From c5b30ba27fc87702024bd37b36ffa7ca92c2f6ef Mon Sep 17 00:00:00 2001
From: Dicky Chiang <dickychiang73@gmail.com>
Date: Sat, 22 Oct 2011 01:50:32 +0800
Subject: [PATCH 04/10] release iw of wifi configure tool

iw is open source code for CLI application to control wifi. Replaced by iwconfig
---
 external/iw/.gitignore  |    7 +
 external/iw/Android.mk  |   48 ++
 external/iw/COPYING     |   16 +
 external/iw/README      |   15 +
 external/iw/bitrate.c   |  140 ++++
 external/iw/connect.c   |  144 ++++
 external/iw/cqm.c       |   54 ++
 external/iw/event.c     |  514 +++++++++++++
 external/iw/genl.c      |  117 +++
 external/iw/ibss.c      |  131 ++++
 external/iw/info.c      |  229 ++++++
 external/iw/interface.c |  416 +++++++++++
 external/iw/iw.8        |   67 ++
 external/iw/iw.c        |  503 +++++++++++++
 external/iw/iw.h        |  167 +++++
 external/iw/link.c      |  260 +++++++
 external/iw/mesh.c      |  367 +++++++++
 external/iw/mpath.c     |  194 +++++
 external/iw/nl80211.h   | 1897 +++++++++++++++++++++++++++++++++++++++++++++++
 external/iw/offch.c     |   43 ++
 external/iw/phy.c       |  309 ++++++++
 external/iw/ps.c        |   83 ++
 external/iw/reason.c    |   50 ++
 external/iw/reg.c       |  191 +++++
 external/iw/scan.c      | 1227 ++++++++++++++++++++++++++++++
 external/iw/sections.c  |    4 +
 external/iw/station.c   |  328 ++++++++
 external/iw/status.c    |   59 ++
 external/iw/survey.c    |   66 ++
 external/iw/util.c      |  521 +++++++++++++
 external/iw/version.c   |    2 +
 external/iw/version.sh  |   24 +
 32 files changed, 8193 insertions(+), 0 deletions(-)
 create mode 100644 external/iw/.gitignore
 create mode 100644 external/iw/Android.mk
 create mode 100644 external/iw/COPYING
 create mode 100644 external/iw/README
 create mode 100644 external/iw/bitrate.c
 create mode 100644 external/iw/connect.c
 create mode 100644 external/iw/cqm.c
 create mode 100644 external/iw/event.c
 create mode 100644 external/iw/genl.c
 create mode 100644 external/iw/ibss.c
 create mode 100644 external/iw/info.c
 create mode 100644 external/iw/interface.c
 create mode 100644 external/iw/iw.8
 create mode 100644 external/iw/iw.c
 create mode 100644 external/iw/iw.h
 create mode 100644 external/iw/link.c
 create mode 100644 external/iw/mesh.c
 create mode 100644 external/iw/mpath.c
 create mode 100644 external/iw/nl80211.h
 create mode 100644 external/iw/offch.c
 create mode 100644 external/iw/phy.c
 create mode 100644 external/iw/ps.c
 create mode 100644 external/iw/reason.c
 create mode 100644 external/iw/reg.c
 create mode 100644 external/iw/scan.c
 create mode 100644 external/iw/sections.c
 create mode 100644 external/iw/station.c
 create mode 100644 external/iw/status.c
 create mode 100644 external/iw/survey.c
 create mode 100644 external/iw/util.c
 create mode 100644 external/iw/version.c
 create mode 100755 external/iw/version.sh

diff --git a/external/iw/.gitignore b/external/iw/.gitignore
new file mode 100644
index 0000000..16bb88b
--- /dev/null
+++ b/external/iw/.gitignore
@@ -0,0 +1,7 @@
+iw
+*~
+*.o
+.config
+version.c
+iw.8.gz
+*-stamp
diff --git a/external/iw/Android.mk b/external/iw/Android.mk
new file mode 100644
index 0000000..1025927
--- /dev/null
+++ b/external/iw/Android.mk
@@ -0,0 +1,48 @@
+LOCAL_PATH:= $(call my-dir)
+
+include $(CLEAR_VARS)
+
+LOCAL_SRC_FILES := \
+	bitrate.c \
+	connect.c \
+	cqm.c \
+	event.c \
+	genl.c \
+	ibss.c \
+	info.c \
+	interface.c \
+	iw.c \
+	link.c \
+	mesh.c \
+	mpath.c \
+	offch.c \
+	phy.c \
+	ps.c \
+	reason.c \
+	reg.c \
+	scan.c \
+	sections.c \
+	station.c \
+	status.c \
+	survey.c \
+	util.c \
+	version.c
+
+LOCAL_C_INCLUDES := \
+	$(LOCAL_PATH) \
+	external/libnl/include
+
+
+LOCAL_NO_DEFAULT_COMPILER_FLAGS := true
+LOCAL_C_INCLUDES += $(LOCAL_PATH)/../libnl/include \
+	$(TARGET_PROJECT_INCLUDES) $(TARGET_C_INCLUDES)
+LOCAL_CFLAGS := $(TARGET_GLOBAL_CFLAGS) $(PRIVATE_ARM_CFLAGS)
+
+LOCAL_SHARED_LIBRARIES += libnl
+LOCAL_MODULE := iw
+LOCAL_LDFLAGS := -Wl,--no-gc-sections
+LOCAL_MODULE_TAGS := eng
+LOCAL_SHARED_LIBRARIES := libnl
+LOCAL_MODULE := iw
+
+include $(BUILD_EXECUTABLE)
diff --git a/external/iw/COPYING b/external/iw/COPYING
new file mode 100644
index 0000000..73e19ac
--- /dev/null
+++ b/external/iw/COPYING
@@ -0,0 +1,16 @@
+Copyright (c) 2007, 2008	Johannes Berg
+Copyright (c) 2007		Andy Lutomirski
+Copyright (c) 2007		Mike Kershaw
+Copyright (c) 2008-2009		Luis R. Rodriguez
+
+Permission to use, copy, modify, and/or distribute this software for any
+purpose with or without fee is hereby granted, provided that the above
+copyright notice and this permission notice appear in all copies.
+
+THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
diff --git a/external/iw/README b/external/iw/README
new file mode 100644
index 0000000..1d0eaae
--- /dev/null
+++ b/external/iw/README
@@ -0,0 +1,15 @@
+
+This is 'iw', a tool to use nl80211.
+
+
+To build iw, just enter 'make'. If that fails, set the
+PKG_CONFIG_PATH environment variable to allow the Makefile
+to find libnl.
+
+
+'iw' is currently maintained at http://git.sipsolutions.net/iw.git/,
+some more documentation is available at
+http://wireless.kernel.org/en/users/Documentation/iw.
+
+Please send all patches to Johannes Berg <johannes@sipsolutions.net>
+and CC linux-wireless@vger.kernel.org for community review.
diff --git a/external/iw/bitrate.c b/external/iw/bitrate.c
new file mode 100644
index 0000000..0012514
--- /dev/null
+++ b/external/iw/bitrate.c
@@ -0,0 +1,140 @@
+#include <errno.h>
+
+#include "nl80211.h"
+#include "iw.h"
+
+
+static int handle_bitrates(struct nl80211_state *state,
+			   struct nl_cb *cb,
+			   struct nl_msg *msg,
+			   int argc, char **argv)
+{
+	struct nlattr *nl_rates, *nl_band;
+	int i;
+	bool have_legacy_24 = false, have_legacy_5 = false;
+	uint8_t legacy_24[32], legacy_5[32];
+	int n_legacy_24 = 0, n_legacy_5 = 0;
+	uint8_t *legacy = NULL;
+	int *n_legacy = NULL;
+	bool have_mcs_24 = false, have_mcs_5 = false;
+#ifdef NL80211_TXRATE_MCS
+	uint8_t mcs_24[77], mcs_5[77];
+	int n_mcs_24 = 0, n_mcs_5 = 0;
+	uint8_t *mcs = NULL;
+	int *n_mcs = NULL;
+#endif
+	enum {
+		S_NONE,
+		S_LEGACY,
+		S_MCS,
+	} parser_state = S_NONE;
+
+	for (i = 0; i < argc; i++) {
+		char *end;
+		double tmpd;
+#ifdef NL80211_TXRATE_MCS
+		long tmpl;
+#endif
+
+		if (strcmp(argv[i], "legacy-2.4") == 0) {
+			if (have_legacy_24)
+				return 1;
+			parser_state = S_LEGACY;
+			legacy = legacy_24;
+			n_legacy = &n_legacy_24;
+			have_legacy_24 = true;
+		} else if (strcmp(argv[i], "legacy-5") == 0) {
+			if (have_legacy_5)
+				return 1;
+			parser_state = S_LEGACY;
+			legacy = legacy_5;
+			n_legacy = &n_legacy_5;
+			have_legacy_5 = true;
+		}
+#ifdef NL80211_TXRATE_MCS
+		else if (strcmp(argv[i], "mcs-2.4") == 0) {
+			if (have_mcs_24)
+				return 1;
+			parser_state = S_MCS;
+			mcs = mcs_24;
+			n_mcs = &n_mcs_24;
+			have_mcs_24 = true;
+		} else if (strcmp(argv[i], "mcs-5") == 0) {
+			if (have_mcs_5)
+				return 1;
+			parser_state = S_MCS;
+			mcs = mcs_5;
+			n_mcs = &n_mcs_5;
+			have_mcs_5 = true;
+		}
+#endif
+		else switch (parser_state) {
+		case S_LEGACY:
+			tmpd = strtod(argv[i], &end);
+			if (*end != '\0')
+				return 1;
+			if (tmpd < 1 || tmpd > 255 * 2)
+				return 1;
+			legacy[(*n_legacy)++] = tmpd * 2;
+			break;
+		case S_MCS:
+#ifdef NL80211_TXRATE_MCS
+			tmpl = strtol(argv[i], &end, 0);
+			if (*end != '\0')
+				return 1;
+			if (tmpl < 0 || tmpl > 255)
+				return 1;
+			mcs[(*n_mcs)++] = tmpl;
+			break;
+#endif
+		default:
+			return 1;
+		}
+	}
+
+	nl_rates = nla_nest_start(msg, NL80211_ATTR_TX_RATES);
+	if (!nl_rates)
+		goto nla_put_failure;
+
+	if (have_legacy_24 || have_mcs_24) {
+		nl_band = nla_nest_start(msg, NL80211_BAND_2GHZ);
+		if (!nl_band)
+			goto nla_put_failure;
+		if (have_legacy_24)
+			nla_put(msg, NL80211_TXRATE_LEGACY, n_legacy_24, legacy_24);
+#ifdef NL80211_TXRATE_MCS
+		if (have_mcs_24)
+			nla_put(msg, NL80211_TXRATE_MCS, n_mcs_24, mcs_24);
+#endif
+		nla_nest_end(msg, nl_band);
+	}
+
+	if (have_legacy_5 || have_mcs_5) {
+		nl_band = nla_nest_start(msg, NL80211_BAND_5GHZ);
+		if (!nl_band)
+			goto nla_put_failure;
+		if (have_legacy_5)
+			nla_put(msg, NL80211_TXRATE_LEGACY, n_legacy_5, legacy_5);
+#ifdef NL80211_TXRATE_MCS
+		if (have_mcs_5)
+			nla_put(msg, NL80211_TXRATE_MCS, n_mcs_5, mcs_5);
+#endif
+		nla_nest_end(msg, nl_band);
+	}
+
+	nla_nest_end(msg, nl_rates);
+
+	return 0;
+ nla_put_failure:
+	return -ENOBUFS;
+}
+
+#define DESCR_LEGACY "[legacy-<2.4|5> <legacy rate in Mbps>*]"
+#ifdef NL80211_TXRATE_MCS
+#define DESCR DESCR_LEGACY " [mcs-<2.4|5> <MCS index>*]"
+#else
+#define DESCR DESCR_LEGACY
+#endif
+
+COMMAND(set, bitrates, DESCR, NL80211_CMD_SET_TX_BITRATE_MASK, 0, CIB_NETDEV,
+	handle_bitrates, "Sets up the specified rate masks.");
diff --git a/external/iw/connect.c b/external/iw/connect.c
new file mode 100644
index 0000000..1af4e0d
--- /dev/null
+++ b/external/iw/connect.c
@@ -0,0 +1,144 @@
+#include <errno.h>
+
+#include <netlink/genl/genl.h>
+#include <netlink/genl/family.h>
+#include <netlink/genl/ctrl.h>
+#include <netlink/msg.h>
+#include <netlink/attr.h>
+
+#include "nl80211.h"
+#include "iw.h"
+
+static int iw_conn(struct nl80211_state *state, struct nl_cb *cb,
+		   struct nl_msg *msg, int argc, char **argv)
+{
+	char *end;
+	unsigned char bssid[6];
+	int freq;
+
+	if (argc < 1)
+		return 1;
+
+	/* SSID */
+	NLA_PUT(msg, NL80211_ATTR_SSID, strlen(argv[0]), argv[0]);
+	argv++;
+	argc--;
+
+	/* freq */
+	if (argc) {
+		freq = strtoul(argv[0], &end, 10);
+		if (*end == '\0') {
+			NLA_PUT_U32(msg, NL80211_ATTR_WIPHY_FREQ, freq);
+			argv++;
+			argc--;
+		}
+	}
+
+	/* bssid */
+	if (argc) {
+		if (mac_addr_a2n(bssid, argv[0]) == 0) {
+			NLA_PUT(msg, NL80211_ATTR_MAC, 6, bssid);
+			argv++;
+			argc--;
+		}
+	}
+
+	if (!argc)
+		return 0;
+
+	if (strcmp(*argv, "key") != 0 && strcmp(*argv, "keys") != 0)
+		return 1;
+
+	argv++;
+	argc--;
+
+	return parse_keys(msg, argv, argc);
+ nla_put_failure:
+	return -ENOSPC;
+}
+
+static int disconnect(struct nl80211_state *state,
+		      struct nl_cb *cb,
+		      struct nl_msg *msg,
+		      int argc, char **argv)
+{
+	return 0;
+}
+TOPLEVEL(disconnect, NULL,
+	NL80211_CMD_DISCONNECT, 0, CIB_NETDEV, disconnect,
+	"Disconnect from the current network.");
+
+static int iw_connect(struct nl80211_state *state, struct nl_cb *cb,
+		      struct nl_msg *msg, int argc, char **argv)
+{
+	char **conn_argv, *dev = argv[0];
+	static const __u32 cmds[] = {
+		NL80211_CMD_CONNECT,
+	};
+	struct print_event_args printargs = { };
+	int conn_argc, err;
+	bool wait = false;
+	int i;
+
+	/* strip "wlan0 connect" */
+	argc -= 2;
+	argv += 2;
+
+	/* check -w */
+	if (argc && strcmp(argv[0], "-w") == 0) {
+		wait = true;
+		argc--;
+		argv++;
+	}
+
+	conn_argc = 3 + argc;
+	conn_argv = calloc(conn_argc, sizeof(*conn_argv));
+	if (!conn_argv)
+		return -ENOMEM;
+
+	err = __prepare_listen_events(state);
+	if (err)
+		return err;
+
+	conn_argv[0] = dev;
+	conn_argv[1] = "connect";
+	conn_argv[2] = "establish";
+	for (i = 0; i < argc; i++)
+		conn_argv[i + 3] = argv[i];
+	err = handle_cmd(state, II_NETDEV, conn_argc, conn_argv);
+	free(conn_argv);
+	if (err)
+		return err;
+
+	if (!wait)
+		return 0;
+
+	/*
+	 * WARNING: DO NOT COPY THIS CODE INTO YOUR APPLICATION
+	 *
+	 * This code has a bug:
+	 *
+	 * It is possible for a connect result message from another
+	 * connect attempt to be processed here first, because we
+	 * start listening to the multicast group before starting
+	 * our own connect request, which may succeed but we get a
+	 * fail message from a previous attempt that raced with us,
+	 * or similar.
+	 *
+	 * The only proper way to fix this would be to listen to events
+	 * before sending the command, and for the kernel to send the
+	 * connect request or a cookie along with the event, so that you
+	 * can match up whether the connect _you_ requested was finished
+	 * or aborted.
+	 *
+	 * Alas, the kernel doesn't do that (yet).
+	 */
+
+	__do_listen_events(state, ARRAY_SIZE(cmds), cmds, &printargs);
+	return 0;
+}
+TOPLEVEL(connect, "[-w] <SSID> [<freq in MHz>] [<bssid>] [key 0:abcde d:1:6162636465]",
+	0, 0, CIB_NETDEV, iw_connect,
+	"Join the network with the given SSID (and frequency, BSSID).\n"
+	"With -w, wait for the connect to finish or fail.");
+HIDDEN(connect, establish, "", NL80211_CMD_CONNECT, 0, CIB_NETDEV, iw_conn);
diff --git a/external/iw/cqm.c b/external/iw/cqm.c
new file mode 100644
index 0000000..3da2b54
--- /dev/null
+++ b/external/iw/cqm.c
@@ -0,0 +1,54 @@
+#include <errno.h>
+
+#include <netlink/genl/genl.h>
+#include <netlink/genl/family.h>
+#include <netlink/genl/ctrl.h>
+#include <netlink/msg.h>
+#include <netlink/attr.h>
+
+#include "nl80211.h"
+#include "iw.h"
+
+static int iw_cqm_rssi(struct nl80211_state *state, struct nl_cb *cb,
+		       struct nl_msg *msg, int argc, char **argv)
+{
+	struct nl_msg *cqm = NULL;
+	int thold = 0;
+	int hyst = 0;
+	int ret = -ENOSPC;
+
+	/* get the required args */
+	if (argc < 1 || argc > 2)
+		return 1;
+
+	if (strcmp(argv[0], "off")) {
+		thold = atoi(argv[0]);
+
+		if (thold == 0)
+			return -EINVAL;
+
+		if (argc == 2)
+			hyst = atoi(argv[1]);
+	}
+
+	/* connection quality monitor attributes */
+	cqm = nlmsg_alloc();
+
+	NLA_PUT_U32(cqm, NL80211_ATTR_CQM_RSSI_THOLD, thold);
+	NLA_PUT_U32(cqm, NL80211_ATTR_CQM_RSSI_HYST, hyst);
+
+	nla_put_nested(msg, NL80211_ATTR_CQM, cqm);
+	ret = 0;
+
+ nla_put_failure:
+	nlmsg_free(cqm);
+	return ret;
+}
+
+TOPLEVEL(cqm, "",
+	 0, 0, CIB_NETDEV, NULL,
+	 "Configure the WLAN connection quality monitor.\n");
+
+COMMAND(cqm, rssi, "<threshold|off> [<hysteresis>]",
+	NL80211_CMD_SET_CQM, 0, CIB_NETDEV, iw_cqm_rssi,
+	"Set connection quality monitor RSSI threshold.\n");
diff --git a/external/iw/event.c b/external/iw/event.c
new file mode 100644
index 0000000..6f3faa2
--- /dev/null
+++ b/external/iw/event.c
@@ -0,0 +1,514 @@
+#include <stdint.h>
+#include <stdbool.h>
+#include <net/if.h>
+#include <errno.h>
+#include "iw.h"
+
+static int no_seq_check(struct nl_msg *msg, void *arg)
+{
+	return NL_OK;
+}
+
+struct ieee80211_beacon_channel {
+	__u16 center_freq;
+	bool passive_scan;
+	bool no_ibss;
+};
+
+static int parse_beacon_hint_chan(struct nlattr *tb,
+				  struct ieee80211_beacon_channel *chan)
+{
+	struct nlattr *tb_freq[NL80211_FREQUENCY_ATTR_MAX + 1];
+	static struct nla_policy beacon_freq_policy[NL80211_FREQUENCY_ATTR_MAX + 1] = {
+		[NL80211_FREQUENCY_ATTR_FREQ] = { .type = NLA_U32 },
+		[NL80211_FREQUENCY_ATTR_PASSIVE_SCAN] = { .type = NLA_FLAG },
+		[NL80211_FREQUENCY_ATTR_NO_IBSS] = { .type = NLA_FLAG },
+	};
+
+	if (nla_parse_nested(tb_freq,
+			     NL80211_FREQUENCY_ATTR_MAX,
+			     tb,
+			     beacon_freq_policy))
+		return -EINVAL;
+
+	chan->center_freq = nla_get_u32(tb_freq[NL80211_FREQUENCY_ATTR_FREQ]);
+
+	if (tb_freq[NL80211_FREQUENCY_ATTR_PASSIVE_SCAN])
+		chan->passive_scan = true;
+	if (tb_freq[NL80211_FREQUENCY_ATTR_NO_IBSS])
+		chan->no_ibss = true;
+
+	return 0;
+}
+
+static void print_frame(struct print_event_args *args, struct nlattr *attr)
+{
+	uint8_t *frame;
+	size_t len;
+	int i;
+	char macbuf[6*3];
+	uint16_t tmp;
+
+	if (!attr)
+		printf(" [no frame]");
+
+	frame = nla_data(attr);
+	len = nla_len(attr);
+
+	if (len < 26) {
+		printf(" [invalid frame: ");
+		goto print_frame;
+	}
+
+	mac_addr_n2a(macbuf, frame + 10);
+	printf(" %s -> ", macbuf);
+	mac_addr_n2a(macbuf, frame + 4);
+	printf("%s", macbuf);
+
+	switch (frame[0] & 0xfc) {
+	case 0x10: /* assoc resp */
+	case 0x30: /* reassoc resp */
+		/* status */
+		tmp = (frame[27] << 8) + frame[26];
+		printf(" status: %d: %s", tmp, get_status_str(tmp));
+		break;
+	case 0x00: /* assoc req */
+	case 0x20: /* reassoc req */
+		break;
+	case 0xb0: /* auth */
+		/* status */
+		tmp = (frame[29] << 8) + frame[28];
+		printf(" status: %d: %s", tmp, get_status_str(tmp));
+		break;
+		break;
+	case 0xa0: /* disassoc */
+	case 0xc0: /* deauth */
+		/* reason */
+		tmp = (frame[25] << 8) + frame[24];
+		printf(" reason %d: %s", tmp, get_reason_str(tmp));
+		break;
+	}
+
+	if (!args->frame)
+		return;
+
+	printf(" [frame:");
+
+ print_frame:
+	for (i = 0; i < len; i++)
+		printf(" %.02x", frame[i]);
+	printf("]");
+}
+
+static void parse_cqm_event(struct nlattr *tb)
+{
+	static struct nla_policy cqm_policy[NL80211_ATTR_CQM_MAX + 1] = {
+		[NL80211_ATTR_CQM_RSSI_THOLD] = { .type = NLA_U32 },
+		[NL80211_ATTR_CQM_RSSI_HYST] = { .type = NLA_U32 },
+		[NL80211_ATTR_CQM_RSSI_THRESHOLD_EVENT] = { .type = NLA_U32 },
+	};
+	struct nlattr *cqm[NL80211_ATTR_CQM_MAX + 1];
+
+	printf("connection quality monitor event: ");
+
+	if (!tb || nla_parse_nested(cqm, NL80211_ATTR_CQM_MAX, tb, cqm_policy)) {
+		printf("missing data!\n");
+		return;
+	}
+
+	if (cqm[NL80211_ATTR_CQM_RSSI_THRESHOLD_EVENT]) {
+		enum nl80211_cqm_rssi_threshold_event rssi_event;
+		rssi_event = nla_get_u32(cqm[NL80211_ATTR_CQM_RSSI_THRESHOLD_EVENT]);
+		if (rssi_event == NL80211_CQM_RSSI_THRESHOLD_EVENT_HIGH)
+			printf("RSSI went above threshold");
+		else
+			printf("RSSI went below threshold");
+	}
+	printf("\n");
+}
+
+
+static int print_event(struct nl_msg *msg, void *arg)
+{
+	struct genlmsghdr *gnlh = nlmsg_data(nlmsg_hdr(msg));
+	struct nlattr *tb[NL80211_ATTR_MAX + 1], *nst;
+	struct print_event_args *args = arg;
+	char ifname[100];
+	char macbuf[6*3];
+	__u8 reg_type;
+	struct ieee80211_beacon_channel chan_before_beacon,  chan_after_beacon;
+	__u32 wiphy_idx = 0;
+	int rem_nst;
+	__u16 status;
+
+	if (args->time || args->reltime) {
+		unsigned long long usecs, previous;
+
+		previous = 1000000ULL * args->ts.tv_sec + args->ts.tv_usec;
+		gettimeofday(&args->ts, NULL);
+		usecs = 1000000ULL * args->ts.tv_sec + args->ts.tv_usec;
+		if (args->reltime) {
+			if (!args->have_ts) {
+				usecs = 0;
+				args->have_ts = true;
+			} else
+				usecs -= previous;
+		}
+		printf("%llu.%06llu: ", usecs/1000000, usecs % 1000000);
+	}
+
+	nla_parse(tb, NL80211_ATTR_MAX, genlmsg_attrdata(gnlh, 0),
+		  genlmsg_attrlen(gnlh, 0), NULL);
+
+	if (tb[NL80211_ATTR_IFINDEX] && tb[NL80211_ATTR_WIPHY]) {
+		if_indextoname(nla_get_u32(tb[NL80211_ATTR_IFINDEX]), ifname);
+		printf("%s (phy #%d): ", ifname, nla_get_u32(tb[NL80211_ATTR_WIPHY]));
+	} else if (tb[NL80211_ATTR_IFINDEX]) {
+		if_indextoname(nla_get_u32(tb[NL80211_ATTR_IFINDEX]), ifname);
+		printf("%s: ", ifname);
+	} else if (tb[NL80211_ATTR_WIPHY]) {
+		printf("phy #%d: ", nla_get_u32(tb[NL80211_ATTR_WIPHY]));
+	}
+
+	switch (gnlh->cmd) {
+	case NL80211_CMD_NEW_WIPHY:
+		printf("renamed to %s\n", nla_get_string(tb[NL80211_ATTR_WIPHY_NAME]));
+		break;
+	case NL80211_CMD_TRIGGER_SCAN:
+		printf("scan started\n");
+		break;
+	case NL80211_CMD_NEW_SCAN_RESULTS:
+		printf("scan finished:");
+	case NL80211_CMD_SCAN_ABORTED:
+		if (gnlh->cmd == NL80211_CMD_SCAN_ABORTED)
+			printf("scan aborted:");
+		if (tb[NL80211_ATTR_SCAN_FREQUENCIES]) {
+			nla_for_each_nested(nst, tb[NL80211_ATTR_SCAN_FREQUENCIES], rem_nst)
+				printf(" %d", nla_get_u32(nst));
+			printf(",");
+		}
+		if (tb[NL80211_ATTR_SCAN_SSIDS]) {
+			nla_for_each_nested(nst, tb[NL80211_ATTR_SCAN_SSIDS], rem_nst) {
+				printf(" \"");
+				print_ssid_escaped(nla_len(nst), nla_data(nst));
+				printf("\"");
+			}
+		}
+		printf("\n");
+		break;
+	case NL80211_CMD_REG_CHANGE:
+		printf("regulatory domain change: ");
+
+		reg_type = nla_get_u8(tb[NL80211_ATTR_REG_TYPE]);
+
+		switch (reg_type) {
+		case NL80211_REGDOM_TYPE_COUNTRY:
+			printf("set to %s by %s request",
+			       nla_get_string(tb[NL80211_ATTR_REG_ALPHA2]),
+			       reg_initiator_to_string(nla_get_u8(tb[NL80211_ATTR_REG_INITIATOR])));
+			if (tb[NL80211_ATTR_WIPHY])
+				printf(" on phy%d", nla_get_u32(tb[NL80211_ATTR_WIPHY]));
+			break;
+		case NL80211_REGDOM_TYPE_WORLD:
+			printf("set to world roaming by %s request",
+			       reg_initiator_to_string(nla_get_u8(tb[NL80211_ATTR_REG_INITIATOR])));
+			break;
+		case NL80211_REGDOM_TYPE_CUSTOM_WORLD:
+			printf("custom world roaming rules in place on phy%d by %s request",
+			       nla_get_u32(tb[NL80211_ATTR_WIPHY]),
+			       reg_initiator_to_string(nla_get_u32(tb[NL80211_ATTR_REG_INITIATOR])));
+			break;
+		case NL80211_REGDOM_TYPE_INTERSECTION:
+			printf("intersection used due to a request made by %s",
+			       reg_initiator_to_string(nla_get_u32(tb[NL80211_ATTR_REG_INITIATOR])));
+			if (tb[NL80211_ATTR_WIPHY])
+				printf(" on phy%d", nla_get_u32(tb[NL80211_ATTR_WIPHY]));
+			break;
+		default:
+			printf("unknown source (upgrade this utility)");
+			break;
+		}
+
+		printf("\n");
+		break;
+	case NL80211_CMD_REG_BEACON_HINT:
+
+		wiphy_idx = nla_get_u32(tb[NL80211_ATTR_WIPHY]);
+
+		memset(&chan_before_beacon, 0, sizeof(chan_before_beacon));
+		memset(&chan_after_beacon, 0, sizeof(chan_after_beacon));
+
+		if (parse_beacon_hint_chan(tb[NL80211_ATTR_FREQ_BEFORE],
+					   &chan_before_beacon))
+			break;
+		if (parse_beacon_hint_chan(tb[NL80211_ATTR_FREQ_AFTER],
+					   &chan_after_beacon))
+			break;
+
+		if (chan_before_beacon.center_freq != chan_after_beacon.center_freq)
+			break;
+
+		/* A beacon hint is sent _only_ if something _did_ change */
+		printf("beacon hint:\n");
+
+		printf("phy%d %d MHz [%d]:\n",
+		       wiphy_idx,
+		       chan_before_beacon.center_freq,
+		       ieee80211_frequency_to_channel(chan_before_beacon.center_freq));
+
+		if (chan_before_beacon.passive_scan && !chan_after_beacon.passive_scan)
+			printf("\to active scanning enabled\n");
+		if (chan_before_beacon.no_ibss && !chan_after_beacon.no_ibss)
+			printf("\to beaconing enabled\n");
+
+		break;
+	case NL80211_CMD_NEW_STATION:
+		mac_addr_n2a(macbuf, nla_data(tb[NL80211_ATTR_MAC]));
+		printf("new station %s\n", macbuf);
+		break;
+	case NL80211_CMD_JOIN_IBSS:
+		mac_addr_n2a(macbuf, nla_data(tb[NL80211_ATTR_MAC]));
+		printf("IBSS %s joined\n", macbuf);
+		break;
+	case NL80211_CMD_AUTHENTICATE:
+		printf("auth");
+		if (tb[NL80211_ATTR_FRAME])
+			print_frame(args, tb[NL80211_ATTR_FRAME]);
+		else if (tb[NL80211_ATTR_TIMED_OUT])
+			printf(": timed out");
+		else
+			printf(": unknown event");
+		printf("\n");
+		break;
+	case NL80211_CMD_ASSOCIATE:
+		printf("assoc");
+		if (tb[NL80211_ATTR_FRAME])
+			print_frame(args, tb[NL80211_ATTR_FRAME]);
+		else if (tb[NL80211_ATTR_TIMED_OUT])
+			printf(": timed out");
+		else
+			printf(": unknown event");
+		printf("\n");
+		break;
+	case NL80211_CMD_DEAUTHENTICATE:
+		printf("deauth");
+		print_frame(args, tb[NL80211_ATTR_FRAME]);
+		printf("\n");
+		break;
+	case NL80211_CMD_DISASSOCIATE:
+		printf("disassoc");
+		print_frame(args, tb[NL80211_ATTR_FRAME]);
+		printf("\n");
+		break;
+	case NL80211_CMD_CONNECT:
+		status = 0;
+		if (!tb[NL80211_ATTR_STATUS_CODE])
+			printf("unknown connect status");
+		else if (nla_get_u16(tb[NL80211_ATTR_STATUS_CODE]) == 0)
+			printf("connected");
+		else {
+			status = nla_get_u16(tb[NL80211_ATTR_STATUS_CODE]);
+			printf("failed to connect");
+		}
+		if (tb[NL80211_ATTR_MAC]) {
+			mac_addr_n2a(macbuf, nla_data(tb[NL80211_ATTR_MAC]));
+			printf(" to %s", macbuf);
+		}
+		if (status)
+			printf(", status: %d: %s", status, get_status_str(status));
+		printf("\n");
+		break;
+	case NL80211_CMD_ROAM:
+		printf("roamed");
+		if (tb[NL80211_ATTR_MAC]) {
+			mac_addr_n2a(macbuf, nla_data(tb[NL80211_ATTR_MAC]));
+			printf(" to %s", macbuf);
+		}
+		printf("\n");
+		break;
+	case NL80211_CMD_DISCONNECT:
+		printf("disconnected");
+		if (tb[NL80211_ATTR_DISCONNECTED_BY_AP])
+			printf(" (by AP)");
+		else
+			printf(" (local request)");
+		if (tb[NL80211_ATTR_REASON_CODE])
+			printf(" reason: %d: %s", nla_get_u16(tb[NL80211_ATTR_REASON_CODE]),
+				get_reason_str(nla_get_u16(tb[NL80211_ATTR_REASON_CODE])));
+		printf("\n");
+		break;
+	case NL80211_CMD_REMAIN_ON_CHANNEL:
+		printf("remain on freq %d (%dms, cookie %llx)\n",
+			nla_get_u32(tb[NL80211_ATTR_WIPHY_FREQ]),
+			nla_get_u32(tb[NL80211_ATTR_DURATION]),
+			(unsigned long long)nla_get_u64(tb[NL80211_ATTR_COOKIE]));
+		break;
+	case NL80211_CMD_CANCEL_REMAIN_ON_CHANNEL:
+		printf("done with remain on freq %d (cookie %llx)\n",
+			nla_get_u32(tb[NL80211_ATTR_WIPHY_FREQ]),
+			(unsigned long long)nla_get_u64(tb[NL80211_ATTR_COOKIE]));
+		break;
+	case NL80211_CMD_NOTIFY_CQM:
+		parse_cqm_event(tb[NL80211_ATTR_CQM]);
+		break;
+	default:
+		printf("unknown event %d\n", gnlh->cmd);
+		break;
+	}
+
+	fflush(stdout);
+	return NL_SKIP;
+}
+
+struct wait_event {
+	int n_cmds;
+	const __u32 *cmds;
+	__u32 cmd;
+	struct print_event_args *pargs;
+};
+
+static int wait_event(struct nl_msg *msg, void *arg)
+{
+	struct wait_event *wait = arg;
+	struct genlmsghdr *gnlh = nlmsg_data(nlmsg_hdr(msg));
+	int i;
+
+	for (i = 0; i < wait->n_cmds; i++) {
+		if (gnlh->cmd == wait->cmds[i]) {
+			wait->cmd = gnlh->cmd;
+			if (wait->pargs)
+				print_event(msg, wait->pargs);
+		}
+	}
+
+	return NL_SKIP;
+}
+
+int __prepare_listen_events(struct nl80211_state *state)
+{
+	int mcid, ret;
+
+	/* Configuration multicast group */
+	mcid = nl_get_multicast_id(state->nl_sock, "nl80211", "config");
+	if (mcid < 0)
+		return mcid;
+
+	ret = nl_socket_add_membership(state->nl_sock, mcid);
+	if (ret)
+		return ret;
+
+	/* Scan multicast group */
+	mcid = nl_get_multicast_id(state->nl_sock, "nl80211", "scan");
+	if (mcid >= 0) {
+		ret = nl_socket_add_membership(state->nl_sock, mcid);
+		if (ret)
+			return ret;
+	}
+
+	/* Regulatory multicast group */
+	mcid = nl_get_multicast_id(state->nl_sock, "nl80211", "regulatory");
+	if (mcid >= 0) {
+		ret = nl_socket_add_membership(state->nl_sock, mcid);
+		if (ret)
+			return ret;
+	}
+
+	/* MLME multicast group */
+	mcid = nl_get_multicast_id(state->nl_sock, "nl80211", "mlme");
+	if (mcid >= 0) {
+		ret = nl_socket_add_membership(state->nl_sock, mcid);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+__u32 __do_listen_events(struct nl80211_state *state,
+			 const int n_waits, const __u32 *waits,
+			 struct print_event_args *args)
+{
+	struct nl_cb *cb = nl_cb_alloc(iw_debug ? NL_CB_DEBUG : NL_CB_DEFAULT);
+	struct wait_event wait_ev;
+
+	if (!cb) {
+		fprintf(stderr, "failed to allocate netlink callbacks\n");
+		return -ENOMEM;
+	}
+
+	/* no sequence checking for multicast messages */
+	nl_cb_set(cb, NL_CB_SEQ_CHECK, NL_CB_CUSTOM, no_seq_check, NULL);
+
+	if (n_waits && waits) {
+		wait_ev.cmds = waits;
+		wait_ev.n_cmds = n_waits;
+		wait_ev.pargs = args;
+		nl_cb_set(cb, NL_CB_VALID, NL_CB_CUSTOM, wait_event, &wait_ev);
+	} else
+		nl_cb_set(cb, NL_CB_VALID, NL_CB_CUSTOM, print_event, args);
+
+	wait_ev.cmd = 0;
+
+	while (!wait_ev.cmd)
+		nl_recvmsgs(state->nl_sock, cb);
+
+	nl_cb_put(cb);
+
+	return wait_ev.cmd;
+}
+
+__u32 listen_events(struct nl80211_state *state,
+		    const int n_waits, const __u32 *waits)
+{
+	int ret;
+
+	ret = __prepare_listen_events(state);
+	if (ret)
+		return ret;
+
+	return __do_listen_events(state, n_waits, waits, NULL);
+}
+
+static int print_events(struct nl80211_state *state,
+			struct nl_cb *cb,
+			struct nl_msg *msg,
+			int argc, char **argv)
+{
+	struct print_event_args args;
+	int ret;
+
+	memset(&args, 0, sizeof(args));
+
+	argc--;
+	argv++;
+
+	while (argc > 0) {
+		if (strcmp(argv[0], "-f") == 0)
+			args.frame = true;
+		else if (strcmp(argv[0], "-t") == 0)
+			args.time = true;
+		else if (strcmp(argv[0], "-r") == 0)
+			args.reltime = true;
+		else
+			return 1;
+		argc--;
+		argv++;
+	}
+
+	if (args.time && args.reltime)
+		return 1;
+
+	if (argc)
+		return 1;
+
+	ret = __prepare_listen_events(state);
+	if (ret)
+		return ret;
+
+	return __do_listen_events(state, 0, NULL, &args);
+}
+TOPLEVEL(event, "[-t] [-r] [-f]", 0, 0, CIB_NONE, print_events,
+	"Monitor events from the kernel.\n"
+	"-t - print timestamp\n"
+	"-r - print relative timstamp\n"
+	"-f - print full frame for auth/assoc etc.");
diff --git a/external/iw/genl.c b/external/iw/genl.c
new file mode 100644
index 0000000..af08676
--- /dev/null
+++ b/external/iw/genl.c
@@ -0,0 +1,117 @@
+/*
+ * This ought to be provided by libnl
+ */
+
+#include <asm/errno.h>
+#include <netlink/genl/genl.h>
+#include <netlink/genl/family.h>
+#include <netlink/genl/ctrl.h>  
+#include <netlink/msg.h>
+#include <netlink/attr.h>
+#include <linux/genetlink.h>
+
+#include "iw.h"
+
+static int error_handler(struct sockaddr_nl *nla, struct nlmsgerr *err,
+			 void *arg)
+{
+	int *ret = arg;
+	*ret = err->error;
+	return NL_STOP;
+}
+
+static int ack_handler(struct nl_msg *msg, void *arg)
+{
+	int *ret = arg;
+	*ret = 0;
+	return NL_STOP;
+}
+
+struct handler_args {
+	const char *group;
+	int id;
+};
+
+static int family_handler(struct nl_msg *msg, void *arg)
+{
+	struct handler_args *grp = arg;
+	struct nlattr *tb[CTRL_ATTR_MAX + 1];
+	struct genlmsghdr *gnlh = nlmsg_data(nlmsg_hdr(msg));
+	struct nlattr *mcgrp;
+	int rem_mcgrp;
+
+	nla_parse(tb, CTRL_ATTR_MAX, genlmsg_attrdata(gnlh, 0),
+		  genlmsg_attrlen(gnlh, 0), NULL);
+
+        if (!tb[CTRL_ATTR_MCAST_GROUPS])
+		return NL_SKIP;
+
+	nla_for_each_nested(mcgrp, tb[CTRL_ATTR_MCAST_GROUPS], rem_mcgrp) {
+		struct nlattr *tb_mcgrp[CTRL_ATTR_MCAST_GRP_MAX + 1];
+
+		nla_parse(tb_mcgrp, CTRL_ATTR_MCAST_GRP_MAX,
+			  nla_data(mcgrp), nla_len(mcgrp), NULL);
+
+		if (!tb_mcgrp[CTRL_ATTR_MCAST_GRP_NAME] ||
+		    !tb_mcgrp[CTRL_ATTR_MCAST_GRP_ID])
+			continue;
+		if (strncmp(nla_data(tb_mcgrp[CTRL_ATTR_MCAST_GRP_NAME]),
+			    grp->group, nla_len(tb_mcgrp[CTRL_ATTR_MCAST_GRP_NAME])))
+			continue;
+		grp->id = nla_get_u32(tb_mcgrp[CTRL_ATTR_MCAST_GRP_ID]);
+		break;
+	}
+	
+	return NL_SKIP;
+}
+
+int nl_get_multicast_id(struct nl_sock *sock, const char *family, const char *group)
+{
+	struct nl_msg *msg;
+	struct nl_cb *cb;
+	int ret, ctrlid;
+	struct handler_args grp = {
+		.group = group,
+		.id = -ENOENT,
+	};
+
+	msg = nlmsg_alloc();
+	if (!msg)
+		return -ENOMEM;
+
+	cb = nl_cb_alloc(NL_CB_DEFAULT);
+	if (!cb) {
+		ret = -ENOMEM;
+		goto out_fail_cb;
+	}
+
+	ctrlid = genl_ctrl_resolve(sock, "nlctrl");
+
+        genlmsg_put(msg, 0, 0, ctrlid, 0,
+		    0, CTRL_CMD_GETFAMILY, 0);
+
+	ret = -ENOBUFS;
+	NLA_PUT_STRING(msg, CTRL_ATTR_FAMILY_NAME, family);
+
+	ret = nl_send_auto_complete(sock, msg);
+	if (ret < 0)
+		goto out;
+
+	ret = 1;
+
+	nl_cb_err(cb, NL_CB_CUSTOM, error_handler, &ret);
+	nl_cb_set(cb, NL_CB_ACK, NL_CB_CUSTOM, ack_handler, &ret);
+	nl_cb_set(cb, NL_CB_VALID, NL_CB_CUSTOM, family_handler, &grp);
+
+	while (ret > 0)
+		nl_recvmsgs(sock, cb);
+
+	if (ret == 0)
+		ret = grp.id;
+ nla_put_failure:
+ out:
+	nl_cb_put(cb);
+ out_fail_cb:
+	nlmsg_free(msg);
+	return ret;
+}
diff --git a/external/iw/ibss.c b/external/iw/ibss.c
new file mode 100644
index 0000000..84ea7f2
--- /dev/null
+++ b/external/iw/ibss.c
@@ -0,0 +1,131 @@
+#ifndef _POSIX_SOURCE
+#define _POSIX_SOURCE
+#endif
+#include <errno.h>
+#include <string.h>
+
+#include <netlink/genl/genl.h>
+#include <netlink/genl/family.h>
+#include <netlink/genl/ctrl.h>
+#include <netlink/msg.h>
+#include <netlink/attr.h>
+
+#include "nl80211.h"
+#include "iw.h"
+
+SECTION(ibss);
+
+static int join_ibss(struct nl80211_state *state,
+		     struct nl_cb *cb,
+		     struct nl_msg *msg,
+		     int argc, char **argv)
+{
+	char *end;
+	unsigned char abssid[6];
+	unsigned char rates[NL80211_MAX_SUPP_RATES];
+	int n_rates = 0;
+	char *value = NULL, *sptr = NULL;
+	float rate;
+	int bintval;
+
+	if (argc < 2)
+		return 1;
+
+	/* SSID */
+	NLA_PUT(msg, NL80211_ATTR_SSID, strlen(argv[0]), argv[0]);
+	argv++;
+	argc--;
+
+	/* freq */
+	NLA_PUT_U32(msg, NL80211_ATTR_WIPHY_FREQ,
+		    strtoul(argv[0], &end, 10));
+	if (*end != '\0')
+		return 1;
+	argv++;
+	argc--;
+
+	if (argc && strcmp(argv[0], "fixed-freq") == 0) {
+		NLA_PUT_FLAG(msg, NL80211_ATTR_FREQ_FIXED);
+		argv++;
+		argc--;
+	}
+
+	if (argc) {
+		if (mac_addr_a2n(abssid, argv[0]) == 0) {
+			NLA_PUT(msg, NL80211_ATTR_MAC, 6, abssid);
+			argv++;
+			argc--;
+		}
+	}
+
+	if (argc > 1 && strcmp(argv[0], "beacon-interval") == 0) {
+		argv++;
+		argc--;
+		bintval = strtoul(argv[0], &end, 10);
+		if (*end != '\0')
+			return 1;
+		NLA_PUT_U32(msg, NL80211_ATTR_BEACON_INTERVAL, bintval);
+		argv++;
+		argc--;
+	}
+
+	/* basic rates */
+	if (argc > 1 && strcmp(argv[0], "basic-rates") == 0) {
+		argv++;
+		argc--;
+
+		value = strtok_r(argv[0], ",", &sptr);
+
+		while (value && n_rates < NL80211_MAX_SUPP_RATES) {
+			rate = strtod(value, &end);
+			rates[n_rates] = rate * 2;
+
+			/* filter out suspicious values  */
+			if (*end != '\0' || !rates[n_rates] ||
+			    rate*2 != rates[n_rates])
+				return 1;
+
+			n_rates++;
+			value = strtok_r(NULL, ",", &sptr);
+		}
+
+		NLA_PUT(msg, NL80211_ATTR_BSS_BASIC_RATES, n_rates, rates);
+
+		argv++;
+		argc--;
+	}
+
+	if (!argc)
+		return 0;
+
+	if (strcmp(*argv, "key") != 0 && strcmp(*argv, "keys") != 0)
+		return 1;
+
+	argv++;
+	argc--;
+
+	return parse_keys(msg, argv, argc);
+ nla_put_failure:
+	return -ENOSPC;
+}
+
+static int leave_ibss(struct nl80211_state *state,
+		      struct nl_cb *cb,
+		      struct nl_msg *msg,
+		      int argc, char **argv)
+{
+	return 0;
+}
+COMMAND(ibss, leave, NULL,
+	NL80211_CMD_LEAVE_IBSS, 0, CIB_NETDEV, leave_ibss,
+	"Leave the current IBSS cell.");
+COMMAND(ibss, join,
+	"<SSID> <freq in MHz> [fixed-freq] [<fixed bssid>] [beacon-interval "
+	"<TU>] [basic-rates <rate in Mbps,rate2,...>] [key d:0:abcde]",
+	NL80211_CMD_JOIN_IBSS, 0, CIB_NETDEV, join_ibss,
+	"Join the IBSS cell with the given SSID, if it doesn't exist create\n"
+	"it on the given frequency. When fixed frequency is requested, don't\n"
+	"join/create a cell on a different frequency. When a fixed BSSID is\n"
+	"requested use that BSSID and do not adopt another cell's BSSID even\n"
+	"if it has higher TSF and the same SSID. If an IBSS is created, create\n"
+	"it with the specified basic-rates and beacon-interval (in TU).");
diff --git a/external/iw/info.c b/external/iw/info.c
new file mode 100644
index 0000000..0783701
--- /dev/null
+++ b/external/iw/info.c
@@ -0,0 +1,229 @@
+#include <stdbool.h>
+#include <errno.h>
+#include <net/if.h>
+
+#include <netlink/genl/genl.h>
+#include <netlink/genl/family.h>
+#include <netlink/genl/ctrl.h>
+#include <netlink/msg.h>
+#include <netlink/attr.h>
+
+#include "nl80211.h"
+#include "iw.h"
+
+static void print_flag(const char *name, int *open)
+{
+	if (!*open)
+		printf(" (");
+	else
+		printf(", ");
+	printf("%s", name);
+	*open = 1;
+}
+
+static int print_phy_handler(struct nl_msg *msg, void *arg)
+{
+	struct nlattr *tb_msg[NL80211_ATTR_MAX + 1];
+	struct genlmsghdr *gnlh = nlmsg_data(nlmsg_hdr(msg));
+
+	struct nlattr *tb_band[NL80211_BAND_ATTR_MAX + 1];
+
+	struct nlattr *tb_freq[NL80211_FREQUENCY_ATTR_MAX + 1];
+	static struct nla_policy freq_policy[NL80211_FREQUENCY_ATTR_MAX + 1] = {
+		[NL80211_FREQUENCY_ATTR_FREQ] = { .type = NLA_U32 },
+		[NL80211_FREQUENCY_ATTR_DISABLED] = { .type = NLA_FLAG },
+		[NL80211_FREQUENCY_ATTR_PASSIVE_SCAN] = { .type = NLA_FLAG },
+		[NL80211_FREQUENCY_ATTR_NO_IBSS] = { .type = NLA_FLAG },
+		[NL80211_FREQUENCY_ATTR_RADAR] = { .type = NLA_FLAG },
+		[NL80211_FREQUENCY_ATTR_MAX_TX_POWER] = { .type = NLA_U32 },
+	};
+
+	struct nlattr *tb_rate[NL80211_BITRATE_ATTR_MAX + 1];
+	static struct nla_policy rate_policy[NL80211_BITRATE_ATTR_MAX + 1] = {
+		[NL80211_BITRATE_ATTR_RATE] = { .type = NLA_U32 },
+		[NL80211_BITRATE_ATTR_2GHZ_SHORTPREAMBLE] = { .type = NLA_FLAG },
+	};
+
+	struct nlattr *nl_band;
+	struct nlattr *nl_freq;
+	struct nlattr *nl_rate;
+	struct nlattr *nl_mode;
+	struct nlattr *nl_cmd;
+	struct nlattr *nl_if, *nl_ftype;
+	int bandidx = 1;
+	int rem_band, rem_freq, rem_rate, rem_mode, rem_cmd, rem_ftype, rem_if;
+	int open;
+
+	nla_parse(tb_msg, NL80211_ATTR_MAX, genlmsg_attrdata(gnlh, 0),
+		  genlmsg_attrlen(gnlh, 0), NULL);
+
+	if (!tb_msg[NL80211_ATTR_WIPHY_BANDS])
+		return NL_SKIP;
+
+	if (tb_msg[NL80211_ATTR_WIPHY_NAME])
+		printf("Wiphy %s\n", nla_get_string(tb_msg[NL80211_ATTR_WIPHY_NAME]));
+
+	nla_for_each_nested(nl_band, tb_msg[NL80211_ATTR_WIPHY_BANDS], rem_band) {
+		printf("\tBand %d:\n", bandidx);
+		bandidx++;
+
+		nla_parse(tb_band, NL80211_BAND_ATTR_MAX, nla_data(nl_band),
+			  nla_len(nl_band), NULL);
+
+#ifdef NL80211_BAND_ATTR_HT_CAPA
+		if (tb_band[NL80211_BAND_ATTR_HT_CAPA]) {
+			__u16 cap = nla_get_u16(tb_band[NL80211_BAND_ATTR_HT_CAPA]);
+			print_ht_capability(cap);
+		}
+		if (tb_band[NL80211_BAND_ATTR_HT_AMPDU_FACTOR]) {
+			__u8 exponent = nla_get_u8(tb_band[NL80211_BAND_ATTR_HT_AMPDU_FACTOR]);
+			print_ampdu_length(exponent);
+		}
+		if (tb_band[NL80211_BAND_ATTR_HT_AMPDU_DENSITY]) {
+			__u8 spacing = nla_get_u8(tb_band[NL80211_BAND_ATTR_HT_AMPDU_DENSITY]);
+			print_ampdu_spacing(spacing);
+		}
+		if (tb_band[NL80211_BAND_ATTR_HT_MCS_SET] &&
+		    nla_len(tb_band[NL80211_BAND_ATTR_HT_MCS_SET]) == 16)
+			print_ht_mcs(nla_data(tb_band[NL80211_BAND_ATTR_HT_MCS_SET]));
+#endif
+
+		printf("\t\tFrequencies:\n");
+
+		nla_for_each_nested(nl_freq, tb_band[NL80211_BAND_ATTR_FREQS], rem_freq) {
+			uint32_t freq;
+			nla_parse(tb_freq, NL80211_FREQUENCY_ATTR_MAX, nla_data(nl_freq),
+				  nla_len(nl_freq), freq_policy);
+			if (!tb_freq[NL80211_FREQUENCY_ATTR_FREQ])
+				continue;
+			freq = nla_get_u32(tb_freq[NL80211_FREQUENCY_ATTR_FREQ]);
+			printf("\t\t\t* %d MHz [%d]", freq, ieee80211_frequency_to_channel(freq));
+
+			if (tb_freq[NL80211_FREQUENCY_ATTR_MAX_TX_POWER] &&
+			    !tb_freq[NL80211_FREQUENCY_ATTR_DISABLED])
+				printf(" (%.1f dBm)", 0.01 * nla_get_u32(tb_freq[NL80211_FREQUENCY_ATTR_MAX_TX_POWER]));
+
+			open = 0;
+			if (tb_freq[NL80211_FREQUENCY_ATTR_DISABLED]) {
+				print_flag("disabled", &open);
+				goto next;
+			}
+			if (tb_freq[NL80211_FREQUENCY_ATTR_PASSIVE_SCAN])
+				print_flag("passive scanning", &open);
+			if (tb_freq[NL80211_FREQUENCY_ATTR_NO_IBSS])
+				print_flag("no IBSS", &open);
+			if (tb_freq[NL80211_FREQUENCY_ATTR_RADAR])
+				print_flag("radar detection", &open);
+ next:
+			if (open)
+				printf(")");
+			printf("\n");
+		}
+
+		printf("\t\tBitrates (non-HT):\n");
+
+		nla_for_each_nested(nl_rate, tb_band[NL80211_BAND_ATTR_RATES], rem_rate) {
+			nla_parse(tb_rate, NL80211_BITRATE_ATTR_MAX, nla_data(nl_rate),
+				  nla_len(nl_rate), rate_policy);
+			if (!tb_rate[NL80211_BITRATE_ATTR_RATE])
+				continue;
+			printf("\t\t\t* %2.1f Mbps", 0.1 * nla_get_u32(tb_rate[NL80211_BITRATE_ATTR_RATE]));
+			open = 0;
+			if (tb_rate[NL80211_BITRATE_ATTR_2GHZ_SHORTPREAMBLE])
+				print_flag("short preamble supported", &open);
+			if (open)
+				printf(")");
+			printf("\n");
+		}
+	}
+
+	if (tb_msg[NL80211_ATTR_MAX_NUM_SCAN_SSIDS])
+		printf("\tmax # scan SSIDs: %d\n",
+		       nla_get_u8(tb_msg[NL80211_ATTR_MAX_NUM_SCAN_SSIDS]));
+	if (tb_msg[NL80211_ATTR_MAX_SCAN_IE_LEN])
+		printf("\tmax scan IEs length: %d bytes\n",
+		       nla_get_u16(tb_msg[NL80211_ATTR_MAX_SCAN_IE_LEN]));
+
+	if (tb_msg[NL80211_ATTR_WIPHY_FRAG_THRESHOLD]) {
+		unsigned int frag;
+
+		frag = nla_get_u32(tb_msg[NL80211_ATTR_WIPHY_FRAG_THRESHOLD]);
+		if (frag != (unsigned int)-1)
+			printf("\tFragmentation threshold: %d\n", frag);
+	}
+
+	if (tb_msg[NL80211_ATTR_WIPHY_RTS_THRESHOLD]) {
+		unsigned int rts;
+
+		rts = nla_get_u32(tb_msg[NL80211_ATTR_WIPHY_RTS_THRESHOLD]);
+		if (rts != (unsigned int)-1)
+			printf("\tRTS threshold: %d\n", rts);
+	}
+
+	if (tb_msg[NL80211_ATTR_WIPHY_COVERAGE_CLASS]) {
+		unsigned char coverage;
+
+		coverage = nla_get_u8(tb_msg[NL80211_ATTR_WIPHY_COVERAGE_CLASS]);
+		/* See handle_distance() for an explanation where the '450' comes from */
+		printf("\tCoverage class: %d (up to %dm)\n", coverage, 450 * coverage);
+	}
+
+	if (tb_msg[NL80211_ATTR_SUPPORTED_IFTYPES]) {
+		printf("\tSupported interface modes:\n");
+		nla_for_each_nested(nl_mode, tb_msg[NL80211_ATTR_SUPPORTED_IFTYPES], rem_mode)
+			printf("\t\t * %s\n", iftype_name(nl_mode->nla_type));
+	}
+
+	if (tb_msg[NL80211_ATTR_SUPPORTED_COMMANDS]) {
+		printf("\tSupported commands:\n");
+		nla_for_each_nested(nl_cmd, tb_msg[NL80211_ATTR_SUPPORTED_COMMANDS], rem_cmd)
+			printf("\t\t * %s\n", command_name(nla_get_u32(nl_cmd)));
+	}
+
+	if (tb_msg[NL80211_ATTR_TX_FRAME_TYPES]) {
+		printf("\tSupported TX frame types:\n");
+		nla_for_each_nested(nl_if, tb_msg[NL80211_ATTR_TX_FRAME_TYPES], rem_if) {
+			bool printed = false;
+			nla_for_each_nested(nl_ftype, nl_if, rem_ftype) {
+				if (!printed)
+					printf("\t\t * %s:", iftype_name(nla_type(nl_if)));
+				printed = true;
+				printf(" 0x%.4x", nla_get_u16(nl_ftype));
+			}
+			if (printed)
+				printf("\n");
+		}
+	}
+
+	if (tb_msg[NL80211_ATTR_RX_FRAME_TYPES]) {
+		printf("\tSupported RX frame types:\n");
+		nla_for_each_nested(nl_if, tb_msg[NL80211_ATTR_RX_FRAME_TYPES], rem_if) {
+			bool printed = false;
+			nla_for_each_nested(nl_ftype, nl_if, rem_ftype) {
+				if (!printed)
+					printf("\t\t * %s:", iftype_name(nla_type(nl_if)));
+				printed = true;
+				printf(" 0x%.4x", nla_get_u16(nl_ftype));
+			}
+			if (printed)
+				printf("\n");
+		}
+	}
+
+	return NL_SKIP;
+}
+
+static int handle_info(struct nl80211_state *state,
+		       struct nl_cb *cb,
+		       struct nl_msg *msg,
+		       int argc, char **argv)
+{
+	nl_cb_set(cb, NL_CB_VALID, NL_CB_CUSTOM, print_phy_handler, NULL);
+
+	return 0;
+}
+__COMMAND(NULL, info, "info", NULL, NL80211_CMD_GET_WIPHY, 0, 0, CIB_PHY, handle_info,
+	 "Show capabilities for the specified wireless device.", NULL);
+TOPLEVEL(list, NULL, NL80211_CMD_GET_WIPHY, NLM_F_DUMP, CIB_NONE, handle_info,
+	 "List all wireless devices and their capabilities.");
+TOPLEVEL(phy, NULL, NL80211_CMD_GET_WIPHY, NLM_F_DUMP, CIB_NONE, handle_info, NULL);
diff --git a/external/iw/interface.c b/external/iw/interface.c
new file mode 100644
index 0000000..9ee39c8
--- /dev/null
+++ b/external/iw/interface.c
@@ -0,0 +1,416 @@
+#include <net/if.h>
+#include <errno.h>
+#include <string.h>
+#include <stdbool.h>
+
+#include <netlink/genl/genl.h>
+#include <netlink/genl/family.h>
+#include <netlink/genl/ctrl.h>
+#include <netlink/msg.h>
+#include <netlink/attr.h>
+
+#include "nl80211.h"
+#include "iw.h"
+
+#define VALID_FLAGS	"none:     no special flags\n"\
+			"fcsfail:  show frames with FCS errors\n"\
+			"control:  show control frames\n"\
+			"otherbss: show frames from other BSSes\n"\
+			"cook:     use cooked mode"
+
+SECTION(interface);
+
+static char *mntr_flags[NL80211_MNTR_FLAG_MAX + 1] = {
+	"none",
+	"fcsfail",
+	"plcpfail",
+	"control",
+	"otherbss",
+	"cook",
+};
+
+static int parse_mntr_flags(int *_argc, char ***_argv,
+			    struct nl_msg *msg)
+{
+	struct nl_msg *flags;
+	int err = -ENOBUFS;
+	enum nl80211_mntr_flags flag;
+	int argc = *_argc;
+	char **argv = *_argv;
+
+	flags = nlmsg_alloc();
+	if (!flags)
+		return -ENOMEM;
+
+	while (argc) {
+		int ok = 0;
+		for (flag = __NL80211_MNTR_FLAG_INVALID;
+		     flag <= NL80211_MNTR_FLAG_MAX; flag++) {
+			if (strcmp(*argv, mntr_flags[flag]) == 0) {
+				ok = 1;
+				/*
+				 * This shouldn't be adding "flag" if that is
+				 * zero, but due to a problem in the kernel's
+				 * nl80211 code (using NLA_NESTED policy) it
+				 * will reject an empty nested attribute but
+				 * not one that contains an invalid attribute
+				 */
+				NLA_PUT_FLAG(flags, flag);
+				break;
+			}
+		}
+		if (!ok) {
+			err = -EINVAL;
+			goto out;
+		}
+		argc--;
+		argv++;
+	}
+
+	nla_put_nested(msg, NL80211_ATTR_MNTR_FLAGS, flags);
+	err = 0;
+ nla_put_failure:
+ out:
+	nlmsg_free(flags);
+
+	*_argc = argc;
+	*_argv = argv;
+
+	return err;
+}
+
+/* for help */
+#define IFACE_TYPES "Valid interface types are: managed, ibss, monitor, mesh, wds."
+
+/* return 0 if ok, internal error otherwise */
+static int get_if_type(int *argc, char ***argv, enum nl80211_iftype *type,
+		       bool need_type)
+{
+	char *tpstr;
+
+	if (*argc < 1 + !!need_type)
+		return 1;
+
+	if (need_type && strcmp((*argv)[0], "type"))
+		return 1;
+
+	tpstr = (*argv)[!!need_type];
+	*argc -= 1 + !!need_type;
+	*argv += 1 + !!need_type;
+
+	if (strcmp(tpstr, "adhoc") == 0 ||
+	    strcmp(tpstr, "ibss") == 0) {
+		*type = NL80211_IFTYPE_ADHOC;
+		return 0;
+	} else if (strcmp(tpstr, "monitor") == 0) {
+		*type = NL80211_IFTYPE_MONITOR;
+		return 0;
+	} else if (strcmp(tpstr, "master") == 0 ||
+		   strcmp(tpstr, "ap") == 0) {
+		*type = NL80211_IFTYPE_UNSPECIFIED;
+		fprintf(stderr, "You need to run a management daemon, e.g. hostapd,\n");
+		fprintf(stderr, "see http://wireless.kernel.org/en/users/Documentation/hostapd\n");
+		fprintf(stderr, "for more information on how to do that.\n");
+		return 2;
+	} else if (strcmp(tpstr, "__ap") == 0) {
+		*type = NL80211_IFTYPE_AP;
+		return 0;
+	} else if (strcmp(tpstr, "__ap_vlan") == 0) {
+		*type = NL80211_IFTYPE_AP_VLAN;
+		return 0;
+	} else if (strcmp(tpstr, "wds") == 0) {
+		*type = NL80211_IFTYPE_WDS;
+		return 0;
+	} else if (strcmp(tpstr, "managed") == 0 ||
+		   strcmp(tpstr, "mgd") == 0 ||
+		   strcmp(tpstr, "station") == 0) {
+		*type = NL80211_IFTYPE_STATION;
+		return 0;
+	} else if (strcmp(tpstr, "mp") == 0 ||
+		   strcmp(tpstr, "mesh") == 0) {
+		*type = NL80211_IFTYPE_MESH_POINT;
+		return 0;
+	} else if (strcmp(tpstr, "__p2pcl") == 0) {
+		*type = NL80211_IFTYPE_P2P_CLIENT;
+		return 0;
+	} else if (strcmp(tpstr, "__p2pgo") == 0) {
+		*type = NL80211_IFTYPE_P2P_GO;
+		return 0;
+	}
+
+	fprintf(stderr, "invalid interface type %s\n", tpstr);
+	return 2;
+}
+
+static int parse_4addr_flag(const char *value, struct nl_msg *msg)
+{
+	if (strcmp(value, "on") == 0)
+		NLA_PUT_U8(msg, NL80211_ATTR_4ADDR, 1);
+	else if (strcmp(value, "off") == 0)
+		NLA_PUT_U8(msg, NL80211_ATTR_4ADDR, 0);
+	else
+		return 1;
+	return 0;
+
+nla_put_failure:
+	return 1;
+}
+
+static int handle_interface_add(struct nl80211_state *state,
+				struct nl_cb *cb,
+				struct nl_msg *msg,
+				int argc, char **argv)
+{
+	char *name;
+	char *mesh_id = NULL;
+	enum nl80211_iftype type;
+	int tpset;
+
+	if (argc < 1)
+		return 1;
+
+	name = argv[0];
+	argc--;
+	argv++;
+
+	tpset = get_if_type(&argc, &argv, &type, true);
+	if (tpset)
+		return tpset;
+
+	if (argc) {
+		if (strcmp(argv[0], "mesh_id") == 0) {
+			argc--;
+			argv++;
+
+			if (!argc)
+				return 1;
+			mesh_id = argv[0];
+			argc--;
+			argv++;
+		} else if (strcmp(argv[0], "4addr") == 0) {
+			argc--;
+			argv++;
+			if (parse_4addr_flag(argv[0], msg)) {
+				fprintf(stderr, "4addr error\n");
+				return 2;
+			}
+			argc--;
+			argv++;
+		} else if (strcmp(argv[0], "flags") == 0) {
+			argc--;
+			argv++;
+			if (parse_mntr_flags(&argc, &argv, msg)) {
+				fprintf(stderr, "flags error\n");
+				return 2;
+			}
+		} else {
+			return 1;
+		}
+	}
+
+	if (argc)
+		return 1;
+
+	NLA_PUT_STRING(msg, NL80211_ATTR_IFNAME, name);
+	NLA_PUT_U32(msg, NL80211_ATTR_IFTYPE, type);
+	if (mesh_id)
+		NLA_PUT(msg, NL80211_ATTR_MESH_ID, strlen(mesh_id), mesh_id);
+
+	return 0;
+ nla_put_failure:
+	return -ENOBUFS;
+}
+COMMAND(interface, add, "<name> type <type> [mesh_id <meshid>] [4addr on|off] [flags <flag>*]",
+	NL80211_CMD_NEW_INTERFACE, 0, CIB_PHY, handle_interface_add,
+	"Add a new virtual interface with the given configuration.\n"
+	IFACE_TYPES "\n\n"
+	"The flags are only used for monitor interfaces, valid flags are:\n"
+	VALID_FLAGS "\n\n"
+	"The mesh_id is used only for mesh mode.");
+COMMAND(interface, add, "<name> type <type> [mesh_id <meshid>] [4addr on|off] [flags <flag>*]",
+	NL80211_CMD_NEW_INTERFACE, 0, CIB_NETDEV, handle_interface_add, NULL);
+
+static int handle_interface_del(struct nl80211_state *state,
+				struct nl_cb *cb,
+				struct nl_msg *msg,
+				int argc, char **argv)
+{
+	return 0;
+}
+TOPLEVEL(del, NULL, NL80211_CMD_DEL_INTERFACE, 0, CIB_NETDEV, handle_interface_del,
+	 "Remove this virtual interface");
+HIDDEN(interface, del, NULL, NL80211_CMD_DEL_INTERFACE, 0, CIB_NETDEV, handle_interface_del);
+
+static int print_iface_handler(struct nl_msg *msg, void *arg)
+{
+	struct genlmsghdr *gnlh = nlmsg_data(nlmsg_hdr(msg));
+	struct nlattr *tb_msg[NL80211_ATTR_MAX + 1];
+	unsigned int *wiphy = arg;
+	const char *indent = "";
+
+	nla_parse(tb_msg, NL80211_ATTR_MAX, genlmsg_attrdata(gnlh, 0),
+		  genlmsg_attrlen(gnlh, 0), NULL);
+
+	if (wiphy && tb_msg[NL80211_ATTR_WIPHY]) {
+		unsigned int thiswiphy = nla_get_u32(tb_msg[NL80211_ATTR_WIPHY]);
+		indent = "\t";
+		if (*wiphy != thiswiphy)
+			printf("phy#%d\n", thiswiphy);
+		*wiphy = thiswiphy;
+	}
+
+	if (tb_msg[NL80211_ATTR_IFNAME])
+		printf("%sInterface %s\n", indent, nla_get_string(tb_msg[NL80211_ATTR_IFNAME]));
+	if (tb_msg[NL80211_ATTR_IFINDEX])
+		printf("%s\tifindex %d\n", indent, nla_get_u32(tb_msg[NL80211_ATTR_IFINDEX]));
+	if (tb_msg[NL80211_ATTR_IFTYPE])
+		printf("%s\ttype %s\n", indent, iftype_name(nla_get_u32(tb_msg[NL80211_ATTR_IFTYPE])));
+
+	return NL_SKIP;
+}
+
+static int handle_interface_info(struct nl80211_state *state,
+				 struct nl_cb *cb,
+				 struct nl_msg *msg,
+				 int argc, char **argv)
+{
+	nl_cb_set(cb, NL_CB_VALID, NL_CB_CUSTOM, print_iface_handler, NULL);
+	return 0;
+}
+TOPLEVEL(info, NULL, NL80211_CMD_GET_INTERFACE, 0, CIB_NETDEV, handle_interface_info,
+	 "Show information for this interface.");
+
+static int handle_interface_set(struct nl80211_state *state,
+				struct nl_cb *cb,
+				struct nl_msg *msg,
+				int argc, char **argv)
+{
+	if (!argc)
+		return 1;
+
+	NLA_PUT_U32(msg, NL80211_ATTR_IFTYPE, NL80211_IFTYPE_MONITOR);
+
+	switch (parse_mntr_flags(&argc, &argv, msg)) {
+	case 0:
+		return 0;
+	case -ENOMEM:
+		fprintf(stderr, "failed to allocate flags\n");
+		return 2;
+	case -EINVAL:
+		fprintf(stderr, "unknown flag %s\n", *argv);
+		return 2;
+	default:
+		return 2;
+	}
+ nla_put_failure:
+	return -ENOBUFS;
+}
+COMMAND(set, monitor, "<flag>*",
+	NL80211_CMD_SET_INTERFACE, 0, CIB_NETDEV, handle_interface_set,
+	"Set monitor flags. Valid flags are:\n"
+	VALID_FLAGS);
+
+static int handle_interface_meshid(struct nl80211_state *state,
+				   struct nl_cb *cb,
+				   struct nl_msg *msg,
+				   int argc, char **argv)
+{
+	char *mesh_id = NULL;
+
+	if (argc != 1)
+		return 1;
+
+	mesh_id = argv[0];
+
+	NLA_PUT(msg, NL80211_ATTR_MESH_ID, strlen(mesh_id), mesh_id);
+
+	return 0;
+ nla_put_failure:
+	return -ENOBUFS;
+}
+COMMAND(set, meshid, "<meshid>",
+	NL80211_CMD_SET_INTERFACE, 0, CIB_NETDEV, handle_interface_meshid, NULL);
+
+static unsigned int dev_dump_wiphy;
+
+static int handle_dev_dump(struct nl80211_state *state,
+			   struct nl_cb *cb,
+			   struct nl_msg *msg,
+			   int argc, char **argv)
+{
+	dev_dump_wiphy = -1;
+	nl_cb_set(cb, NL_CB_VALID, NL_CB_CUSTOM, print_iface_handler, &dev_dump_wiphy);
+	return 0;
+}
+TOPLEVEL(dev, NULL, NL80211_CMD_GET_INTERFACE, NLM_F_DUMP, CIB_NONE, handle_dev_dump,
+	 "List all network interfaces for wireless hardware.");
+
+static int handle_interface_type(struct nl80211_state *state,
+				 struct nl_cb *cb,
+				 struct nl_msg *msg,
+				 int argc, char **argv)
+{
+	enum nl80211_iftype type;
+	int tpset;
+
+	tpset = get_if_type(&argc, &argv, &type, false);
+	if (tpset)
+		return tpset;
+
+	if (argc)
+		return 1;
+
+	NLA_PUT_U32(msg, NL80211_ATTR_IFTYPE, type);
+
+	return 0;
+ nla_put_failure:
+	return -ENOBUFS;
+}
+COMMAND(set, type, "<type>",
+	NL80211_CMD_SET_INTERFACE, 0, CIB_NETDEV, handle_interface_type,
+	"Set interface type/mode.\n"
+	IFACE_TYPES);
+
+static int handle_interface_4addr(struct nl80211_state *state,
+				 struct nl_cb *cb,
+				 struct nl_msg *msg,
+				 int argc, char **argv)
+{
+	if (argc != 1)
+		return 1;
+	return parse_4addr_flag(argv[0], msg);
+}
+COMMAND(set, 4addr, "<on|off>",
+	NL80211_CMD_SET_INTERFACE, 0, CIB_NETDEV, handle_interface_4addr,
+	"Set interface 4addr (WDS) mode.");
+
+static int handle_interface_wds_peer(struct nl80211_state *state,
+				     struct nl_cb *cb,
+				     struct nl_msg *msg,
+				     int argc, char **argv)
+{
+	unsigned char mac_addr[ETH_ALEN];
+
+	if (argc < 1)
+		return 1;
+
+	if (mac_addr_a2n(mac_addr, argv[0])) {
+		fprintf(stderr, "Invalid MAC address\n");
+		return 2;
+	}
+
+	argc--;
+	argv++;
+
+	if (argc)
+		return 1;
+
+	NLA_PUT(msg, NL80211_ATTR_MAC, ETH_ALEN, mac_addr);
+
+	return 0;
+ nla_put_failure:
+	return -ENOBUFS;
+}
+COMMAND(set, peer, "<MAC address>",
+	NL80211_CMD_SET_WDS_PEER, 0, CIB_NETDEV, handle_interface_wds_peer,
+	"Set interface WDS peer.");
diff --git a/external/iw/iw.8 b/external/iw/iw.8
new file mode 100644
index 0000000..866260f
--- /dev/null
+++ b/external/iw/iw.8
@@ -0,0 +1,67 @@
+.TH IW 8 "16 September 2008" "iw" "Linux"
+.SH NAME
+iw \- show / manipulate wireless devices and their configuration
+.SH SYNOPSIS
+
+.ad l
+.in +8
+.ti -8
+.B iw
+.RI [ " OPTIONS " ] " " { " 
+.BR help " |"
+.RI ""OBJECT " " COMMAND " }"
+.sp
+
+.ti -8
+.IR OBJECT " := { "
+.BR dev " | " phy " | " reg " }"
+.sp
+
+.ti -8
+.IR OPTIONS " := { --version | --debug }"
+
+.SH OPTIONS
+
+.TP
+.BR " --version"
+print version information and exit.
+
+.TP
+.BR " --debug"
+enable netlink message debugging.
+
+.SH IW - COMMAND SYNTAX
+
+.SS
+.I OBJECT
+
+.TP
+.B dev <interface name>
+- network interface.
+
+.TP
+.B phy <phy name>
+- wireless hardware device (by name).
+.TP
+.B phy#<phy index>
+- wireless hardware device (by index).
+
+.TP
+.B reg
+- regulatory agent.
+
+.SS
+.I COMMAND
+
+Specifies the action to perform on the object.
+The set of possible actions depends on the object type.
+.B iw help
+will print all supported commands.
+
+.SH SEE ALSO
+.BR ip (8),
+.BR crda (8),
+.BR regdbdump (8),
+.BR regulatory.bin (5)
+
+.BR http://wireless.kernel.org/en/users/Documentation/iw
diff --git a/external/iw/iw.c b/external/iw/iw.c
new file mode 100644
index 0000000..2593481
--- /dev/null
+++ b/external/iw/iw.c
@@ -0,0 +1,503 @@
+/*
+ * nl80211 userspace tool
+ *
+ * Copyright 2007, 2008	Johannes Berg <johannes@sipsolutions.net>
+ */
+
+#include <errno.h>
+#include <stdio.h>
+#include <string.h>
+#include <net/if.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <stdbool.h>
+                     
+#include <netlink/genl/genl.h>
+#include <netlink/genl/family.h>
+#include <netlink/genl/ctrl.h>  
+#include <netlink/msg.h>
+#include <netlink/attr.h>
+
+#include "nl80211.h"
+#include "iw.h"
+
+#ifndef CONFIG_LIBNL20
+/* libnl 2.0 compatibility code */
+
+static inline struct nl_handle *nl_socket_alloc(void)
+{
+	return nl_handle_alloc();
+}
+
+static inline void nl_socket_free(struct nl_sock *h)
+{
+	nl_handle_destroy(h);
+}
+
+static inline int __genl_ctrl_alloc_cache(struct nl_sock *h, struct nl_cache **cache)
+{
+	struct nl_cache *tmp = genl_ctrl_alloc_cache(h);
+	if (!tmp)
+		return -ENOMEM;
+	*cache = tmp;
+	return 0;
+}
+#define genl_ctrl_alloc_cache __genl_ctrl_alloc_cache
+#endif /* CONFIG_LIBNL20 */
+
+int iw_debug = 0;
+
+static int nl80211_init(struct nl80211_state *state)
+{
+	int err;
+
+	state->nl_sock = nl_socket_alloc();
+	if (!state->nl_sock) {
+		fprintf(stderr, "Failed to allocate netlink socket.\n");
+		return -ENOMEM;
+	}
+
+	if (genl_connect(state->nl_sock)) {
+		fprintf(stderr, "Failed to connect to generic netlink.\n");
+		err = -ENOLINK;
+		goto out_handle_destroy;
+	}
+
+	if (genl_ctrl_alloc_cache(state->nl_sock, &state->nl_cache)) {
+		fprintf(stderr, "Failed to allocate generic netlink cache.\n");
+		err = -ENOMEM;
+		goto out_handle_destroy;
+	}
+
+	state->nl80211 = genl_ctrl_search_by_name(state->nl_cache, "nl80211");
+	if (!state->nl80211) {
+		fprintf(stderr, "nl80211 not found.\n");
+		err = -ENOENT;
+		goto out_cache_free;
+	}
+
+	return 0;
+
+ out_cache_free:
+	nl_cache_free(state->nl_cache);
+ out_handle_destroy:
+	nl_socket_free(state->nl_sock);
+	return err;
+}
+
+static void nl80211_cleanup(struct nl80211_state *state)
+{
+	genl_family_put(state->nl80211);
+	nl_cache_free(state->nl_cache);
+	nl_socket_free(state->nl_sock);
+}
+
+static int cmd_size;
+
+extern struct cmd __start___cmd;
+extern struct cmd __stop___cmd;
+
+#define for_each_cmd(_cmd)					\
+	for (_cmd = &__start___cmd; _cmd < &__stop___cmd;		\
+	     _cmd = (const struct cmd *)((char *)_cmd + cmd_size))
+
+
+static void __usage_cmd(const struct cmd *cmd, char *indent, bool full)
+{
+	const char *start, *lend, *end;
+
+	printf("%s", indent);
+
+	switch (cmd->idby) {
+	case CIB_NONE:
+		break;
+	case CIB_PHY:
+		printf("phy <phyname> ");
+		break;
+	case CIB_NETDEV:
+		printf("dev <devname> ");
+		break;
+	}
+	if (cmd->parent && cmd->parent->name)
+		printf("%s ", cmd->parent->name);
+	printf("%s", cmd->name);
+	if (cmd->args)
+		printf(" %s", cmd->args);
+	printf("\n");
+
+	if (!full || !cmd->help)
+		return;
+
+	/* hack */
+	if (strlen(indent))
+		indent = "\t\t";
+	else
+		printf("\n");
+
+	/* print line by line */
+	start = cmd->help;
+	end = strchr(start, '\0');
+	do {
+		lend = strchr(start, '\n');
+		if (!lend)
+			lend = end;
+		printf("%s", indent);
+		printf("%.*s\n", (int)(lend - start), start);
+		start = lend + 1;
+	} while (end != lend);
+
+	printf("\n");
+}
+
+static void usage_options(void)
+{
+	printf("Options:\n");
+	printf("\t--debug\t\tenable netlink debugging\n");
+}
+
+static const char *argv0;
+
+static void usage(bool full)
+{
+	const struct cmd *section, *cmd;
+
+	printf("Usage:\t%s [options] command\n", argv0);
+	usage_options();
+	printf("\t--version\tshow version (%s)\n", iw_version);
+	printf("Commands:\n");
+	for_each_cmd(section) {
+		if (section->parent)
+			continue;
+
+		if (section->handler && !section->hidden)
+			__usage_cmd(section, "\t", full);
+
+		for_each_cmd(cmd) {
+			if (section != cmd->parent)
+				continue;
+			if (!cmd->handler || cmd->hidden)
+				continue;
+			__usage_cmd(cmd, "\t", full);
+		}
+	}
+	printf("\nYou can omit the 'phy' or 'dev' if "
+			"the identification is unique,\n"
+			"e.g. \"iw wlan0 info\" or \"iw phy0 info\". "
+			"(Don't when scripting.)\n\n"
+			"Do NOT screenscrape this tool, we don't "
+			"consider its output stable.\n\n");
+}
+
+static int print_help(struct nl80211_state *state,
+		      struct nl_cb *cb,
+		      struct nl_msg *msg,
+		      int argc, char **argv)
+{
+	exit(3);
+}
+TOPLEVEL(help, NULL, 0, 0, CIB_NONE, print_help,
+	 "Print usage for each command.");
+
+static void usage_cmd(const struct cmd *cmd)
+{
+	printf("Usage:\t%s [options] ", argv0);
+	__usage_cmd(cmd, "", true);
+	usage_options();
+}
+
+static void version(void)
+{
+	printf("iw version %s\n", iw_version);
+}
+
+static int phy_lookup(char *name)
+{
+	char buf[200];
+	int fd, pos;
+
+	snprintf(buf, sizeof(buf), "/sys/class/ieee80211/%s/index", name);
+
+	fd = open(buf, O_RDONLY);
+	if (fd < 0)
+		return -1;
+	pos = read(fd, buf, sizeof(buf) - 1);
+	if (pos < 0) {
+		close(fd);
+		return -1;
+	}
+	buf[pos] = '\0';
+	close(fd);
+	return atoi(buf);
+}
+
+static int error_handler(struct sockaddr_nl *nla, struct nlmsgerr *err,
+			 void *arg)
+{
+	int *ret = arg;
+	*ret = err->error;
+	return NL_STOP;
+}
+
+static int finish_handler(struct nl_msg *msg, void *arg)
+{
+	int *ret = arg;
+	*ret = 0;
+	return NL_SKIP;
+}
+
+static int ack_handler(struct nl_msg *msg, void *arg)
+{
+	int *ret = arg;
+	*ret = 0;
+	return NL_STOP;
+}
+
+static int __handle_cmd(struct nl80211_state *state, enum id_input idby,
+			int argc, char **argv, const struct cmd **cmdout)
+{
+	const struct cmd *cmd, *match = NULL, *sectcmd;
+	struct nl_cb *cb;
+	struct nl_msg *msg;
+	int devidx = 0;
+	int err, o_argc;
+	const char *command, *section;
+	char *tmp, **o_argv;
+	enum command_identify_by command_idby = CIB_NONE;
+
+	if (argc <= 1 && idby != II_NONE)
+		return 1;
+
+	o_argc = argc;
+	o_argv = argv;
+
+	switch (idby) {
+	case II_PHY_IDX:
+		command_idby = CIB_PHY;
+		devidx = strtoul(*argv + 4, &tmp, 0);
+		if (*tmp != '\0')
+			return 1;
+		argc--;
+		argv++;
+		break;
+	case II_PHY_NAME:
+		command_idby = CIB_PHY;
+		devidx = phy_lookup(*argv);
+		argc--;
+		argv++;
+		break;
+	case II_NETDEV:
+		command_idby = CIB_NETDEV;
+		devidx = if_nametoindex(*argv);
+		if (devidx == 0)
+			devidx = -1;
+		argc--;
+		argv++;
+		break;
+	default:
+		break;
+	}
+
+	if (devidx < 0)
+		return -errno;
+
+	section = *argv;
+	argc--;
+	argv++;
+
+	for_each_cmd(sectcmd) {
+		if (sectcmd->parent)
+			continue;
+		/* ok ... bit of a hack for the dupe 'info' section */
+		if (match && sectcmd->idby != command_idby)
+			continue;
+		if (strcmp(sectcmd->name, section) == 0)
+			match = sectcmd;
+	}
+
+	sectcmd = match;
+	match = NULL;
+	if (!sectcmd)
+		return 1;
+
+	if (argc > 0) {
+		command = *argv;
+
+		for_each_cmd(cmd) {
+			if (!cmd->handler)
+				continue;
+			if (cmd->parent != sectcmd)
+				continue;
+			if (cmd->idby != command_idby)
+				continue;
+			if (strcmp(cmd->name, command))
+				continue;
+			if (argc > 1 && !cmd->args)
+				continue;
+			match = cmd;
+			break;
+		}
+
+		if (match) {
+			argc--;
+			argv++;
+		}
+	}
+
+	if (match)
+		cmd = match;
+	else {
+		/* Use the section itself, if possible. */
+		cmd = sectcmd;
+		if (argc && !cmd->args)
+			return 1;
+		if (cmd->idby != command_idby)
+			return 1;
+		if (!cmd->handler)
+			return 1;
+	}
+
+	if (cmd->selector) {
+		cmd = cmd->selector(argc, argv);
+		if (!cmd)
+			return 1;
+	}
+
+	if (cmdout)
+		*cmdout = cmd;
+
+	if (!cmd->cmd) {
+		argc = o_argc;
+		argv = o_argv;
+		return cmd->handler(state, NULL, NULL, argc, argv);
+	}
+
+	msg = nlmsg_alloc();
+	if (!msg) {
+		fprintf(stderr, "failed to allocate netlink message\n");
+		return 2;
+	}
+
+	cb = nl_cb_alloc(iw_debug ? NL_CB_DEBUG : NL_CB_DEFAULT);
+	if (!cb) {
+		fprintf(stderr, "failed to allocate netlink callbacks\n");
+		err = 2;
+		goto out_free_msg;
+	}
+
+	genlmsg_put(msg, 0, 0, genl_family_get_id(state->nl80211), 0,
+		    cmd->nl_msg_flags, cmd->cmd, 0);
+
+	switch (command_idby) {
+	case CIB_PHY:
+		NLA_PUT_U32(msg, NL80211_ATTR_WIPHY, devidx);
+		break;
+	case CIB_NETDEV:
+		NLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, devidx);
+		break;
+	default:
+		break;
+	}
+
+	err = cmd->handler(state, cb, msg, argc, argv);
+	if (err)
+		goto out;
+
+	err = nl_send_auto_complete(state->nl_sock, msg);
+	if (err < 0)
+		goto out;
+
+	err = 1;
+
+	nl_cb_err(cb, NL_CB_CUSTOM, error_handler, &err);
+	nl_cb_set(cb, NL_CB_FINISH, NL_CB_CUSTOM, finish_handler, &err);
+	nl_cb_set(cb, NL_CB_ACK, NL_CB_CUSTOM, ack_handler, &err);
+
+	while (err > 0)
+		nl_recvmsgs(state->nl_sock, cb);
+ out:
+	nl_cb_put(cb);
+ out_free_msg:
+	nlmsg_free(msg);
+	return err;
+ nla_put_failure:
+	fprintf(stderr, "building message failed\n");
+	return 2;
+}
+
+int handle_cmd(struct nl80211_state *state, enum id_input idby,
+	       int argc, char **argv)
+{
+	return __handle_cmd(state, idby, argc, argv, NULL);
+}
+
+int main(int argc, char **argv)
+{
+	struct nl80211_state nlstate;
+	int err;
+	const struct cmd *cmd = NULL;
+
+	/* calculate command size including padding */
+	cmd_size = abs((long)&__section_set - (long)&__section_get);
+	/* strip off self */
+	argc--;
+	argv0 = *argv++;
+
+	if (argc > 0 && strcmp(*argv, "--debug") == 0) {
+		iw_debug = 1;
+		argc--;
+		argv++;
+	}
+
+	if (argc > 0 && strcmp(*argv, "--version") == 0) {
+		version();
+		return 0;
+	}
+
+	/* need to treat "help" command specially so it works w/o nl80211 */
+	if (argc == 0 || strcmp(*argv, "help") == 0) {
+		usage(argc != 0);
+		return 0;
+	}
+
+	err = nl80211_init(&nlstate);
+	if (err)
+		return 1;
+
+	if (strcmp(*argv, "dev") == 0 && argc > 1) {
+		argc--;
+		argv++;
+		err = __handle_cmd(&nlstate, II_NETDEV, argc, argv, &cmd);
+	} else if (strncmp(*argv, "phy", 3) == 0 && argc > 1) {
+		if (strlen(*argv) == 3) {
+			argc--;
+			argv++;
+			err = __handle_cmd(&nlstate, II_PHY_NAME, argc, argv, &cmd);
+		} else if (*(*argv + 3) == '#')
+			err = __handle_cmd(&nlstate, II_PHY_IDX, argc, argv, &cmd);
+		else
+			goto detect;
+	} else {
+		int idx;
+		enum id_input idby = II_NONE;
+ detect:
+		if ((idx = if_nametoindex(argv[0])) != 0)
+			idby = II_NETDEV;
+		else if ((idx = phy_lookup(argv[0])) >= 0)
+			idby = II_PHY_NAME;
+		err = __handle_cmd(&nlstate, idby, argc, argv, &cmd);
+	}
+
+	if (err == 1) {
+		if (cmd)
+			usage_cmd(cmd);
+		else
+			usage(false);
+	} else if (err < 0)
+		fprintf(stderr, "command failed: %s (%d)\n", strerror(-err), err);
+
+	nl80211_cleanup(&nlstate);
+
+	return err;
+}
diff --git a/external/iw/iw.h b/external/iw/iw.h
new file mode 100644
index 0000000..b0bc489
--- /dev/null
+++ b/external/iw/iw.h
@@ -0,0 +1,167 @@
+#ifndef __IW_H
+#define __IW_H
+
+#include <stdbool.h>
+#include <netlink/netlink.h>
+#include <netlink/genl/genl.h>
+#include <netlink/genl/family.h>
+#include <netlink/genl/ctrl.h>
+
+#include "nl80211.h"
+
+#define ETH_ALEN 6
+
+#ifndef CONFIG_LIBNL20
+#  define nl_sock nl_handle
+#endif
+
+struct nl80211_state {
+	struct nl_sock *nl_sock;
+	struct nl_cache *nl_cache;
+	struct genl_family *nl80211;
+};
+
+enum command_identify_by {
+	CIB_NONE,
+	CIB_PHY,
+	CIB_NETDEV,
+};
+
+enum id_input {
+	II_NONE,
+	II_NETDEV,
+	II_PHY_NAME,
+	II_PHY_IDX,
+};
+
+struct cmd {
+	const char *name;
+	const char *args;
+	const char *help;
+	const enum nl80211_commands cmd;
+	int nl_msg_flags;
+	int hidden;
+	const enum command_identify_by idby;
+	/*
+	 * The handler should return a negative error code,
+	 * zero on success, 1 if the arguments were wrong
+	 * and the usage message should and 2 otherwise.
+	 */
+	int (*handler)(struct nl80211_state *state,
+		       struct nl_cb *cb,
+		       struct nl_msg *msg,
+		       int argc, char **argv);
+	const struct cmd *(*selector)(int argc, char **argv);
+	const struct cmd *parent;
+};
+
+#define ARRAY_SIZE(ar) (sizeof(ar)/sizeof(ar[0]))
+
+#define __COMMAND(_section, _symname, _name, _args, _nlcmd, _flags, _hidden, _idby, _handler, _help, _sel)\
+	static struct cmd						\
+	__cmd ## _ ## _symname ## _ ## _handler ## _ ## _nlcmd ## _ ## _idby ## _ ## _hidden\
+	__attribute__((used)) __attribute__((section("__cmd")))	= {	\
+		.name = (_name),					\
+		.args = (_args),					\
+		.cmd = (_nlcmd),					\
+		.nl_msg_flags = (_flags),				\
+		.hidden = (_hidden),					\
+		.idby = (_idby),					\
+		.handler = (_handler),					\
+		.help = (_help),					\
+		.parent = _section,					\
+		.selector = (_sel),					\
+	}
+#define __ACMD(_section, _symname, _name, _args, _nlcmd, _flags, _hidden, _idby, _handler, _help, _sel, _alias)\
+	__COMMAND(_section, _symname, _name, _args, _nlcmd, _flags, _hidden, _idby, _handler, _help, _sel);\
+	static const struct cmd *_alias = &__cmd ## _ ## _symname ## _ ## _handler ## _ ## _nlcmd ## _ ## _idby ## _ ## _hidden
+#define COMMAND(section, name, args, cmd, flags, idby, handler, help)	\
+	__COMMAND(&(__section ## _ ## section), name, #name, args, cmd, flags, 0, idby, handler, help, NULL)
+#define COMMAND_ALIAS(section, name, args, cmd, flags, idby, handler, help, selector, alias)\
+	__ACMD(&(__section ## _ ## section), name, #name, args, cmd, flags, 0, idby, handler, help, selector, alias)
+#define HIDDEN(section, name, args, cmd, flags, idby, handler)		\
+	__COMMAND(&(__section ## _ ## section), name, #name, args, cmd, flags, 1, idby, handler, NULL, NULL)
+
+#define TOPLEVEL(_name, _args, _nlcmd, _flags, _idby, _handler, _help)	\
+	struct cmd							\
+	__section ## _ ## _name						\
+	__attribute__((used)) __attribute__((section("__cmd")))	= {	\
+		.name = (#_name),					\
+		.args = (_args),					\
+		.cmd = (_nlcmd),					\
+		.nl_msg_flags = (_flags),				\
+		.idby = (_idby),					\
+		.handler = (_handler),					\
+		.help = (_help),					\
+	 }
+#define SECTION(_name)							\
+	struct cmd __section ## _ ## _name				\
+	__attribute__((used)) __attribute__((section("__cmd"))) = {	\
+		.name = (#_name),					\
+		.hidden = 1,						\
+	}
+
+#define DECLARE_SECTION(_name)						\
+	extern struct cmd __section ## _ ## _name;
+
+extern const char iw_version[];
+
+extern int iw_debug;
+
+int handle_cmd(struct nl80211_state *state, enum id_input idby,
+	       int argc, char **argv);
+
+struct print_event_args {
+	struct timeval ts; /* internal */
+	bool have_ts; /* must be set false */
+	bool frame, time, reltime;
+};
+
+__u32 listen_events(struct nl80211_state *state,
+		    const int n_waits, const __u32 *waits);
+int __prepare_listen_events(struct nl80211_state *state);
+__u32 __do_listen_events(struct nl80211_state *state,
+			 const int n_waits, const __u32 *waits,
+			 struct print_event_args *args);
+
+
+int mac_addr_a2n(unsigned char *mac_addr, char *arg);
+void mac_addr_n2a(char *mac_addr, unsigned char *arg);
+unsigned char *parse_hex(char *hex, size_t *outlen);
+
+int parse_keys(struct nl_msg *msg, char **argv, int argc);
+
+void print_ht_mcs(const __u8 *mcs);
+void print_ampdu_length(__u8 exponent);
+void print_ampdu_spacing(__u8 spacing);
+void print_ht_capability(__u16 cap);
+
+const char *iftype_name(enum nl80211_iftype iftype);
+const char *command_name(enum nl80211_commands cmd);
+int ieee80211_channel_to_frequency(int chan);
+int ieee80211_frequency_to_channel(int freq);
+
+void print_ssid_escaped(const uint8_t len, const uint8_t *data);
+
+int nl_get_multicast_id(struct nl_sock *sock, const char *family, const char *group);
+
+char *reg_initiator_to_string(__u8 initiator);
+
+const char *get_reason_str(uint16_t reason);
+const char *get_status_str(uint16_t status);
+
+enum print_ie_type {
+	PRINT_SCAN,
+	PRINT_LINK,
+};
+
+#define BIT(x) (1ULL<<(x))
+
+void print_ies(unsigned char *ie, int ielen, bool unknown,
+	       enum print_ie_type ptype);
+
+
+DECLARE_SECTION(set);
+DECLARE_SECTION(get);
+
+#endif /* __IW_H */
diff --git a/external/iw/link.c b/external/iw/link.c
new file mode 100644
index 0000000..297073d
--- /dev/null
+++ b/external/iw/link.c
@@ -0,0 +1,260 @@
+#include <net/if.h>
+#include <errno.h>
+#include <string.h>
+#include <ctype.h>
+#include <stdbool.h>
+
+#include <netlink/genl/genl.h>
+#include <netlink/genl/family.h>
+#include <netlink/genl/ctrl.h>
+#include <netlink/msg.h>
+#include <netlink/attr.h>
+
+#include "nl80211.h"
+#include "iw.h"
+
+struct link_result {
+	uint8_t bssid[8];
+	bool link_found;
+	bool anything_found;
+};
+
+static struct link_result lr = { .link_found = false };
+
+static int link_bss_handler(struct nl_msg *msg, void *arg)
+{
+	struct nlattr *tb[NL80211_ATTR_MAX + 1];
+	struct genlmsghdr *gnlh = nlmsg_data(nlmsg_hdr(msg));
+	struct nlattr *bss[NL80211_BSS_MAX + 1];
+	static struct nla_policy bss_policy[NL80211_BSS_MAX + 1] = {
+		[NL80211_BSS_TSF] = { .type = NLA_U64 },
+		[NL80211_BSS_FREQUENCY] = { .type = NLA_U32 },
+		[NL80211_BSS_BSSID] = { },
+		[NL80211_BSS_BEACON_INTERVAL] = { .type = NLA_U16 },
+		[NL80211_BSS_CAPABILITY] = { .type = NLA_U16 },
+		[NL80211_BSS_INFORMATION_ELEMENTS] = { },
+		[NL80211_BSS_SIGNAL_MBM] = { .type = NLA_U32 },
+		[NL80211_BSS_SIGNAL_UNSPEC] = { .type = NLA_U8 },
+		[NL80211_BSS_STATUS] = { .type = NLA_U32 },
+	};
+	struct link_result *result = arg;
+	char mac_addr[20], dev[20];
+
+	nla_parse(tb, NL80211_ATTR_MAX, genlmsg_attrdata(gnlh, 0),
+		  genlmsg_attrlen(gnlh, 0), NULL);
+
+	if (!tb[NL80211_ATTR_BSS]) {
+		fprintf(stderr, "bss info missing!\n");
+		return NL_SKIP;
+	}
+	if (nla_parse_nested(bss, NL80211_BSS_MAX,
+			     tb[NL80211_ATTR_BSS],
+			     bss_policy)) {
+		fprintf(stderr, "failed to parse nested attributes!\n");
+		return NL_SKIP;
+	}
+
+	if (!bss[NL80211_BSS_BSSID])
+		return NL_SKIP;
+
+	if (!bss[NL80211_BSS_STATUS])
+		return NL_SKIP;
+
+	mac_addr_n2a(mac_addr, nla_data(bss[NL80211_BSS_BSSID]));
+	if_indextoname(nla_get_u32(tb[NL80211_ATTR_IFINDEX]), dev);
+
+	switch (nla_get_u32(bss[NL80211_BSS_STATUS])) {
+	case NL80211_BSS_STATUS_ASSOCIATED:
+		printf("Connected to %s (on %s)\n", mac_addr, dev);
+		break;
+	case NL80211_BSS_STATUS_AUTHENTICATED:
+		printf("Authenticated with %s (on %s)\n", mac_addr, dev);
+		return NL_SKIP;
+	case NL80211_BSS_STATUS_IBSS_JOINED:
+		printf("Joined IBSS %s (on %s)\n", mac_addr, dev);
+		break;
+	default:
+		return NL_SKIP;
+	}
+
+	result->anything_found = true;
+
+	if (bss[NL80211_BSS_INFORMATION_ELEMENTS])
+		print_ies(nla_data(bss[NL80211_BSS_INFORMATION_ELEMENTS]),
+			  nla_len(bss[NL80211_BSS_INFORMATION_ELEMENTS]),
+			  false, PRINT_LINK);
+
+	if (bss[NL80211_BSS_FREQUENCY])
+		printf("\tfreq: %d\n",
+			nla_get_u32(bss[NL80211_BSS_FREQUENCY]));
+
+	if (nla_get_u32(bss[NL80211_BSS_STATUS]) != NL80211_BSS_STATUS_ASSOCIATED)
+		return NL_SKIP;
+
+	/* only in the assoc case do we want more info from station get */
+	result->link_found = true;
+	memcpy(result->bssid, nla_data(bss[NL80211_BSS_BSSID]), 6);
+	return NL_SKIP;
+}
+
+static int handle_scan_for_link(struct nl80211_state *state,
+				struct nl_cb *cb,
+				struct nl_msg *msg,
+				int argc, char **argv)
+{
+	if (argc > 0)
+		return 1;
+
+	nl_cb_set(cb, NL_CB_VALID, NL_CB_CUSTOM, link_bss_handler, &lr);
+	return 0;
+}
+
+static int print_link_sta(struct nl_msg *msg, void *arg)
+{
+	struct nlattr *tb[NL80211_ATTR_MAX + 1];
+	struct genlmsghdr *gnlh = nlmsg_data(nlmsg_hdr(msg));
+	struct nlattr *sinfo[NL80211_STA_INFO_MAX + 1];
+	struct nlattr *rinfo[NL80211_RATE_INFO_MAX + 1];
+	static struct nla_policy stats_policy[NL80211_STA_INFO_MAX + 1] = {
+		[NL80211_STA_INFO_INACTIVE_TIME] = { .type = NLA_U32 },
+		[NL80211_STA_INFO_RX_BYTES] = { .type = NLA_U32 },
+		[NL80211_STA_INFO_TX_BYTES] = { .type = NLA_U32 },
+		[NL80211_STA_INFO_RX_PACKETS] = { .type = NLA_U32 },
+		[NL80211_STA_INFO_TX_PACKETS] = { .type = NLA_U32 },
+		[NL80211_STA_INFO_SIGNAL] = { .type = NLA_U8 },
+		[NL80211_STA_INFO_TX_BITRATE] = { .type = NLA_NESTED },
+		[NL80211_STA_INFO_LLID] = { .type = NLA_U16 },
+		[NL80211_STA_INFO_PLID] = { .type = NLA_U16 },
+		[NL80211_STA_INFO_PLINK_STATE] = { .type = NLA_U8 },
+	};
+
+	static struct nla_policy rate_policy[NL80211_RATE_INFO_MAX + 1] = {
+		[NL80211_RATE_INFO_BITRATE] = { .type = NLA_U16 },
+		[NL80211_RATE_INFO_MCS] = { .type = NLA_U8 },
+		[NL80211_RATE_INFO_40_MHZ_WIDTH] = { .type = NLA_FLAG },
+		[NL80211_RATE_INFO_SHORT_GI] = { .type = NLA_FLAG },
+	};
+
+	nla_parse(tb, NL80211_ATTR_MAX, genlmsg_attrdata(gnlh, 0),
+		  genlmsg_attrlen(gnlh, 0), NULL);
+
+	if (!tb[NL80211_ATTR_STA_INFO]) {
+		fprintf(stderr, "sta stats missing!\n");
+		return NL_SKIP;
+	}
+	if (nla_parse_nested(sinfo, NL80211_STA_INFO_MAX,
+			     tb[NL80211_ATTR_STA_INFO],
+			     stats_policy)) {
+		fprintf(stderr, "failed to parse nested attributes!\n");
+		return NL_SKIP;
+	}
+
+	if (sinfo[NL80211_STA_INFO_RX_BYTES] && sinfo[NL80211_STA_INFO_RX_PACKETS])
+		printf("\tRX: %u bytes (%u packets)\n",
+			nla_get_u32(sinfo[NL80211_STA_INFO_RX_BYTES]),
+			nla_get_u32(sinfo[NL80211_STA_INFO_RX_PACKETS]));
+	if (sinfo[NL80211_STA_INFO_TX_BYTES] && sinfo[NL80211_STA_INFO_TX_PACKETS])
+		printf("\tTX: %u bytes (%u packets)\n",
+			nla_get_u32(sinfo[NL80211_STA_INFO_TX_BYTES]),
+			nla_get_u32(sinfo[NL80211_STA_INFO_TX_PACKETS]));
+	if (sinfo[NL80211_STA_INFO_SIGNAL])
+		printf("\tsignal: %d dBm\n",
+			(int8_t)nla_get_u8(sinfo[NL80211_STA_INFO_SIGNAL]));
+
+	if (sinfo[NL80211_STA_INFO_TX_BITRATE]) {
+		if (nla_parse_nested(rinfo, NL80211_RATE_INFO_MAX,
+				     sinfo[NL80211_STA_INFO_TX_BITRATE], rate_policy)) {
+			fprintf(stderr, "failed to parse nested rate attributes!\n");
+		} else {
+			printf("\ttx bitrate: ");
+			if (rinfo[NL80211_RATE_INFO_BITRATE]) {
+				int rate = nla_get_u16(rinfo[NL80211_RATE_INFO_BITRATE]);
+				printf("%d.%d MBit/s", rate / 10, rate % 10);
+			}
+
+			if (rinfo[NL80211_RATE_INFO_MCS])
+				printf(" MCS %d", nla_get_u8(rinfo[NL80211_RATE_INFO_MCS]));
+			if (rinfo[NL80211_RATE_INFO_40_MHZ_WIDTH])
+				printf(" 40Mhz");
+			if (rinfo[NL80211_RATE_INFO_SHORT_GI])
+				printf(" short GI");
+			printf("\n");
+		}
+	}
+
+	return NL_SKIP;
+}
+
+static int handle_link_sta(struct nl80211_state *state,
+			   struct nl_cb *cb,
+			   struct nl_msg *msg,
+			   int argc, char **argv)
+{
+	unsigned char mac_addr[ETH_ALEN];
+
+	if (argc < 1)
+		return 1;
+
+	if (mac_addr_a2n(mac_addr, argv[0])) {
+		fprintf(stderr, "invalid mac address\n");
+		return 2;
+	}
+
+	argc--;
+	argv++;
+
+	if (argc)
+		return 1;
+
+	NLA_PUT(msg, NL80211_ATTR_MAC, ETH_ALEN, mac_addr);
+
+	nl_cb_set(cb, NL_CB_VALID, NL_CB_CUSTOM, print_link_sta, NULL);
+
+	return 0;
+ nla_put_failure:
+	return -ENOBUFS;
+}
+
+static int handle_link(struct nl80211_state *state, struct nl_cb *cb,
+		       struct nl_msg *msg, int argc, char **argv)
+{
+	char *link_argv[] = {
+		NULL,
+		"link",
+		"get_bss",
+		NULL,
+	};
+	char *station_argv[] = {
+		NULL,
+		"link",
+		"get_sta",
+		NULL,
+		NULL,
+	};
+	char bssid_buf[3*6];
+	int err;
+
+	link_argv[0] = argv[0];
+	err = handle_cmd(state, II_NETDEV, 3, link_argv);
+	if (err)
+		return err;
+
+	if (!lr.link_found) {
+		if (!lr.anything_found)
+			printf("Not connected.\n");
+		return 0;
+	}
+
+	mac_addr_n2a(bssid_buf, lr.bssid);
+	bssid_buf[17] = '\0';
+
+	station_argv[0] = argv[0];
+	station_argv[3] = bssid_buf;
+	return handle_cmd(state, II_NETDEV, 4, station_argv);
+}
+TOPLEVEL(link, NULL, 0, 0, CIB_NETDEV, handle_link,
+	 "Print information about the current link, if any.");
+HIDDEN(link, get_sta, "", NL80211_CMD_GET_STATION, 0,
+	CIB_NETDEV, handle_link_sta);
+HIDDEN(link, get_bss, NULL, NL80211_CMD_GET_SCAN, NLM_F_DUMP,
+	CIB_NETDEV, handle_scan_for_link);
diff --git a/external/iw/mesh.c b/external/iw/mesh.c
new file mode 100644
index 0000000..7c6ab3d
--- /dev/null
+++ b/external/iw/mesh.c
@@ -0,0 +1,367 @@
+#include <net/if.h>
+#include <errno.h>
+#include <string.h>
+
+#include <netlink/genl/genl.h>
+#include <netlink/genl/family.h>
+#include <netlink/genl/ctrl.h>
+#include <netlink/msg.h>
+#include <netlink/attr.h>
+
+#include "nl80211.h"
+#include "iw.h"
+
+SECTION(mesh);
+
+
+typedef struct _any_t {
+	union {
+		uint32_t as_32;
+		uint16_t as_16;
+		uint8_t as_8;
+	} u;
+} _any;
+
+/* describes a mesh parameter */
+struct mesh_param_descr {
+	const char *name;
+	enum nl80211_meshconf_params mesh_param_num;
+	int (*nla_put_fn)(struct nl_msg*, int, _any*);
+	uint32_t (*parse_fn)(const char*, _any*);
+	void (*nla_print_fn)(struct nlattr *);
+};
+
+/* utility functions for manipulating and printing u8/u16/u32 values and
+ * timesouts. */
+static int _my_nla_put_u8(struct nl_msg *n, int mesh_param_num, _any *value)
+{
+	return nla_put(n, mesh_param_num, sizeof(uint8_t), &value->u.as_8);
+}
+
+static int _my_nla_put_u16(struct nl_msg *n, int mesh_param_num, _any *value)
+{
+	return nla_put(n, mesh_param_num, sizeof(uint16_t), &value->u.as_16);
+}
+
+static int _my_nla_put_u32(struct nl_msg *n, int mesh_param_num, _any *value)
+{
+	return nla_put(n, mesh_param_num, sizeof(uint32_t), &value->u.as_32);
+}
+
+static uint32_t _parse_u8(const char *str, _any *ret)
+{
+	char *endptr = NULL;
+	unsigned long int v = strtoul(str, &endptr, 10);
+	if (*endptr != '\0')
+		return 0xff;
+	if (v > 0xff)
+		return 0xff;
+	ret->u.as_8 = (uint8_t)v;
+	return 0;
+}
+
+static uint32_t _parse_u8_as_bool(const char *str, _any *ret)
+{
+	char *endptr = NULL;
+	unsigned long int v = strtoul(str, &endptr, 10);
+	if (*endptr != '\0')
+		return 0x1;
+	if (v > 0x1)
+		return 0x1;
+	ret->u.as_8 = (uint8_t)v;
+	return 0;
+}
+
+static uint32_t _parse_u16(const char *str, _any *ret)
+{
+	char *endptr = NULL;
+	long int v = strtol(str, &endptr, 10);
+	if (*endptr != '\0')
+		return 0xffff;
+	if ((v < 0) || (v > 0xffff))
+		return 0xffff;
+	ret->u.as_16 = (uint16_t)v;
+	return 0;
+}
+
+static uint32_t _parse_u32(const char *str, _any *ret)
+{
+	char *endptr = NULL;
+	long long int v = strtoll(str, &endptr, 10);
+	if (*endptr != '\0')
+		return 0xffffffff;
+	if ((v < 0) || (v > 0xffffffff))
+		return 0xffffffff;
+	ret->u.as_32 = (uint32_t)v;
+	return 0;
+}
+
+static void _print_u8(struct nlattr *a)
+{
+	printf("%d", nla_get_u8(a));
+}
+
+static void _print_u16(struct nlattr *a)
+{
+	printf("%d", nla_get_u16(a));
+}
+
+static void _print_u16_timeout(struct nlattr *a)
+{
+	printf("%d milliseconds", nla_get_u16(a));
+}
+
+static void _print_u16_in_TUs(struct nlattr *a)
+{
+	printf("%d TUs", nla_get_u16(a));
+}
+
+static void _print_u32_timeout(struct nlattr *a)
+{
+	printf("%u milliseconds", nla_get_u32(a));
+}
+
+static void _print_u32_in_TUs(struct nlattr *a)
+{
+	printf("%d TUs", nla_get_u32(a));
+}
+
+/* The current mesh parameters */
+const static struct mesh_param_descr _mesh_param_descrs[] =
+{
+	{"mesh_retry_timeout",
+	NL80211_MESHCONF_RETRY_TIMEOUT,
+	_my_nla_put_u16, _parse_u16, _print_u16_timeout},
+	{"mesh_confirm_timeout",
+	NL80211_MESHCONF_CONFIRM_TIMEOUT,
+	_my_nla_put_u16, _parse_u16, _print_u16_timeout},
+	{"mesh_holding_timeout",
+	NL80211_MESHCONF_HOLDING_TIMEOUT,
+	_my_nla_put_u16, _parse_u16, _print_u16_timeout},
+	{"mesh_max_peer_links",
+	NL80211_MESHCONF_MAX_PEER_LINKS,
+	_my_nla_put_u16, _parse_u16, _print_u16},
+	{"mesh_max_retries",
+	NL80211_MESHCONF_MAX_RETRIES,
+	_my_nla_put_u8, _parse_u8, _print_u8},
+	{"mesh_ttl",
+	NL80211_MESHCONF_TTL,
+	_my_nla_put_u8, _parse_u8, _print_u8},
+	{"mesh_element_ttl",
+	NL80211_MESHCONF_ELEMENT_TTL,
+	_my_nla_put_u8, _parse_u8, _print_u8},
+	{"mesh_auto_open_plinks",
+	NL80211_MESHCONF_AUTO_OPEN_PLINKS,
+	_my_nla_put_u8, _parse_u8_as_bool, _print_u8},
+	{"mesh_hwmp_max_preq_retries",
+	NL80211_MESHCONF_HWMP_MAX_PREQ_RETRIES,
+	_my_nla_put_u8, _parse_u8, _print_u8},
+	{"mesh_path_refresh_time",
+	NL80211_MESHCONF_PATH_REFRESH_TIME,
+	_my_nla_put_u32, _parse_u32, _print_u32_timeout},
+	{"mesh_min_discovery_timeout",
+	NL80211_MESHCONF_MIN_DISCOVERY_TIMEOUT,
+	_my_nla_put_u16, _parse_u16, _print_u16_timeout},
+	{"mesh_hwmp_active_path_timeout",
+	NL80211_MESHCONF_HWMP_ACTIVE_PATH_TIMEOUT,
+	_my_nla_put_u32, _parse_u32, _print_u32_in_TUs},
+	{"mesh_hwmp_preq_min_interval",
+	NL80211_MESHCONF_HWMP_PREQ_MIN_INTERVAL,
+	_my_nla_put_u16, _parse_u16, _print_u16_in_TUs},
+	{"mesh_hwmp_net_diameter_traversal_time",
+	NL80211_MESHCONF_HWMP_NET_DIAM_TRVS_TIME,
+	_my_nla_put_u16, _parse_u16, _print_u16_in_TUs},
+	{"mesh_hwmp_rootmode", NL80211_MESHCONF_HWMP_ROOTMODE,
+	_my_nla_put_u8, _parse_u8, _print_u8},
+};
+
+static void print_all_mesh_param_descr(void)
+{
+	int i;
+
+	printf("Possible mesh parameters are:\n");
+
+	for (i = 0; i < ARRAY_SIZE(_mesh_param_descrs); i++)
+		printf(" - %s\n", _mesh_param_descrs[i].name);
+}
+
+static const struct mesh_param_descr *find_mesh_param(const char *name)
+{
+	int i;
+	const struct mesh_param_descr *mdescr = NULL;
+
+	/* Find out what mesh parameter we want to change. */
+	for (i = 0; i < ARRAY_SIZE(_mesh_param_descrs); i++) {
+		if (!strcmp(_mesh_param_descrs[i].name, name))
+			return _mesh_param_descrs + i;
+	}
+
+	if (!mdescr) {
+		print_all_mesh_param_descr();
+		return NULL;
+	}
+	return mdescr;
+}
+
+/* Setter */
+static int set_interface_meshparam(struct nl80211_state *state,
+				   struct nl_cb *cb,
+				   struct nl_msg *msg,
+				   int argc, char **argv)
+{
+	const struct mesh_param_descr *mdescr;
+	struct nlattr *container;
+	uint32_t ret;
+	int err;
+
+	container = nla_nest_start(msg, NL80211_ATTR_MESH_PARAMS);
+	if (!container)
+		return -ENOBUFS;
+
+	if (!argc)
+		return 1;
+
+	while (argc) {
+		const char *name;
+		char *value;
+		_any any;
+
+		memset(&any, 0, sizeof(_any));
+
+		name = argv[0];
+		value = strchr(name, '=');
+		if (value) {
+			*value = '\0';
+			value++;
+			argc--;
+			argv++;
+		} else {
+			/* backward compat -- accept w/o '=' */
+			if (argc < 2) {
+				printf("Must specify a value for %s.\n", name);
+				return 2;
+			}
+			value = argv[1];
+			argc -= 2;
+			argv += 2;
+		}
+
+		mdescr = find_mesh_param(name);
+		if (!mdescr)
+			return 2;
+
+		/* Parse the new value */
+		ret = mdescr->parse_fn(value, &any);
+		if (ret != 0) {
+			printf("%s must be set to a number "
+			       "between 0 and %u\n", mdescr->name, ret);
+			return 2;
+		}
+
+		err = mdescr->nla_put_fn(msg, mdescr->mesh_param_num, &any);
+		if (err)
+			return err;
+	}
+	nla_nest_end(msg, container);
+
+	return err;
+}
+
+COMMAND(set, mesh_param, "<param>=<value> [<param>=<value>]*",
+	NL80211_CMD_SET_MESH_PARAMS, 0, CIB_NETDEV, set_interface_meshparam,
+	"Set mesh parameter (run command without any to see available ones).");
+
+/* Getter */
+static int print_mesh_param_handler(struct nl_msg *msg, void *arg)
+{
+	const struct mesh_param_descr *mdescr = arg;
+	struct nlattr *attrs[NL80211_ATTR_MAX + 1];
+	struct nlattr *parent_attr;
+	struct nlattr *mesh_params[NL80211_MESHCONF_ATTR_MAX + 1];
+	struct genlmsghdr *gnlh = nlmsg_data(nlmsg_hdr(msg));
+
+	/* locate NL80211_ATTR_MESH_PARAMS */
+	nla_parse(attrs, NL80211_ATTR_MAX, genlmsg_attrdata(gnlh, 0),
+		  genlmsg_attrlen(gnlh, 0), NULL);
+	parent_attr = attrs[NL80211_ATTR_MESH_PARAMS];
+	if (!parent_attr)
+		return -EINVAL;
+
+	/* unpack the mesh parameters */
+	if (nla_parse_nested(mesh_params, NL80211_MESHCONF_ATTR_MAX,
+			     parent_attr, NULL))
+		return -EINVAL;
+
+	if (!mdescr) {
+		int i;
+
+		for (i = 0; i < ARRAY_SIZE(_mesh_param_descrs); i++) {
+			mdescr = &_mesh_param_descrs[i];
+			printf("%s = ", mdescr->name);
+			mdescr->nla_print_fn(mesh_params[mdescr->mesh_param_num]);
+			printf("\n");
+		}
+		return NL_SKIP;
+	}
+
+	/* print out the mesh parameter */
+	mdescr->nla_print_fn(mesh_params[mdescr->mesh_param_num]);
+	printf("\n");
+	return NL_SKIP;
+}
+
+static int get_interface_meshparam(struct nl80211_state *state,
+				   struct nl_cb *cb,
+				   struct nl_msg *msg,
+				   int argc, char **argv)
+{
+	const struct mesh_param_descr *mdescr = NULL;
+
+	if (argc > 1)
+		return 1;
+
+	if (argc == 1) {
+		mdescr = find_mesh_param(argv[0]);
+		if (!mdescr)
+			return 2;
+	}
+
+	nl_cb_set(cb, NL_CB_VALID, NL_CB_CUSTOM,
+		  print_mesh_param_handler, (void *)mdescr);
+	return 0;
+}
+
+COMMAND(get, mesh_param, "[<param>]",
+	NL80211_CMD_GET_MESH_PARAMS, 0, CIB_NETDEV, get_interface_meshparam,
+	"Retrieve mesh parameter (run command without any to see available ones).");
+
+static int join_mesh(struct nl80211_state *state, struct nl_cb *cb,
+		     struct nl_msg *msg, int argc, char **argv)
+{
+	if (argc < 1)
+		return 1;
+
+	NLA_PUT(msg, NL80211_ATTR_MESH_ID, strlen(argv[0]), argv[0]);
+	argc--;
+	argv++;
+
+	if (!argc)
+		return 0;
+	return set_interface_meshparam(state, cb, msg, argc, argv);
+ nla_put_failure:
+	return -ENOBUFS;
+}
+COMMAND(mesh, join, "<mesh ID> [<param>=<value>]*",
+	NL80211_CMD_JOIN_MESH, 0, CIB_NETDEV, join_mesh,
+	"Join a mesh with the given mesh ID and mesh parameters.");
+
+static int leave_mesh(struct nl80211_state *state, struct nl_cb *cb,
+		      struct nl_msg *msg, int argc, char **argv)
+{
+	if (argc)
+		return 1;
+
+	return 0;
+}
+COMMAND(mesh, leave, NULL, NL80211_CMD_LEAVE_MESH, 0, CIB_NETDEV, leave_mesh,
+	"Leave a mesh.");
diff --git a/external/iw/mpath.c b/external/iw/mpath.c
new file mode 100644
index 0000000..3afe7b7
--- /dev/null
+++ b/external/iw/mpath.c
@@ -0,0 +1,194 @@
+#include <net/if.h>
+#include <errno.h>
+#include <string.h>
+
+#include <netlink/genl/genl.h>
+#include <netlink/genl/family.h>
+#include <netlink/genl/ctrl.h>
+#include <netlink/msg.h>
+#include <netlink/attr.h>
+
+#include "nl80211.h"
+#include "iw.h"
+
+SECTION(mpath);
+
+enum plink_state {
+	LISTEN,
+	OPN_SNT,
+	OPN_RCVD,
+	CNF_RCVD,
+	ESTAB,
+	HOLDING,
+	BLOCKED
+};
+
+enum plink_actions {
+	PLINK_ACTION_UNDEFINED,
+	PLINK_ACTION_OPEN,
+	PLINK_ACTION_BLOCK,
+};
+
+
+static int print_mpath_handler(struct nl_msg *msg, void *arg)
+{
+	struct nlattr *tb[NL80211_ATTR_MAX + 1];
+	struct genlmsghdr *gnlh = nlmsg_data(nlmsg_hdr(msg));
+	struct nlattr *pinfo[NL80211_MPATH_INFO_MAX + 1];
+	char dst[20], next_hop[20], dev[20];
+	static struct nla_policy mpath_policy[NL80211_MPATH_INFO_MAX + 1] = {
+		[NL80211_MPATH_INFO_FRAME_QLEN] = { .type = NLA_U32 },
+		[NL80211_MPATH_INFO_SN] = { .type = NLA_U32 },
+		[NL80211_MPATH_INFO_METRIC] = { .type = NLA_U32 },
+		[NL80211_MPATH_INFO_EXPTIME] = { .type = NLA_U32 },
+		[NL80211_MPATH_INFO_DISCOVERY_TIMEOUT] = { .type = NLA_U32 },
+		[NL80211_MPATH_INFO_DISCOVERY_RETRIES] = { .type = NLA_U8 },
+		[NL80211_MPATH_INFO_FLAGS] = { .type = NLA_U8 },
+	};
+
+	nla_parse(tb, NL80211_ATTR_MAX, genlmsg_attrdata(gnlh, 0),
+		  genlmsg_attrlen(gnlh, 0), NULL);
+
+	/*
+	 * TODO: validate the interface and mac address!
+	 * Otherwise, there's a race condition as soon as
+	 * the kernel starts sending mpath notifications.
+	 */
+
+	if (!tb[NL80211_ATTR_MPATH_INFO]) {
+		fprintf(stderr, "mpath info missing!\n");
+		return NL_SKIP;
+	}
+	if (nla_parse_nested(pinfo, NL80211_MPATH_INFO_MAX,
+			     tb[NL80211_ATTR_MPATH_INFO],
+			     mpath_policy)) {
+		fprintf(stderr, "failed to parse nested attributes!\n");
+		return NL_SKIP;
+	}
+
+	mac_addr_n2a(dst, nla_data(tb[NL80211_ATTR_MAC]));
+	mac_addr_n2a(next_hop, nla_data(tb[NL80211_ATTR_MPATH_NEXT_HOP]));
+	if_indextoname(nla_get_u32(tb[NL80211_ATTR_IFINDEX]), dev);
+	printf("%s %s %s", dst, next_hop, dev);
+	if (pinfo[NL80211_MPATH_INFO_SN])
+		printf("\t%u",
+			nla_get_u32(pinfo[NL80211_MPATH_INFO_SN]));
+	if (pinfo[NL80211_MPATH_INFO_METRIC])
+		printf("\t%u",
+			nla_get_u32(pinfo[NL80211_MPATH_INFO_METRIC]));
+	if (pinfo[NL80211_MPATH_INFO_FRAME_QLEN])
+		printf("\t%u",
+			nla_get_u32(pinfo[NL80211_MPATH_INFO_FRAME_QLEN]));
+	if (pinfo[NL80211_MPATH_INFO_EXPTIME])
+		printf("\t%u",
+			nla_get_u32(pinfo[NL80211_MPATH_INFO_EXPTIME]));
+	if (pinfo[NL80211_MPATH_INFO_DISCOVERY_TIMEOUT])
+		printf("\t%u",
+		nla_get_u32(pinfo[NL80211_MPATH_INFO_DISCOVERY_TIMEOUT]));
+	if (pinfo[NL80211_MPATH_INFO_DISCOVERY_RETRIES])
+		printf("\t%u",
+		nla_get_u8(pinfo[NL80211_MPATH_INFO_DISCOVERY_RETRIES]));
+	if (pinfo[NL80211_MPATH_INFO_FLAGS])
+		printf("\t0x%x",
+			nla_get_u8(pinfo[NL80211_MPATH_INFO_FLAGS]));
+
+	printf("\n");
+	return NL_SKIP;
+}
+
+static int handle_mpath_get(struct nl80211_state *state,
+			    struct nl_cb *cb,
+			    struct nl_msg *msg,
+			    int argc, char **argv)
+{
+	unsigned char dst[ETH_ALEN];
+
+	if (argc < 1)
+		return 1;
+
+	if (mac_addr_a2n(dst, argv[0])) {
+		fprintf(stderr, "invalid mac address\n");
+		return 2;
+	}
+	argc--;
+	argv++;
+
+	if (argc)
+		return 1;
+
+	NLA_PUT(msg, NL80211_ATTR_MAC, ETH_ALEN, dst);
+
+	nl_cb_set(cb, NL_CB_VALID, NL_CB_CUSTOM, print_mpath_handler, NULL);
+
+	return 0;
+ nla_put_failure:
+	return -ENOBUFS;
+}
+COMMAND(mpath, get, "<MAC address>",
+	NL80211_CMD_GET_MPATH, 0, CIB_NETDEV, handle_mpath_get,
+	"Get information on mesh path to the given node.");
+COMMAND(mpath, del, "<MAC address>",
+	NL80211_CMD_DEL_MPATH, 0, CIB_NETDEV, handle_mpath_get,
+	"Remove the mesh path to the given node.");
+
+static int handle_mpath_set(struct nl80211_state *state,
+			    struct nl_cb *cb,
+			    struct nl_msg *msg,
+			    int argc, char **argv)
+{
+	unsigned char dst[ETH_ALEN];
+	unsigned char next_hop[ETH_ALEN];
+
+	if (argc < 3)
+		return 1;
+
+	if (mac_addr_a2n(dst, argv[0])) {
+		fprintf(stderr, "invalid destination mac address\n");
+		return 2;
+	}
+	argc--;
+	argv++;
+
+	if (strcmp("next_hop", argv[0]) != 0)
+		return 1;
+	argc--;
+	argv++;
+
+	if (mac_addr_a2n(next_hop, argv[0])) {
+		fprintf(stderr, "invalid next hop mac address\n");
+		return 2;
+	}
+	argc--;
+	argv++;
+
+	if (argc)
+		return 1;
+
+	NLA_PUT(msg, NL80211_ATTR_MAC, ETH_ALEN, dst);
+	NLA_PUT(msg, NL80211_ATTR_MPATH_NEXT_HOP, ETH_ALEN, next_hop);
+
+	nl_cb_set(cb, NL_CB_VALID, NL_CB_CUSTOM, print_mpath_handler, NULL);
+	return 0;
+ nla_put_failure:
+	return -ENOBUFS;
+}
+COMMAND(mpath, new, "<destination MAC address> next_hop <next hop MAC address>",
+	NL80211_CMD_NEW_MPATH, 0, CIB_NETDEV, handle_mpath_set,
+	"Create a new mesh path (instead of relying on automatic discovery).");
+COMMAND(mpath, set, "<destination MAC address> next_hop <next hop MAC address>",
+	NL80211_CMD_SET_MPATH, 0, CIB_NETDEV, handle_mpath_set,
+	"Set an existing mesh path's next hop.");
+
+static int handle_mpath_dump(struct nl80211_state *state,
+			     struct nl_cb *cb,
+			     struct nl_msg *msg,
+			     int argc, char **argv)
+{
+	printf("DEST ADDR         NEXT HOP          IFACE\tSN\tMETRIC\tQLEN\t"
+	       "EXPTIME\t\tDTIM\tDRET\tFLAGS\n");
+	nl_cb_set(cb, NL_CB_VALID, NL_CB_CUSTOM, print_mpath_handler, NULL);
+	return 0;
+}
+COMMAND(mpath, dump, NULL,
+	NL80211_CMD_GET_MPATH, NLM_F_DUMP, CIB_NETDEV, handle_mpath_dump,
+	"List known mesh paths.");
diff --git a/external/iw/nl80211.h b/external/iw/nl80211.h
new file mode 100644
index 0000000..3804212
--- /dev/null
+++ b/external/iw/nl80211.h
@@ -0,0 +1,1897 @@
+#ifndef __LINUX_NL80211_H
+#define __LINUX_NL80211_H
+/*
+ * 802.11 netlink interface public header
+ *
+ * Copyright 2006-2010 Johannes Berg <johannes@sipsolutions.net>
+ * Copyright 2008 Michael Wu <flamingice@sourmilk.net>
+ * Copyright 2008 Luis Carlos Cobo <luisca@cozybit.com>
+ * Copyright 2008 Michael Buesch <mb@bu3sch.de>
+ * Copyright 2008, 2009 Luis R. Rodriguez <lrodriguez@atheros.com>
+ * Copyright 2008 Jouni Malinen <jouni.malinen@atheros.com>
+ * Copyright 2008 Colin McCabe <colin@cozybit.com>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+
+#include <linux/types.h>
+
+/**
+ * DOC: Station handling
+ *
+ * Stations are added per interface, but a special case exists with VLAN
+ * interfaces. When a station is bound to an AP interface, it may be moved
+ * into a VLAN identified by a VLAN interface index (%NL80211_ATTR_STA_VLAN).
+ * The station is still assumed to belong to the AP interface it was added
+ * to.
+ *
+ * TODO: need more info?
+ */
+
+/**
+ * DOC: Frame transmission/registration support
+ *
+ * Frame transmission and registration support exists to allow userspace
+ * management entities such as wpa_supplicant react to management frames
+ * that are not being handled by the kernel. This includes, for example,
+ * certain classes of action frames that cannot be handled in the kernel
+ * for various reasons.
+ *
+ * Frame registration is done on a per-interface basis and registrations
+ * cannot be removed other than by closing the socket. It is possible to
+ * specify a registration filter to register, for example, only for a
+ * certain type of action frame. In particular with action frames, those
+ * that userspace registers for will not be returned as unhandled by the
+ * driver, so that the registered application has to take responsibility
+ * for doing that.
+ *
+ * The type of frame that can be registered for is also dependent on the
+ * driver and interface type. The frame types are advertised in wiphy
+ * attributes so applications know what to expect.
+ *
+ * NOTE: When an interface changes type while registrations are active,
+ *       these registrations are ignored until the interface type is
+ *       changed again. This means that changing the interface type can
+ *       lead to a situation that couldn't otherwise be produced, but
+ *       any such registrations will be dormant in the sense that they
+ *       will not be serviced, i.e. they will not receive any frames.
+ *
+ * Frame transmission allows userspace to send for example the required
+ * responses to action frames. It is subject to some sanity checking,
+ * but many frames can be transmitted. When a frame was transmitted, its
+ * status is indicated to the sending socket.
+ *
+ * For more technical details, see the corresponding command descriptions
+ * below.
+ */
+
+/**
+ * enum nl80211_commands - supported nl80211 commands
+ *
+ * @NL80211_CMD_UNSPEC: unspecified command to catch errors
+ *
+ * @NL80211_CMD_GET_WIPHY: request information about a wiphy or dump request
+ *	to get a list of all present wiphys.
+ * @NL80211_CMD_SET_WIPHY: set wiphy parameters, needs %NL80211_ATTR_WIPHY or
+ *	%NL80211_ATTR_IFINDEX; can be used to set %NL80211_ATTR_WIPHY_NAME,
+ *	%NL80211_ATTR_WIPHY_TXQ_PARAMS, %NL80211_ATTR_WIPHY_FREQ,
+ *	%NL80211_ATTR_WIPHY_CHANNEL_TYPE, %NL80211_ATTR_WIPHY_RETRY_SHORT,
+ *	%NL80211_ATTR_WIPHY_RETRY_LONG, %NL80211_ATTR_WIPHY_FRAG_THRESHOLD,
+ *	and/or %NL80211_ATTR_WIPHY_RTS_THRESHOLD.
+ *	However, for setting the channel, see %NL80211_CMD_SET_CHANNEL
+ *	instead, the support here is for backward compatibility only.
+ * @NL80211_CMD_NEW_WIPHY: Newly created wiphy, response to get request
+ *	or rename notification. Has attributes %NL80211_ATTR_WIPHY and
+ *	%NL80211_ATTR_WIPHY_NAME.
+ * @NL80211_CMD_DEL_WIPHY: Wiphy deleted. Has attributes
+ *	%NL80211_ATTR_WIPHY and %NL80211_ATTR_WIPHY_NAME.
+ *
+ * @NL80211_CMD_GET_INTERFACE: Request an interface's configuration;
+ *	either a dump request on a %NL80211_ATTR_WIPHY or a specific get
+ *	on an %NL80211_ATTR_IFINDEX is supported.
+ * @NL80211_CMD_SET_INTERFACE: Set type of a virtual interface, requires
+ *	%NL80211_ATTR_IFINDEX and %NL80211_ATTR_IFTYPE.
+ * @NL80211_CMD_NEW_INTERFACE: Newly created virtual interface or response
+ *	to %NL80211_CMD_GET_INTERFACE. Has %NL80211_ATTR_IFINDEX,
+ *	%NL80211_ATTR_WIPHY and %NL80211_ATTR_IFTYPE attributes. Can also
+ *	be sent from userspace to request creation of a new virtual interface,
+ *	then requires attributes %NL80211_ATTR_WIPHY, %NL80211_ATTR_IFTYPE and
+ *	%NL80211_ATTR_IFNAME.
+ * @NL80211_CMD_DEL_INTERFACE: Virtual interface was deleted, has attributes
+ *	%NL80211_ATTR_IFINDEX and %NL80211_ATTR_WIPHY. Can also be sent from
+ *	userspace to request deletion of a virtual interface, then requires
+ *	attribute %NL80211_ATTR_IFINDEX.
+ *
+ * @NL80211_CMD_GET_KEY: Get sequence counter information for a key specified
+ *	by %NL80211_ATTR_KEY_IDX and/or %NL80211_ATTR_MAC.
+ * @NL80211_CMD_SET_KEY: Set key attributes %NL80211_ATTR_KEY_DEFAULT,
+ *	%NL80211_ATTR_KEY_DEFAULT_MGMT, or %NL80211_ATTR_KEY_THRESHOLD.
+ * @NL80211_CMD_NEW_KEY: add a key with given %NL80211_ATTR_KEY_DATA,
+ *	%NL80211_ATTR_KEY_IDX, %NL80211_ATTR_MAC, %NL80211_ATTR_KEY_CIPHER,
+ *	and %NL80211_ATTR_KEY_SEQ attributes.
+ * @NL80211_CMD_DEL_KEY: delete a key identified by %NL80211_ATTR_KEY_IDX
+ *	or %NL80211_ATTR_MAC.
+ *
+ * @NL80211_CMD_GET_BEACON: retrieve beacon information (returned in a
+ *	%NL80222_CMD_NEW_BEACON message)
+ * @NL80211_CMD_SET_BEACON: set the beacon on an access point interface
+ *	using the %NL80211_ATTR_BEACON_INTERVAL, %NL80211_ATTR_DTIM_PERIOD,
+ *	%NL80211_ATTR_BEACON_HEAD and %NL80211_ATTR_BEACON_TAIL attributes.
+ * @NL80211_CMD_NEW_BEACON: add a new beacon to an access point interface,
+ *	parameters are like for %NL80211_CMD_SET_BEACON.
+ * @NL80211_CMD_DEL_BEACON: remove the beacon, stop sending it
+ *
+ * @NL80211_CMD_GET_STATION: Get station attributes for station identified by
+ *	%NL80211_ATTR_MAC on the interface identified by %NL80211_ATTR_IFINDEX.
+ * @NL80211_CMD_SET_STATION: Set station attributes for station identified by
+ *	%NL80211_ATTR_MAC on the interface identified by %NL80211_ATTR_IFINDEX.
+ * @NL80211_CMD_NEW_STATION: Add a station with given attributes to the
+ *	the interface identified by %NL80211_ATTR_IFINDEX.
+ * @NL80211_CMD_DEL_STATION: Remove a station identified by %NL80211_ATTR_MAC
+ *	or, if no MAC address given, all stations, on the interface identified
+ *	by %NL80211_ATTR_IFINDEX.
+ *
+ * @NL80211_CMD_GET_MPATH: Get mesh path attributes for mesh path to
+ * 	destination %NL80211_ATTR_MAC on the interface identified by
+ * 	%NL80211_ATTR_IFINDEX.
+ * @NL80211_CMD_SET_MPATH:  Set mesh path attributes for mesh path to
+ * 	destination %NL80211_ATTR_MAC on the interface identified by
+ * 	%NL80211_ATTR_IFINDEX.
+ * @NL80211_CMD_NEW_PATH: Add a mesh path with given attributes to the
+ *	the interface identified by %NL80211_ATTR_IFINDEX.
+ * @NL80211_CMD_DEL_PATH: Remove a mesh path identified by %NL80211_ATTR_MAC
+ *	or, if no MAC address given, all mesh paths, on the interface identified
+ *	by %NL80211_ATTR_IFINDEX.
+ * @NL80211_CMD_SET_BSS: Set BSS attributes for BSS identified by
+ *	%NL80211_ATTR_IFINDEX.
+ *
+ * @NL80211_CMD_GET_REG: ask the wireless core to send us its currently set
+ * 	regulatory domain.
+ * @NL80211_CMD_SET_REG: Set current regulatory domain. CRDA sends this command
+ *	after being queried by the kernel. CRDA replies by sending a regulatory
+ *	domain structure which consists of %NL80211_ATTR_REG_ALPHA set to our
+ *	current alpha2 if it found a match. It also provides
+ * 	NL80211_ATTR_REG_RULE_FLAGS, and a set of regulatory rules. Each
+ * 	regulatory rule is a nested set of attributes  given by
+ * 	%NL80211_ATTR_REG_RULE_FREQ_[START|END] and
+ * 	%NL80211_ATTR_FREQ_RANGE_MAX_BW with an attached power rule given by
+ * 	%NL80211_ATTR_REG_RULE_POWER_MAX_ANT_GAIN and
+ * 	%NL80211_ATTR_REG_RULE_POWER_MAX_EIRP.
+ * @NL80211_CMD_REQ_SET_REG: ask the wireless core to set the regulatory domain
+ * 	to the specified ISO/IEC 3166-1 alpha2 country code. The core will
+ * 	store this as a valid request and then query userspace for it.
+ *
+ * @NL80211_CMD_GET_MESH_PARAMS: Get mesh networking properties for the
+ *	interface identified by %NL80211_ATTR_IFINDEX
+ *
+ * @NL80211_CMD_SET_MESH_PARAMS: Set mesh networking properties for the
+ *      interface identified by %NL80211_ATTR_IFINDEX
+ *
+ * @NL80211_CMD_SET_MGMT_EXTRA_IE: Set extra IEs for management frames. The
+ *	interface is identified with %NL80211_ATTR_IFINDEX and the management
+ *	frame subtype with %NL80211_ATTR_MGMT_SUBTYPE. The extra IE data to be
+ *	added to the end of the specified management frame is specified with
+ *	%NL80211_ATTR_IE. If the command succeeds, the requested data will be
+ *	added to all specified management frames generated by
+ *	kernel/firmware/driver.
+ *	Note: This command has been removed and it is only reserved at this
+ *	point to avoid re-using existing command number. The functionality this
+ *	command was planned for has been provided with cleaner design with the
+ *	option to specify additional IEs in NL80211_CMD_TRIGGER_SCAN,
+ *	NL80211_CMD_AUTHENTICATE, NL80211_CMD_ASSOCIATE,
+ *	NL80211_CMD_DEAUTHENTICATE, and NL80211_CMD_DISASSOCIATE.
+ *
+ * @NL80211_CMD_GET_SCAN: get scan results
+ * @NL80211_CMD_TRIGGER_SCAN: trigger a new scan with the given parameters
+ * @NL80211_CMD_NEW_SCAN_RESULTS: scan notification (as a reply to
+ *	NL80211_CMD_GET_SCAN and on the "scan" multicast group)
+ * @NL80211_CMD_SCAN_ABORTED: scan was aborted, for unspecified reasons,
+ *	partial scan results may be available
+ *
+ * @NL80211_CMD_GET_SURVEY: get survey resuls, e.g. channel occupation
+ *      or noise level
+ * @NL80211_CMD_NEW_SURVEY_RESULTS: survey data notification (as a reply to
+ *	NL80211_CMD_GET_SURVEY and on the "scan" multicast group)
+ *
+ * @NL80211_CMD_REG_CHANGE: indicates to userspace the regulatory domain
+ * 	has been changed and provides details of the request information
+ * 	that caused the change such as who initiated the regulatory request
+ * 	(%NL80211_ATTR_REG_INITIATOR), the wiphy_idx
+ * 	(%NL80211_ATTR_REG_ALPHA2) on which the request was made from if
+ * 	the initiator was %NL80211_REGDOM_SET_BY_COUNTRY_IE or
+ * 	%NL80211_REGDOM_SET_BY_DRIVER, the type of regulatory domain
+ * 	set (%NL80211_ATTR_REG_TYPE), if the type of regulatory domain is
+ * 	%NL80211_REG_TYPE_COUNTRY the alpha2 to which we have moved on
+ * 	to (%NL80211_ATTR_REG_ALPHA2).
+ * @NL80211_CMD_REG_BEACON_HINT: indicates to userspace that an AP beacon
+ * 	has been found while world roaming thus enabling active scan or
+ * 	any mode of operation that initiates TX (beacons) on a channel
+ * 	where we would not have been able to do either before. As an example
+ * 	if you are world roaming (regulatory domain set to world or if your
+ * 	driver is using a custom world roaming regulatory domain) and while
+ * 	doing a passive scan on the 5 GHz band you find an AP there (if not
+ * 	on a DFS channel) you will now be able to actively scan for that AP
+ * 	or use AP mode on your card on that same channel. Note that this will
+ * 	never be used for channels 1-11 on the 2 GHz band as they are always
+ * 	enabled world wide. This beacon hint is only sent if your device had
+ * 	either disabled active scanning or beaconing on a channel. We send to
+ * 	userspace the wiphy on which we removed a restriction from
+ * 	(%NL80211_ATTR_WIPHY) and the channel on which this occurred
+ * 	before (%NL80211_ATTR_FREQ_BEFORE) and after (%NL80211_ATTR_FREQ_AFTER)
+ * 	the beacon hint was processed.
+ *
+ * @NL80211_CMD_AUTHENTICATE: authentication request and notification.
+ *	This command is used both as a command (request to authenticate) and
+ *	as an event on the "mlme" multicast group indicating completion of the
+ *	authentication process.
+ *	When used as a command, %NL80211_ATTR_IFINDEX is used to identify the
+ *	interface. %NL80211_ATTR_MAC is used to specify PeerSTAAddress (and
+ *	BSSID in case of station mode). %NL80211_ATTR_SSID is used to specify
+ *	the SSID (mainly for association, but is included in authentication
+ *	request, too, to help BSS selection. %NL80211_ATTR_WIPHY_FREQ is used
+ *	to specify the frequence of the channel in MHz. %NL80211_ATTR_AUTH_TYPE
+ *	is used to specify the authentication type. %NL80211_ATTR_IE is used to
+ *	define IEs (VendorSpecificInfo, but also including RSN IE and FT IEs)
+ *	to be added to the frame.
+ *	When used as an event, this reports reception of an Authentication
+ *	frame in station and IBSS modes when the local MLME processed the
+ *	frame, i.e., it was for the local STA and was received in correct
+ *	state. This is similar to MLME-AUTHENTICATE.confirm primitive in the
+ *	MLME SAP interface (kernel providing MLME, userspace SME). The
+ *	included %NL80211_ATTR_FRAME attribute contains the management frame
+ *	(including both the header and frame body, but not FCS). This event is
+ *	also used to indicate if the authentication attempt timed out. In that
+ *	case the %NL80211_ATTR_FRAME attribute is replaced with a
+ *	%NL80211_ATTR_TIMED_OUT flag (and %NL80211_ATTR_MAC to indicate which
+ *	pending authentication timed out).
+ * @NL80211_CMD_ASSOCIATE: association request and notification; like
+ *	NL80211_CMD_AUTHENTICATE but for Association and Reassociation
+ *	(similar to MLME-ASSOCIATE.request, MLME-REASSOCIATE.request,
+ *	MLME-ASSOCIATE.confirm or MLME-REASSOCIATE.confirm primitives).
+ * @NL80211_CMD_DEAUTHENTICATE: deauthentication request and notification; like
+ *	NL80211_CMD_AUTHENTICATE but for Deauthentication frames (similar to
+ *	MLME-DEAUTHENTICATION.request and MLME-DEAUTHENTICATE.indication
+ *	primitives).
+ * @NL80211_CMD_DISASSOCIATE: disassociation request and notification; like
+ *	NL80211_CMD_AUTHENTICATE but for Disassociation frames (similar to
+ *	MLME-DISASSOCIATE.request and MLME-DISASSOCIATE.indication primitives).
+ *
+ * @NL80211_CMD_MICHAEL_MIC_FAILURE: notification of a locally detected Michael
+ *	MIC (part of TKIP) failure; sent on the "mlme" multicast group; the
+ *	event includes %NL80211_ATTR_MAC to describe the source MAC address of
+ *	the frame with invalid MIC, %NL80211_ATTR_KEY_TYPE to show the key
+ *	type, %NL80211_ATTR_KEY_IDX to indicate the key identifier, and
+ *	%NL80211_ATTR_KEY_SEQ to indicate the TSC value of the frame; this
+ *	event matches with MLME-MICHAELMICFAILURE.indication() primitive
+ *
+ * @NL80211_CMD_JOIN_IBSS: Join a new IBSS -- given at least an SSID and a
+ *	FREQ attribute (for the initial frequency if no peer can be found)
+ *	and optionally a MAC (as BSSID) and FREQ_FIXED attribute if those
+ *	should be fixed rather than automatically determined. Can only be
+ *	executed on a network interface that is UP, and fixed BSSID/FREQ
+ *	may be rejected. Another optional parameter is the beacon interval,
+ *	given in the %NL80211_ATTR_BEACON_INTERVAL attribute, which if not
+ *	given defaults to 100 TU (102.4ms).
+ * @NL80211_CMD_LEAVE_IBSS: Leave the IBSS -- no special arguments, the IBSS is
+ *	determined by the network interface.
+ *
+ * @NL80211_CMD_TESTMODE: testmode command, takes a wiphy (or ifindex) attribute
+ *	to identify the device, and the TESTDATA blob attribute to pass through
+ *	to the driver.
+ *
+ * @NL80211_CMD_CONNECT: connection request and notification; this command
+ *	requests to connect to a specified network but without separating
+ *	auth and assoc steps. For this, you need to specify the SSID in a
+ *	%NL80211_ATTR_SSID attribute, and can optionally specify the association
+ *	IEs in %NL80211_ATTR_IE, %NL80211_ATTR_AUTH_TYPE, %NL80211_ATTR_MAC,
+ *	%NL80211_ATTR_WIPHY_FREQ, %NL80211_ATTR_CONTROL_PORT,
+ *	%NL80211_ATTR_CONTROL_PORT_ETHERTYPE and
+ *	%NL80211_ATTR_CONTROL_PORT_NO_ENCRYPT.
+ *	It is also sent as an event, with the BSSID and response IEs when the
+ *	connection is established or failed to be established. This can be
+ *	determined by the STATUS_CODE attribute.
+ * @NL80211_CMD_ROAM: request that the card roam (currently not implemented),
+ *	sent as an event when the card/driver roamed by itself.
+ * @NL80211_CMD_DISCONNECT: drop a given connection; also used to notify
+ *	userspace that a connection was dropped by the AP or due to other
+ *	reasons, for this the %NL80211_ATTR_DISCONNECTED_BY_AP and
+ *	%NL80211_ATTR_REASON_CODE attributes are used.
+ *
+ * @NL80211_CMD_SET_WIPHY_NETNS: Set a wiphy's netns. Note that all devices
+ *	associated with this wiphy must be down and will follow.
+ *
+ * @NL80211_CMD_REMAIN_ON_CHANNEL: Request to remain awake on the specified
+ *	channel for the specified amount of time. This can be used to do
+ *	off-channel operations like transmit a Public Action frame and wait for
+ *	a response while being associated to an AP on another channel.
+ *	%NL80211_ATTR_IFINDEX is used to specify which interface (and thus
+ *	radio) is used. %NL80211_ATTR_WIPHY_FREQ is used to specify the
+ *	frequency for the operation and %NL80211_ATTR_WIPHY_CHANNEL_TYPE may be
+ *	optionally used to specify additional channel parameters.
+ *	%NL80211_ATTR_DURATION is used to specify the duration in milliseconds
+ *	to remain on the channel. This command is also used as an event to
+ *	notify when the requested duration starts (it may take a while for the
+ *	driver to schedule this time due to other concurrent needs for the
+ *	radio).
+ *	When called, this operation returns a cookie (%NL80211_ATTR_COOKIE)
+ *	that will be included with any events pertaining to this request;
+ *	the cookie is also used to cancel the request.
+ * @NL80211_CMD_CANCEL_REMAIN_ON_CHANNEL: This command can be used to cancel a
+ *	pending remain-on-channel duration if the desired operation has been
+ *	completed prior to expiration of the originally requested duration.
+ *	%NL80211_ATTR_WIPHY or %NL80211_ATTR_IFINDEX is used to specify the
+ *	radio. The %NL80211_ATTR_COOKIE attribute must be given as well to
+ *	uniquely identify the request.
+ *	This command is also used as an event to notify when a requested
+ *	remain-on-channel duration has expired.
+ *
+ * @NL80211_CMD_SET_TX_BITRATE_MASK: Set the mask of rates to be used in TX
+ *	rate selection. %NL80211_ATTR_IFINDEX is used to specify the interface
+ *	and @NL80211_ATTR_TX_RATES the set of allowed rates.
+ *
+ * @NL80211_CMD_REGISTER_FRAME: Register for receiving certain mgmt frames
+ *	(via @NL80211_CMD_FRAME) for processing in userspace. This command
+ *	requires an interface index, a frame type attribute (optional for
+ *	backward compatibility reasons, if not given assumes action frames)
+ *	and a match attribute containing the first few bytes of the frame
+ *	that should match, e.g. a single byte for only a category match or
+ *	four bytes for vendor frames including the OUI. The registration
+ *	cannot be dropped, but is removed automatically when the netlink
+ *	socket is closed. Multiple registrations can be made.
+ * @NL80211_CMD_REGISTER_ACTION: Alias for @NL80211_CMD_REGISTER_FRAME for
+ *	backward compatibility
+ * @NL80211_CMD_FRAME: Management frame TX request and RX notification. This
+ *	command is used both as a request to transmit a management frame and
+ *	as an event indicating reception of a frame that was not processed in
+ *	kernel code, but is for us (i.e., which may need to be processed in a
+ *	user space application). %NL80211_ATTR_FRAME is used to specify the
+ *	frame contents (including header). %NL80211_ATTR_WIPHY_FREQ (and
+ *	optionally %NL80211_ATTR_WIPHY_CHANNEL_TYPE) is used to indicate on
+ *	which channel the frame is to be transmitted or was received. If this
+ *	channel is not the current channel (remain-on-channel or the
+ *	operational channel) the device will switch to the given channel and
+ *	transmit the frame, optionally waiting for a response for the time
+ *	specified using %NL80211_ATTR_DURATION. When called, this operation
+ *	returns a cookie (%NL80211_ATTR_COOKIE) that will be included with the
+ *	TX status event pertaining to the TX request.
+ * @NL80211_CMD_FRAME_WAIT_CANCEL: When an off-channel TX was requested, this
+ *	command may be used with the corresponding cookie to cancel the wait
+ *	time if it is known that it is no longer necessary.
+ * @NL80211_CMD_ACTION: Alias for @NL80211_CMD_FRAME for backward compatibility.
+ * @NL80211_CMD_FRAME_TX_STATUS: Report TX status of a management frame
+ *	transmitted with %NL80211_CMD_FRAME. %NL80211_ATTR_COOKIE identifies
+ *	the TX command and %NL80211_ATTR_FRAME includes the contents of the
+ *	frame. %NL80211_ATTR_ACK flag is included if the recipient acknowledged
+ *	the frame.
+ * @NL80211_CMD_ACTION_TX_STATUS: Alias for @NL80211_CMD_FRAME_TX_STATUS for
+ *	backward compatibility.
+ * @NL80211_CMD_SET_CQM: Connection quality monitor configuration. This command
+ *	is used to configure connection quality monitoring notification trigger
+ *	levels.
+ * @NL80211_CMD_NOTIFY_CQM: Connection quality monitor notification. This
+ *	command is used as an event to indicate the that a trigger level was
+ *	reached.
+ * @NL80211_CMD_SET_CHANNEL: Set the channel (using %NL80211_ATTR_WIPHY_FREQ
+ *	and %NL80211_ATTR_WIPHY_CHANNEL_TYPE) the given interface (identifed
+ *	by %NL80211_ATTR_IFINDEX) shall operate on.
+ *	In case multiple channels are supported by the device, the mechanism
+ *	with which it switches channels is implementation-defined.
+ *	When a monitor interface is given, it can only switch channel while
+ *	no other interfaces are operating to avoid disturbing the operation
+ *	of any other interfaces, and other interfaces will again take
+ *	precedence when they are used.
+ *
+ * @NL80211_CMD_SET_WDS_PEER: Set the MAC address of the peer on a WDS interface.
+ *
+ * @NL80211_CMD_JOIN_MESH: Join a mesh. The mesh ID must be given, and initial
+ *	mesh config parameters may be given.
+ * @NL80211_CMD_LEAVE_MESH: Leave the mesh network -- no special arguments, the
+ *	network is determined by the network interface.
+ *
+ * @NL80211_CMD_MAX: highest used command number
+ * @__NL80211_CMD_AFTER_LAST: internal use
+ */
+enum nl80211_commands {
+/* don't change the order or add anything inbetween, this is ABI! */
+	NL80211_CMD_UNSPEC,
+
+	NL80211_CMD_GET_WIPHY,		/* can dump */
+	NL80211_CMD_SET_WIPHY,
+	NL80211_CMD_NEW_WIPHY,
+	NL80211_CMD_DEL_WIPHY,
+
+	NL80211_CMD_GET_INTERFACE,	/* can dump */
+	NL80211_CMD_SET_INTERFACE,
+	NL80211_CMD_NEW_INTERFACE,
+	NL80211_CMD_DEL_INTERFACE,
+
+	NL80211_CMD_GET_KEY,
+	NL80211_CMD_SET_KEY,
+	NL80211_CMD_NEW_KEY,
+	NL80211_CMD_DEL_KEY,
+
+	NL80211_CMD_GET_BEACON,
+	NL80211_CMD_SET_BEACON,
+	NL80211_CMD_NEW_BEACON,
+	NL80211_CMD_DEL_BEACON,
+
+	NL80211_CMD_GET_STATION,
+	NL80211_CMD_SET_STATION,
+	NL80211_CMD_NEW_STATION,
+	NL80211_CMD_DEL_STATION,
+
+	NL80211_CMD_GET_MPATH,
+	NL80211_CMD_SET_MPATH,
+	NL80211_CMD_NEW_MPATH,
+	NL80211_CMD_DEL_MPATH,
+
+	NL80211_CMD_SET_BSS,
+
+	NL80211_CMD_SET_REG,
+	NL80211_CMD_REQ_SET_REG,
+
+	NL80211_CMD_GET_MESH_PARAMS,
+	NL80211_CMD_SET_MESH_PARAMS,
+
+	NL80211_CMD_SET_MGMT_EXTRA_IE /* reserved; not used */,
+
+	NL80211_CMD_GET_REG,
+
+	NL80211_CMD_GET_SCAN,
+	NL80211_CMD_TRIGGER_SCAN,
+	NL80211_CMD_NEW_SCAN_RESULTS,
+	NL80211_CMD_SCAN_ABORTED,
+
+	NL80211_CMD_REG_CHANGE,
+
+	NL80211_CMD_AUTHENTICATE,
+	NL80211_CMD_ASSOCIATE,
+	NL80211_CMD_DEAUTHENTICATE,
+	NL80211_CMD_DISASSOCIATE,
+
+	NL80211_CMD_MICHAEL_MIC_FAILURE,
+
+	NL80211_CMD_REG_BEACON_HINT,
+
+	NL80211_CMD_JOIN_IBSS,
+	NL80211_CMD_LEAVE_IBSS,
+
+	NL80211_CMD_TESTMODE,
+
+	NL80211_CMD_CONNECT,
+	NL80211_CMD_ROAM,
+	NL80211_CMD_DISCONNECT,
+
+	NL80211_CMD_SET_WIPHY_NETNS,
+
+	NL80211_CMD_GET_SURVEY,
+	NL80211_CMD_NEW_SURVEY_RESULTS,
+
+	NL80211_CMD_SET_PMKSA,
+	NL80211_CMD_DEL_PMKSA,
+	NL80211_CMD_FLUSH_PMKSA,
+
+	NL80211_CMD_REMAIN_ON_CHANNEL,
+	NL80211_CMD_CANCEL_REMAIN_ON_CHANNEL,
+
+	NL80211_CMD_SET_TX_BITRATE_MASK,
+
+	NL80211_CMD_REGISTER_FRAME,
+	NL80211_CMD_REGISTER_ACTION = NL80211_CMD_REGISTER_FRAME,
+	NL80211_CMD_FRAME,
+	NL80211_CMD_ACTION = NL80211_CMD_FRAME,
+	NL80211_CMD_FRAME_TX_STATUS,
+	NL80211_CMD_ACTION_TX_STATUS = NL80211_CMD_FRAME_TX_STATUS,
+
+	NL80211_CMD_SET_POWER_SAVE,
+	NL80211_CMD_GET_POWER_SAVE,
+
+	NL80211_CMD_SET_CQM,
+	NL80211_CMD_NOTIFY_CQM,
+
+	NL80211_CMD_SET_CHANNEL,
+	NL80211_CMD_SET_WDS_PEER,
+
+	NL80211_CMD_FRAME_WAIT_CANCEL,
+
+	NL80211_CMD_JOIN_MESH,
+	NL80211_CMD_LEAVE_MESH,
+
+	/* add new commands above here */
+
+	/* used to define NL80211_CMD_MAX below */
+	__NL80211_CMD_AFTER_LAST,
+	NL80211_CMD_MAX = __NL80211_CMD_AFTER_LAST - 1
+};
+
+/*
+ * Allow user space programs to use #ifdef on new commands by defining them
+ * here
+ */
+#define NL80211_CMD_SET_BSS NL80211_CMD_SET_BSS
+#define NL80211_CMD_SET_MGMT_EXTRA_IE NL80211_CMD_SET_MGMT_EXTRA_IE
+#define NL80211_CMD_REG_CHANGE NL80211_CMD_REG_CHANGE
+#define NL80211_CMD_AUTHENTICATE NL80211_CMD_AUTHENTICATE
+#define NL80211_CMD_ASSOCIATE NL80211_CMD_ASSOCIATE
+#define NL80211_CMD_DEAUTHENTICATE NL80211_CMD_DEAUTHENTICATE
+#define NL80211_CMD_DISASSOCIATE NL80211_CMD_DISASSOCIATE
+#define NL80211_CMD_REG_BEACON_HINT NL80211_CMD_REG_BEACON_HINT
+
+/**
+ * enum nl80211_attrs - nl80211 netlink attributes
+ *
+ * @NL80211_ATTR_UNSPEC: unspecified attribute to catch errors
+ *
+ * @NL80211_ATTR_WIPHY: index of wiphy to operate on, cf.
+ *	/sys/class/ieee80211/<phyname>/index
+ * @NL80211_ATTR_WIPHY_NAME: wiphy name (used for renaming)
+ * @NL80211_ATTR_WIPHY_TXQ_PARAMS: a nested array of TX queue parameters
+ * @NL80211_ATTR_WIPHY_FREQ: frequency of the selected channel in MHz
+ * @NL80211_ATTR_WIPHY_CHANNEL_TYPE: included with NL80211_ATTR_WIPHY_FREQ
+ *	if HT20 or HT40 are allowed (i.e., 802.11n disabled if not included):
+ *	NL80211_CHAN_NO_HT = HT not allowed (i.e., same as not including
+ *		this attribute)
+ *	NL80211_CHAN_HT20 = HT20 only
+ *	NL80211_CHAN_HT40MINUS = secondary channel is below the primary channel
+ *	NL80211_CHAN_HT40PLUS = secondary channel is above the primary channel
+ * @NL80211_ATTR_WIPHY_RETRY_SHORT: TX retry limit for frames whose length is
+ *	less than or equal to the RTS threshold; allowed range: 1..255;
+ *	dot11ShortRetryLimit; u8
+ * @NL80211_ATTR_WIPHY_RETRY_LONG: TX retry limit for frames whose length is
+ *	greater than the RTS threshold; allowed range: 1..255;
+ *	dot11ShortLongLimit; u8
+ * @NL80211_ATTR_WIPHY_FRAG_THRESHOLD: fragmentation threshold, i.e., maximum
+ *	length in octets for frames; allowed range: 256..8000, disable
+ *	fragmentation with (u32)-1; dot11FragmentationThreshold; u32
+ * @NL80211_ATTR_WIPHY_RTS_THRESHOLD: RTS threshold (TX frames with length
+ *	larger than or equal to this use RTS/CTS handshake); allowed range:
+ *	0..65536, disable with (u32)-1; dot11RTSThreshold; u32
+ * @NL80211_ATTR_WIPHY_COVERAGE_CLASS: Coverage Class as defined by IEEE 802.11
+ *	section 7.3.2.9; dot11CoverageClass; u8
+ *
+ * @NL80211_ATTR_IFINDEX: network interface index of the device to operate on
+ * @NL80211_ATTR_IFNAME: network interface name
+ * @NL80211_ATTR_IFTYPE: type of virtual interface, see &enum nl80211_iftype
+ *
+ * @NL80211_ATTR_MAC: MAC address (various uses)
+ *
+ * @NL80211_ATTR_KEY_DATA: (temporal) key data; for TKIP this consists of
+ *	16 bytes encryption key followed by 8 bytes each for TX and RX MIC
+ *	keys
+ * @NL80211_ATTR_KEY_IDX: key ID (u8, 0-3)
+ * @NL80211_ATTR_KEY_CIPHER: key cipher suite (u32, as defined by IEEE 802.11
+ *	section 7.3.2.25.1, e.g. 0x000FAC04)
+ * @NL80211_ATTR_KEY_SEQ: transmit key sequence number (IV/PN) for TKIP and
+ *	CCMP keys, each six bytes in little endian
+ *
+ * @NL80211_ATTR_BEACON_INTERVAL: beacon interval in TU
+ * @NL80211_ATTR_DTIM_PERIOD: DTIM period for beaconing
+ * @NL80211_ATTR_BEACON_HEAD: portion of the beacon before the TIM IE
+ * @NL80211_ATTR_BEACON_TAIL: portion of the beacon after the TIM IE
+ *
+ * @NL80211_ATTR_STA_AID: Association ID for the station (u16)
+ * @NL80211_ATTR_STA_FLAGS: flags, nested element with NLA_FLAG attributes of
+ *	&enum nl80211_sta_flags (deprecated, use %NL80211_ATTR_STA_FLAGS2)
+ * @NL80211_ATTR_STA_LISTEN_INTERVAL: listen interval as defined by
+ *	IEEE 802.11 7.3.1.6 (u16).
+ * @NL80211_ATTR_STA_SUPPORTED_RATES: supported rates, array of supported
+ *	rates as defined by IEEE 802.11 7.3.2.2 but without the length
+ *	restriction (at most %NL80211_MAX_SUPP_RATES).
+ * @NL80211_ATTR_STA_VLAN: interface index of VLAN interface to move station
+ *	to, or the AP interface the station was originally added to to.
+ * @NL80211_ATTR_STA_INFO: information about a station, part of station info
+ *	given for %NL80211_CMD_GET_STATION, nested attribute containing
+ *	info as possible, see &enum nl80211_sta_info.
+ *
+ * @NL80211_ATTR_WIPHY_BANDS: Information about an operating bands,
+ *	consisting of a nested array.
+ *
+ * @NL80211_ATTR_MESH_ID: mesh id (1-32 bytes).
+ * @NL80211_ATTR_PLINK_ACTION: action to perform on the mesh peer link.
+ * @NL80211_ATTR_MPATH_NEXT_HOP: MAC address of the next hop for a mesh path.
+ * @NL80211_ATTR_MPATH_INFO: information about a mesh_path, part of mesh path
+ * 	info given for %NL80211_CMD_GET_MPATH, nested attribute described at
+ *	&enum nl80211_mpath_info.
+ *
+ * @NL80211_ATTR_MNTR_FLAGS: flags, nested element with NLA_FLAG attributes of
+ *      &enum nl80211_mntr_flags.
+ *
+ * @NL80211_ATTR_REG_ALPHA2: an ISO-3166-alpha2 country code for which the
+ * 	current regulatory domain should be set to or is already set to.
+ * 	For example, 'CR', for Costa Rica. This attribute is used by the kernel
+ * 	to query the CRDA to retrieve one regulatory domain. This attribute can
+ * 	also be used by userspace to query the kernel for the currently set
+ * 	regulatory domain. We chose an alpha2 as that is also used by the
+ * 	IEEE-802.11d country information element to identify a country.
+ * 	Users can also simply ask the wireless core to set regulatory domain
+ * 	to a specific alpha2.
+ * @NL80211_ATTR_REG_RULES: a nested array of regulatory domain regulatory
+ *	rules.
+ *
+ * @NL80211_ATTR_BSS_CTS_PROT: whether CTS protection is enabled (u8, 0 or 1)
+ * @NL80211_ATTR_BSS_SHORT_PREAMBLE: whether short preamble is enabled
+ *	(u8, 0 or 1)
+ * @NL80211_ATTR_BSS_SHORT_SLOT_TIME: whether short slot time enabled
+ *	(u8, 0 or 1)
+ * @NL80211_ATTR_BSS_BASIC_RATES: basic rates, array of basic
+ *	rates in format defined by IEEE 802.11 7.3.2.2 but without the length
+ *	restriction (at most %NL80211_MAX_SUPP_RATES).
+ *
+ * @NL80211_ATTR_HT_CAPABILITY: HT Capability information element (from
+ *	association request when used with NL80211_CMD_NEW_STATION)
+ *
+ * @NL80211_ATTR_SUPPORTED_IFTYPES: nested attribute containing all
+ *	supported interface types, each a flag attribute with the number
+ *	of the interface mode.
+ *
+ * @NL80211_ATTR_MGMT_SUBTYPE: Management frame subtype for
+ *	%NL80211_CMD_SET_MGMT_EXTRA_IE.
+ *
+ * @NL80211_ATTR_IE: Information element(s) data (used, e.g., with
+ *	%NL80211_CMD_SET_MGMT_EXTRA_IE).
+ *
+ * @NL80211_ATTR_MAX_NUM_SCAN_SSIDS: number of SSIDs you can scan with
+ *	a single scan request, a wiphy attribute.
+ * @NL80211_ATTR_MAX_SCAN_IE_LEN: maximum length of information elements
+ *	that can be added to a scan request
+ *
+ * @NL80211_ATTR_SCAN_FREQUENCIES: nested attribute with frequencies (in MHz)
+ * @NL80211_ATTR_SCAN_SSIDS: nested attribute with SSIDs, leave out for passive
+ *	scanning and include a zero-length SSID (wildcard) for wildcard scan
+ * @NL80211_ATTR_BSS: scan result BSS
+ *
+ * @NL80211_ATTR_REG_INITIATOR: indicates who requested the regulatory domain
+ * 	currently in effect. This could be any of the %NL80211_REGDOM_SET_BY_*
+ * @NL80211_ATTR_REG_TYPE: indicates the type of the regulatory domain currently
+ * 	set. This can be one of the nl80211_reg_type (%NL80211_REGDOM_TYPE_*)
+ *
+ * @NL80211_ATTR_SUPPORTED_COMMANDS: wiphy attribute that specifies
+ *	an array of command numbers (i.e. a mapping index to command number)
+ *	that the driver for the given wiphy supports.
+ *
+ * @NL80211_ATTR_FRAME: frame data (binary attribute), including frame header
+ *	and body, but not FCS; used, e.g., with NL80211_CMD_AUTHENTICATE and
+ *	NL80211_CMD_ASSOCIATE events
+ * @NL80211_ATTR_SSID: SSID (binary attribute, 0..32 octets)
+ * @NL80211_ATTR_AUTH_TYPE: AuthenticationType, see &enum nl80211_auth_type,
+ *	represented as a u32
+ * @NL80211_ATTR_REASON_CODE: ReasonCode for %NL80211_CMD_DEAUTHENTICATE and
+ *	%NL80211_CMD_DISASSOCIATE, u16
+ *
+ * @NL80211_ATTR_KEY_TYPE: Key Type, see &enum nl80211_key_type, represented as
+ *	a u32
+ *
+ * @NL80211_ATTR_FREQ_BEFORE: A channel which has suffered a regulatory change
+ * 	due to considerations from a beacon hint. This attribute reflects
+ * 	the state of the channel _before_ the beacon hint processing. This
+ * 	attributes consists of a nested attribute containing
+ * 	NL80211_FREQUENCY_ATTR_*
+ * @NL80211_ATTR_FREQ_AFTER: A channel which has suffered a regulatory change
+ * 	due to considerations from a beacon hint. This attribute reflects
+ * 	the state of the channel _after_ the beacon hint processing. This
+ * 	attributes consists of a nested attribute containing
+ * 	NL80211_FREQUENCY_ATTR_*
+ *
+ * @NL80211_ATTR_CIPHER_SUITES: a set of u32 values indicating the supported
+ *	cipher suites
+ *
+ * @NL80211_ATTR_FREQ_FIXED: a flag indicating the IBSS should not try to look
+ *	for other networks on different channels
+ *
+ * @NL80211_ATTR_TIMED_OUT: a flag indicating than an operation timed out; this
+ *	is used, e.g., with %NL80211_CMD_AUTHENTICATE event
+ *
+ * @NL80211_ATTR_USE_MFP: Whether management frame protection (IEEE 802.11w) is
+ *	used for the association (&enum nl80211_mfp, represented as a u32);
+ *	this attribute can be used
+ *	with %NL80211_CMD_ASSOCIATE request
+ *
+ * @NL80211_ATTR_STA_FLAGS2: Attribute containing a
+ *	&struct nl80211_sta_flag_update.
+ *
+ * @NL80211_ATTR_CONTROL_PORT: A flag indicating whether user space controls
+ *	IEEE 802.1X port, i.e., sets/clears %NL80211_STA_FLAG_AUTHORIZED, in
+ *	station mode. If the flag is included in %NL80211_CMD_ASSOCIATE
+ *	request, the driver will assume that the port is unauthorized until
+ *	authorized by user space. Otherwise, port is marked authorized by
+ *	default in station mode.
+ * @NL80211_ATTR_CONTROL_PORT_ETHERTYPE: A 16-bit value indicating the
+ *	ethertype that will be used for key negotiation. It can be
+ *	specified with the associate and connect commands. If it is not
+ *	specified, the value defaults to 0x888E (PAE, 802.1X). This
+ *	attribute is also used as a flag in the wiphy information to
+ *	indicate that protocols other than PAE are supported.
+ * @NL80211_ATTR_CONTROL_PORT_NO_ENCRYPT: When included along with
+ *	%NL80211_ATTR_CONTROL_PORT_ETHERTYPE, indicates that the custom
+ *	ethertype frames used for key negotiation must not be encrypted.
+ *
+ * @NL80211_ATTR_TESTDATA: Testmode data blob, passed through to the driver.
+ *	We recommend using nested, driver-specific attributes within this.
+ *
+ * @NL80211_ATTR_DISCONNECTED_BY_AP: A flag indicating that the DISCONNECT
+ *	event was due to the AP disconnecting the station, and not due to
+ *	a local disconnect request.
+ * @NL80211_ATTR_STATUS_CODE: StatusCode for the %NL80211_CMD_CONNECT
+ *	event (u16)
+ * @NL80211_ATTR_PRIVACY: Flag attribute, used with connect(), indicating
+ *	that protected APs should be used.
+ *
+ * @NL80211_ATTR_CIPHERS_PAIRWISE: Used with CONNECT and ASSOCIATE to
+ *	indicate which unicast key ciphers will be used with the connection
+ *	(an array of u32).
+ * @NL80211_ATTR_CIPHER_GROUP: Used with CONNECT and ASSOCIATE to indicate
+ *	which group key cipher will be used with the connection (a u32).
+ * @NL80211_ATTR_WPA_VERSIONS: Used with CONNECT and ASSOCIATE to indicate
+ *	which WPA version(s) the AP we want to associate with is using
+ *	(a u32 with flags from &enum nl80211_wpa_versions).
+ * @NL80211_ATTR_AKM_SUITES: Used with CONNECT and ASSOCIATE to indicate
+ *	which key management algorithm(s) to use (an array of u32).
+ *
+ * @NL80211_ATTR_REQ_IE: (Re)association request information elements as
+ *	sent out by the card, for ROAM and successful CONNECT events.
+ * @NL80211_ATTR_RESP_IE: (Re)association response information elements as
+ *	sent by peer, for ROAM and successful CONNECT events.
+ *
+ * @NL80211_ATTR_PREV_BSSID: previous BSSID, to be used by in ASSOCIATE
+ *	commands to specify using a reassociate frame
+ *
+ * @NL80211_ATTR_KEY: key information in a nested attribute with
+ *	%NL80211_KEY_* sub-attributes
+ * @NL80211_ATTR_KEYS: array of keys for static WEP keys for connect()
+ *	and join_ibss(), key information is in a nested attribute each
+ *	with %NL80211_KEY_* sub-attributes
+ *
+ * @NL80211_ATTR_PID: Process ID of a network namespace.
+ *
+ * @NL80211_ATTR_GENERATION: Used to indicate consistent snapshots for
+ *	dumps. This number increases whenever the object list being
+ *	dumped changes, and as such userspace can verify that it has
+ *	obtained a complete and consistent snapshot by verifying that
+ *	all dump messages contain the same generation number. If it
+ *	changed then the list changed and the dump should be repeated
+ *	completely from scratch.
+ *
+ * @NL80211_ATTR_4ADDR: Use 4-address frames on a virtual interface
+ *
+ * @NL80211_ATTR_SURVEY_INFO: survey information about a channel, part of
+ *      the survey response for %NL80211_CMD_GET_SURVEY, nested attribute
+ *      containing info as possible, see &enum survey_info.
+ *
+ * @NL80211_ATTR_PMKID: PMK material for PMKSA caching.
+ * @NL80211_ATTR_MAX_NUM_PMKIDS: maximum number of PMKIDs a firmware can
+ *	cache, a wiphy attribute.
+ *
+ * @NL80211_ATTR_DURATION: Duration of an operation in milliseconds, u32.
+ *
+ * @NL80211_ATTR_COOKIE: Generic 64-bit cookie to identify objects.
+ *
+ * @NL80211_ATTR_TX_RATES: Nested set of attributes
+ *	(enum nl80211_tx_rate_attributes) describing TX rates per band. The
+ *	enum nl80211_band value is used as the index (nla_type() of the nested
+ *	data. If a band is not included, it will be configured to allow all
+ *	rates based on negotiated supported rates information. This attribute
+ *	is used with %NL80211_CMD_SET_TX_BITRATE_MASK.
+ *
+ * @NL80211_ATTR_FRAME_MATCH: A binary attribute which typically must contain
+ *	at least one byte, currently used with @NL80211_CMD_REGISTER_FRAME.
+ * @NL80211_ATTR_FRAME_TYPE: A u16 indicating the frame type/subtype for the
+ *	@NL80211_CMD_REGISTER_FRAME command.
+ * @NL80211_ATTR_TX_FRAME_TYPES: wiphy capability attribute, which is a
+ *	nested attribute of %NL80211_ATTR_FRAME_TYPE attributes, containing
+ *	information about which frame types can be transmitted with
+ *	%NL80211_CMD_FRAME.
+ * @NL80211_ATTR_RX_FRAME_TYPES: wiphy capability attribute, which is a
+ *	nested attribute of %NL80211_ATTR_FRAME_TYPE attributes, containing
+ *	information about which frame types can be registered for RX.
+ *
+ * @NL80211_ATTR_ACK: Flag attribute indicating that the frame was
+ *	acknowledged by the recipient.
+ *
+ * @NL80211_ATTR_CQM: connection quality monitor configuration in a
+ *	nested attribute with %NL80211_ATTR_CQM_* sub-attributes.
+ *
+ * @NL80211_ATTR_LOCAL_STATE_CHANGE: Flag attribute to indicate that a command
+ *	is requesting a local authentication/association state change without
+ *	invoking actual management frame exchange. This can be used with
+ *	NL80211_CMD_AUTHENTICATE, NL80211_CMD_DEAUTHENTICATE,
+ *	NL80211_CMD_DISASSOCIATE.
+ *
+ * @NL80211_ATTR_AP_ISOLATE: (AP mode) Do not forward traffic between stations
+ *	connected to this BSS.
+ *
+ * @NL80211_ATTR_WIPHY_TX_POWER_SETTING: Transmit power setting type. See
+ *      &enum nl80211_tx_power_setting for possible values.
+ * @NL80211_ATTR_WIPHY_TX_POWER_LEVEL: Transmit power level in signed mBm units.
+ *      This is used in association with @NL80211_ATTR_WIPHY_TX_POWER_SETTING
+ *      for non-automatic settings.
+ *
+ * @NL80211_ATTR_SUPPORT_IBSS_RSN: The device supports IBSS RSN, which mostly
+ *	means support for per-station GTKs.
+ *
+ * @NL80211_ATTR_WIPHY_ANTENNA_TX: Bitmap of allowed antennas for transmitting.
+ *	This can be used to mask out antennas which are not attached or should
+ *	not be used for transmitting. If an antenna is not selected in this
+ *	bitmap the hardware is not allowed to transmit on this antenna.
+ *
+ *	Each bit represents one antenna, starting with antenna 1 at the first
+ *	bit. Depending on which antennas are selected in the bitmap, 802.11n
+ *	drivers can derive which chainmasks to use (if all antennas belonging to
+ *	a particular chain are disabled this chain should be disabled) and if
+ *	a chain has diversity antennas wether diversity should be used or not.
+ *	HT capabilities (STBC, TX Beamforming, Antenna selection) can be
+ *	derived from the available chains after applying the antenna mask.
+ *	Non-802.11n drivers can derive wether to use diversity or not.
+ *	Drivers may reject configurations or RX/TX mask combinations they cannot
+ *	support by returning -EINVAL.
+ *
+ * @NL80211_ATTR_WIPHY_ANTENNA_RX: Bitmap of allowed antennas for receiving.
+ *	This can be used to mask out antennas which are not attached or should
+ *	not be used for receiving. If an antenna is not selected in this bitmap
+ *	the hardware should not be configured to receive on this antenna.
+ *	For a more detailed descripton see @NL80211_ATTR_WIPHY_ANTENNA_TX.
+ *
+ * @NL80211_ATTR_MCAST_RATE: Multicast tx rate (in 100 kbps) for IBSS
+ *
+ * @NL80211_ATTR_OFFCHANNEL_TX_OK: For management frame TX, the frame may be
+ *	transmitted on another channel when the channel given doesn't match
+ *	the current channel. If the current channel doesn't match and this
+ *	flag isn't set, the frame will be rejected. This is also used as an
+ *	nl80211 capability flag.
+ *
+ * @NL80211_ATTR_BSS_HTOPMODE: HT operation mode (u16)
+ *
+ * @NL80211_ATTR_MAX: highest attribute number currently defined
+ * @__NL80211_ATTR_AFTER_LAST: internal use
+ */
+enum nl80211_attrs {
+/* don't change the order or add anything inbetween, this is ABI! */
+	NL80211_ATTR_UNSPEC,
+
+	NL80211_ATTR_WIPHY,
+	NL80211_ATTR_WIPHY_NAME,
+
+	NL80211_ATTR_IFINDEX,
+	NL80211_ATTR_IFNAME,
+	NL80211_ATTR_IFTYPE,
+
+	NL80211_ATTR_MAC,
+
+	NL80211_ATTR_KEY_DATA,
+	NL80211_ATTR_KEY_IDX,
+	NL80211_ATTR_KEY_CIPHER,
+	NL80211_ATTR_KEY_SEQ,
+	NL80211_ATTR_KEY_DEFAULT,
+
+	NL80211_ATTR_BEACON_INTERVAL,
+	NL80211_ATTR_DTIM_PERIOD,
+	NL80211_ATTR_BEACON_HEAD,
+	NL80211_ATTR_BEACON_TAIL,
+
+	NL80211_ATTR_STA_AID,
+	NL80211_ATTR_STA_FLAGS,
+	NL80211_ATTR_STA_LISTEN_INTERVAL,
+	NL80211_ATTR_STA_SUPPORTED_RATES,
+	NL80211_ATTR_STA_VLAN,
+	NL80211_ATTR_STA_INFO,
+
+	NL80211_ATTR_WIPHY_BANDS,
+
+	NL80211_ATTR_MNTR_FLAGS,
+
+	NL80211_ATTR_MESH_ID,
+	NL80211_ATTR_STA_PLINK_ACTION,
+	NL80211_ATTR_MPATH_NEXT_HOP,
+	NL80211_ATTR_MPATH_INFO,
+
+	NL80211_ATTR_BSS_CTS_PROT,
+	NL80211_ATTR_BSS_SHORT_PREAMBLE,
+	NL80211_ATTR_BSS_SHORT_SLOT_TIME,
+
+	NL80211_ATTR_HT_CAPABILITY,
+
+	NL80211_ATTR_SUPPORTED_IFTYPES,
+
+	NL80211_ATTR_REG_ALPHA2,
+	NL80211_ATTR_REG_RULES,
+
+	NL80211_ATTR_MESH_PARAMS,
+
+	NL80211_ATTR_BSS_BASIC_RATES,
+
+	NL80211_ATTR_WIPHY_TXQ_PARAMS,
+	NL80211_ATTR_WIPHY_FREQ,
+	NL80211_ATTR_WIPHY_CHANNEL_TYPE,
+
+	NL80211_ATTR_KEY_DEFAULT_MGMT,
+
+	NL80211_ATTR_MGMT_SUBTYPE,
+	NL80211_ATTR_IE,
+
+	NL80211_ATTR_MAX_NUM_SCAN_SSIDS,
+
+	NL80211_ATTR_SCAN_FREQUENCIES,
+	NL80211_ATTR_SCAN_SSIDS,
+	NL80211_ATTR_GENERATION, /* replaces old SCAN_GENERATION */
+	NL80211_ATTR_BSS,
+
+	NL80211_ATTR_REG_INITIATOR,
+	NL80211_ATTR_REG_TYPE,
+
+	NL80211_ATTR_SUPPORTED_COMMANDS,
+
+	NL80211_ATTR_FRAME,
+	NL80211_ATTR_SSID,
+	NL80211_ATTR_AUTH_TYPE,
+	NL80211_ATTR_REASON_CODE,
+
+	NL80211_ATTR_KEY_TYPE,
+
+	NL80211_ATTR_MAX_SCAN_IE_LEN,
+	NL80211_ATTR_CIPHER_SUITES,
+
+	NL80211_ATTR_FREQ_BEFORE,
+	NL80211_ATTR_FREQ_AFTER,
+
+	NL80211_ATTR_FREQ_FIXED,
+
+
+	NL80211_ATTR_WIPHY_RETRY_SHORT,
+	NL80211_ATTR_WIPHY_RETRY_LONG,
+	NL80211_ATTR_WIPHY_FRAG_THRESHOLD,
+	NL80211_ATTR_WIPHY_RTS_THRESHOLD,
+
+	NL80211_ATTR_TIMED_OUT,
+
+	NL80211_ATTR_USE_MFP,
+
+	NL80211_ATTR_STA_FLAGS2,
+
+	NL80211_ATTR_CONTROL_PORT,
+
+	NL80211_ATTR_TESTDATA,
+
+	NL80211_ATTR_PRIVACY,
+
+	NL80211_ATTR_DISCONNECTED_BY_AP,
+	NL80211_ATTR_STATUS_CODE,
+
+	NL80211_ATTR_CIPHER_SUITES_PAIRWISE,
+	NL80211_ATTR_CIPHER_SUITE_GROUP,
+	NL80211_ATTR_WPA_VERSIONS,
+	NL80211_ATTR_AKM_SUITES,
+
+	NL80211_ATTR_REQ_IE,
+	NL80211_ATTR_RESP_IE,
+
+	NL80211_ATTR_PREV_BSSID,
+
+	NL80211_ATTR_KEY,
+	NL80211_ATTR_KEYS,
+
+	NL80211_ATTR_PID,
+
+	NL80211_ATTR_4ADDR,
+
+	NL80211_ATTR_SURVEY_INFO,
+
+	NL80211_ATTR_PMKID,
+	NL80211_ATTR_MAX_NUM_PMKIDS,
+
+	NL80211_ATTR_DURATION,
+
+	NL80211_ATTR_COOKIE,
+
+	NL80211_ATTR_WIPHY_COVERAGE_CLASS,
+
+	NL80211_ATTR_TX_RATES,
+
+	NL80211_ATTR_FRAME_MATCH,
+
+	NL80211_ATTR_ACK,
+
+	NL80211_ATTR_PS_STATE,
+
+	NL80211_ATTR_CQM,
+
+	NL80211_ATTR_LOCAL_STATE_CHANGE,
+
+	NL80211_ATTR_AP_ISOLATE,
+
+	NL80211_ATTR_WIPHY_TX_POWER_SETTING,
+	NL80211_ATTR_WIPHY_TX_POWER_LEVEL,
+
+	NL80211_ATTR_TX_FRAME_TYPES,
+	NL80211_ATTR_RX_FRAME_TYPES,
+	NL80211_ATTR_FRAME_TYPE,
+
+	NL80211_ATTR_CONTROL_PORT_ETHERTYPE,
+	NL80211_ATTR_CONTROL_PORT_NO_ENCRYPT,
+
+	NL80211_ATTR_SUPPORT_IBSS_RSN,
+
+	NL80211_ATTR_WIPHY_ANTENNA_TX,
+	NL80211_ATTR_WIPHY_ANTENNA_RX,
+
+	NL80211_ATTR_MCAST_RATE,
+
+	NL80211_ATTR_OFFCHANNEL_TX_OK,
+
+	NL80211_ATTR_BSS_HT_OPMODE,
+
+	/* add attributes here, update the policy in nl80211.c */
+
+	__NL80211_ATTR_AFTER_LAST,
+	NL80211_ATTR_MAX = __NL80211_ATTR_AFTER_LAST - 1
+};
+
+/* source-level API compatibility */
+#define NL80211_ATTR_SCAN_GENERATION NL80211_ATTR_GENERATION
+
+/*
+ * Allow user space programs to use #ifdef on new attributes by defining them
+ * here
+ */
+#define NL80211_CMD_CONNECT NL80211_CMD_CONNECT
+#define NL80211_ATTR_HT_CAPABILITY NL80211_ATTR_HT_CAPABILITY
+#define NL80211_ATTR_BSS_BASIC_RATES NL80211_ATTR_BSS_BASIC_RATES
+#define NL80211_ATTR_WIPHY_TXQ_PARAMS NL80211_ATTR_WIPHY_TXQ_PARAMS
+#define NL80211_ATTR_WIPHY_FREQ NL80211_ATTR_WIPHY_FREQ
+#define NL80211_ATTR_WIPHY_CHANNEL_TYPE NL80211_ATTR_WIPHY_CHANNEL_TYPE
+#define NL80211_ATTR_MGMT_SUBTYPE NL80211_ATTR_MGMT_SUBTYPE
+#define NL80211_ATTR_IE NL80211_ATTR_IE
+#define NL80211_ATTR_REG_INITIATOR NL80211_ATTR_REG_INITIATOR
+#define NL80211_ATTR_REG_TYPE NL80211_ATTR_REG_TYPE
+#define NL80211_ATTR_FRAME NL80211_ATTR_FRAME
+#define NL80211_ATTR_SSID NL80211_ATTR_SSID
+#define NL80211_ATTR_AUTH_TYPE NL80211_ATTR_AUTH_TYPE
+#define NL80211_ATTR_REASON_CODE NL80211_ATTR_REASON_CODE
+#define NL80211_ATTR_CIPHER_SUITES_PAIRWISE NL80211_ATTR_CIPHER_SUITES_PAIRWISE
+#define NL80211_ATTR_CIPHER_SUITE_GROUP NL80211_ATTR_CIPHER_SUITE_GROUP
+#define NL80211_ATTR_WPA_VERSIONS NL80211_ATTR_WPA_VERSIONS
+#define NL80211_ATTR_AKM_SUITES NL80211_ATTR_AKM_SUITES
+#define NL80211_ATTR_KEY NL80211_ATTR_KEY
+#define NL80211_ATTR_KEYS NL80211_ATTR_KEYS
+
+#define NL80211_MAX_SUPP_RATES			32
+#define NL80211_MAX_SUPP_REG_RULES		32
+#define NL80211_TKIP_DATA_OFFSET_ENCR_KEY	0
+#define NL80211_TKIP_DATA_OFFSET_TX_MIC_KEY	16
+#define NL80211_TKIP_DATA_OFFSET_RX_MIC_KEY	24
+#define NL80211_HT_CAPABILITY_LEN		26
+
+#define NL80211_MAX_NR_CIPHER_SUITES		5
+#define NL80211_MAX_NR_AKM_SUITES		2
+
+/**
+ * enum nl80211_iftype - (virtual) interface types
+ *
+ * @NL80211_IFTYPE_UNSPECIFIED: unspecified type, driver decides
+ * @NL80211_IFTYPE_ADHOC: independent BSS member
+ * @NL80211_IFTYPE_STATION: managed BSS member
+ * @NL80211_IFTYPE_AP: access point
+ * @NL80211_IFTYPE_AP_VLAN: VLAN interface for access points
+ * @NL80211_IFTYPE_WDS: wireless distribution interface
+ * @NL80211_IFTYPE_MONITOR: monitor interface receiving all frames
+ * @NL80211_IFTYPE_MESH_POINT: mesh point
+ * @NL80211_IFTYPE_P2P_CLIENT: P2P client
+ * @NL80211_IFTYPE_P2P_GO: P2P group owner
+ * @NL80211_IFTYPE_MAX: highest interface type number currently defined
+ * @NUM_NL80211_IFTYPES: number of defined interface types
+ *
+ * These values are used with the %NL80211_ATTR_IFTYPE
+ * to set the type of an interface.
+ *
+ */
+enum nl80211_iftype {
+	NL80211_IFTYPE_UNSPECIFIED,
+	NL80211_IFTYPE_ADHOC,
+	NL80211_IFTYPE_STATION,
+	NL80211_IFTYPE_AP,
+	NL80211_IFTYPE_AP_VLAN,
+	NL80211_IFTYPE_WDS,
+	NL80211_IFTYPE_MONITOR,
+	NL80211_IFTYPE_MESH_POINT,
+	NL80211_IFTYPE_P2P_CLIENT,
+	NL80211_IFTYPE_P2P_GO,
+
+	/* keep last */
+	NUM_NL80211_IFTYPES,
+	NL80211_IFTYPE_MAX = NUM_NL80211_IFTYPES - 1
+};
+
+/**
+ * enum nl80211_sta_flags - station flags
+ *
+ * Station flags. When a station is added to an AP interface, it is
+ * assumed to be already associated (and hence authenticated.)
+ *
+ * @__NL80211_STA_FLAG_INVALID: attribute number 0 is reserved
+ * @NL80211_STA_FLAG_AUTHORIZED: station is authorized (802.1X)
+ * @NL80211_STA_FLAG_SHORT_PREAMBLE: station is capable of receiving frames
+ *	with short barker preamble
+ * @NL80211_STA_FLAG_WME: station is WME/QoS capable
+ * @NL80211_STA_FLAG_MFP: station uses management frame protection
+ * @NL80211_STA_FLAG_MAX: highest station flag number currently defined
+ * @__NL80211_STA_FLAG_AFTER_LAST: internal use
+ */
+enum nl80211_sta_flags {
+	__NL80211_STA_FLAG_INVALID,
+	NL80211_STA_FLAG_AUTHORIZED,
+	NL80211_STA_FLAG_SHORT_PREAMBLE,
+	NL80211_STA_FLAG_WME,
+	NL80211_STA_FLAG_MFP,
+
+	/* keep last */
+	__NL80211_STA_FLAG_AFTER_LAST,
+	NL80211_STA_FLAG_MAX = __NL80211_STA_FLAG_AFTER_LAST - 1
+};
+
+/**
+ * struct nl80211_sta_flag_update - station flags mask/set
+ * @mask: mask of station flags to set
+ * @set: which values to set them to
+ *
+ * Both mask and set contain bits as per &enum nl80211_sta_flags.
+ */
+struct nl80211_sta_flag_update {
+	__u32 mask;
+	__u32 set;
+} __attribute__((packed));
+
+/**
+ * enum nl80211_rate_info - bitrate information
+ *
+ * These attribute types are used with %NL80211_STA_INFO_TXRATE
+ * when getting information about the bitrate of a station.
+ *
+ * @__NL80211_RATE_INFO_INVALID: attribute number 0 is reserved
+ * @NL80211_RATE_INFO_BITRATE: total bitrate (u16, 100kbit/s)
+ * @NL80211_RATE_INFO_MCS: mcs index for 802.11n (u8)
+ * @NL80211_RATE_INFO_40_MHZ_WIDTH: 40 Mhz dualchannel bitrate
+ * @NL80211_RATE_INFO_SHORT_GI: 400ns guard interval
+ * @NL80211_RATE_INFO_MAX: highest rate_info number currently defined
+ * @__NL80211_RATE_INFO_AFTER_LAST: internal use
+ */
+enum nl80211_rate_info {
+	__NL80211_RATE_INFO_INVALID,
+	NL80211_RATE_INFO_BITRATE,
+	NL80211_RATE_INFO_MCS,
+	NL80211_RATE_INFO_40_MHZ_WIDTH,
+	NL80211_RATE_INFO_SHORT_GI,
+
+	/* keep last */
+	__NL80211_RATE_INFO_AFTER_LAST,
+	NL80211_RATE_INFO_MAX = __NL80211_RATE_INFO_AFTER_LAST - 1
+};
+
+/**
+ * enum nl80211_sta_info - station information
+ *
+ * These attribute types are used with %NL80211_ATTR_STA_INFO
+ * when getting information about a station.
+ *
+ * @__NL80211_STA_INFO_INVALID: attribute number 0 is reserved
+ * @NL80211_STA_INFO_INACTIVE_TIME: time since last activity (u32, msecs)
+ * @NL80211_STA_INFO_RX_BYTES: total received bytes (u32, from this station)
+ * @NL80211_STA_INFO_TX_BYTES: total transmitted bytes (u32, to this station)
+ * @__NL80211_STA_INFO_AFTER_LAST: internal
+ * @NL80211_STA_INFO_MAX: highest possible station info attribute
+ * @NL80211_STA_INFO_SIGNAL: signal strength of last received PPDU (u8, dBm)
+ * @NL80211_STA_INFO_TX_BITRATE: current unicast tx rate, nested attribute
+ * 	containing info as possible, see &enum nl80211_sta_info_txrate.
+ * @NL80211_STA_INFO_RX_PACKETS: total received packet (u32, from this station)
+ * @NL80211_STA_INFO_TX_PACKETS: total transmitted packets (u32, to this
+ *	station)
+ * @NL80211_STA_INFO_TX_RETRIES: total retries (u32, to this station)
+ * @NL80211_STA_INFO_TX_FAILED: total failed packets (u32, to this station)
+ * @NL80211_STA_INFO_SIGNAL_AVG: signal strength average (u8, dBm)
+ */
+enum nl80211_sta_info {
+	__NL80211_STA_INFO_INVALID,
+	NL80211_STA_INFO_INACTIVE_TIME,
+	NL80211_STA_INFO_RX_BYTES,
+	NL80211_STA_INFO_TX_BYTES,
+	NL80211_STA_INFO_LLID,
+	NL80211_STA_INFO_PLID,
+	NL80211_STA_INFO_PLINK_STATE,
+	NL80211_STA_INFO_SIGNAL,
+	NL80211_STA_INFO_TX_BITRATE,
+	NL80211_STA_INFO_RX_PACKETS,
+	NL80211_STA_INFO_TX_PACKETS,
+	NL80211_STA_INFO_TX_RETRIES,
+	NL80211_STA_INFO_TX_FAILED,
+	NL80211_STA_INFO_SIGNAL_AVG,
+
+	/* keep last */
+	__NL80211_STA_INFO_AFTER_LAST,
+	NL80211_STA_INFO_MAX = __NL80211_STA_INFO_AFTER_LAST - 1
+};
+
+/**
+ * enum nl80211_mpath_flags - nl80211 mesh path flags
+ *
+ * @NL80211_MPATH_FLAG_ACTIVE: the mesh path is active
+ * @NL80211_MPATH_FLAG_RESOLVING: the mesh path discovery process is running
+ * @NL80211_MPATH_FLAG_SN_VALID: the mesh path contains a valid SN
+ * @NL80211_MPATH_FLAG_FIXED: the mesh path has been manually set
+ * @NL80211_MPATH_FLAG_RESOLVED: the mesh path discovery process succeeded
+ */
+enum nl80211_mpath_flags {
+	NL80211_MPATH_FLAG_ACTIVE =	1<<0,
+	NL80211_MPATH_FLAG_RESOLVING =	1<<1,
+	NL80211_MPATH_FLAG_SN_VALID =	1<<2,
+	NL80211_MPATH_FLAG_FIXED =	1<<3,
+	NL80211_MPATH_FLAG_RESOLVED =	1<<4,
+};
+
+/**
+ * enum nl80211_mpath_info - mesh path information
+ *
+ * These attribute types are used with %NL80211_ATTR_MPATH_INFO when getting
+ * information about a mesh path.
+ *
+ * @__NL80211_MPATH_INFO_INVALID: attribute number 0 is reserved
+ * @NL80211_MPATH_INFO_FRAME_QLEN: number of queued frames for this destination
+ * @NL80211_MPATH_INFO_SN: destination sequence number
+ * @NL80211_MPATH_INFO_METRIC: metric (cost) of this mesh path
+ * @NL80211_MPATH_INFO_EXPTIME: expiration time for the path, in msec from now
+ * @NL80211_MPATH_INFO_FLAGS: mesh path flags, enumerated in
+ * 	&enum nl80211_mpath_flags;
+ * @NL80211_MPATH_INFO_DISCOVERY_TIMEOUT: total path discovery timeout, in msec
+ * @NL80211_MPATH_INFO_DISCOVERY_RETRIES: mesh path discovery retries
+ * @NL80211_MPATH_INFO_MAX: highest mesh path information attribute number
+ *	currently defind
+ * @__NL80211_MPATH_INFO_AFTER_LAST: internal use
+ */
+enum nl80211_mpath_info {
+	__NL80211_MPATH_INFO_INVALID,
+	NL80211_MPATH_INFO_FRAME_QLEN,
+	NL80211_MPATH_INFO_SN,
+	NL80211_MPATH_INFO_METRIC,
+	NL80211_MPATH_INFO_EXPTIME,
+	NL80211_MPATH_INFO_FLAGS,
+	NL80211_MPATH_INFO_DISCOVERY_TIMEOUT,
+	NL80211_MPATH_INFO_DISCOVERY_RETRIES,
+
+	/* keep last */
+	__NL80211_MPATH_INFO_AFTER_LAST,
+	NL80211_MPATH_INFO_MAX = __NL80211_MPATH_INFO_AFTER_LAST - 1
+};
+
+/**
+ * enum nl80211_band_attr - band attributes
+ * @__NL80211_BAND_ATTR_INVALID: attribute number 0 is reserved
+ * @NL80211_BAND_ATTR_FREQS: supported frequencies in this band,
+ *	an array of nested frequency attributes
+ * @NL80211_BAND_ATTR_RATES: supported bitrates in this band,
+ *	an array of nested bitrate attributes
+ * @NL80211_BAND_ATTR_HT_MCS_SET: 16-byte attribute containing the MCS set as
+ *	defined in 802.11n
+ * @NL80211_BAND_ATTR_HT_CAPA: HT capabilities, as in the HT information IE
+ * @NL80211_BAND_ATTR_HT_AMPDU_FACTOR: A-MPDU factor, as in 11n
+ * @NL80211_BAND_ATTR_HT_AMPDU_DENSITY: A-MPDU density, as in 11n
+ * @NL80211_BAND_ATTR_MAX: highest band attribute currently defined
+ * @__NL80211_BAND_ATTR_AFTER_LAST: internal use
+ */
+enum nl80211_band_attr {
+	__NL80211_BAND_ATTR_INVALID,
+	NL80211_BAND_ATTR_FREQS,
+	NL80211_BAND_ATTR_RATES,
+
+	NL80211_BAND_ATTR_HT_MCS_SET,
+	NL80211_BAND_ATTR_HT_CAPA,
+	NL80211_BAND_ATTR_HT_AMPDU_FACTOR,
+	NL80211_BAND_ATTR_HT_AMPDU_DENSITY,
+
+	/* keep last */
+	__NL80211_BAND_ATTR_AFTER_LAST,
+	NL80211_BAND_ATTR_MAX = __NL80211_BAND_ATTR_AFTER_LAST - 1
+};
+
+#define NL80211_BAND_ATTR_HT_CAPA NL80211_BAND_ATTR_HT_CAPA
+
+/**
+ * enum nl80211_frequency_attr - frequency attributes
+ * @__NL80211_FREQUENCY_ATTR_INVALID: attribute number 0 is reserved
+ * @NL80211_FREQUENCY_ATTR_FREQ: Frequency in MHz
+ * @NL80211_FREQUENCY_ATTR_DISABLED: Channel is disabled in current
+ *	regulatory domain.
+ * @NL80211_FREQUENCY_ATTR_PASSIVE_SCAN: Only passive scanning is
+ *	permitted on this channel in current regulatory domain.
+ * @NL80211_FREQUENCY_ATTR_NO_IBSS: IBSS networks are not permitted
+ *	on this channel in current regulatory domain.
+ * @NL80211_FREQUENCY_ATTR_RADAR: Radar detection is mandatory
+ *	on this channel in current regulatory domain.
+ * @NL80211_FREQUENCY_ATTR_MAX_TX_POWER: Maximum transmission power in mBm
+ *	(100 * dBm).
+ * @NL80211_FREQUENCY_ATTR_MAX: highest frequency attribute number
+ *	currently defined
+ * @__NL80211_FREQUENCY_ATTR_AFTER_LAST: internal use
+ */
+enum nl80211_frequency_attr {
+	__NL80211_FREQUENCY_ATTR_INVALID,
+	NL80211_FREQUENCY_ATTR_FREQ,
+	NL80211_FREQUENCY_ATTR_DISABLED,
+	NL80211_FREQUENCY_ATTR_PASSIVE_SCAN,
+	NL80211_FREQUENCY_ATTR_NO_IBSS,
+	NL80211_FREQUENCY_ATTR_RADAR,
+	NL80211_FREQUENCY_ATTR_MAX_TX_POWER,
+
+	/* keep last */
+	__NL80211_FREQUENCY_ATTR_AFTER_LAST,
+	NL80211_FREQUENCY_ATTR_MAX = __NL80211_FREQUENCY_ATTR_AFTER_LAST - 1
+};
+
+#define NL80211_FREQUENCY_ATTR_MAX_TX_POWER NL80211_FREQUENCY_ATTR_MAX_TX_POWER
+
+/**
+ * enum nl80211_bitrate_attr - bitrate attributes
+ * @__NL80211_BITRATE_ATTR_INVALID: attribute number 0 is reserved
+ * @NL80211_BITRATE_ATTR_RATE: Bitrate in units of 100 kbps
+ * @NL80211_BITRATE_ATTR_2GHZ_SHORTPREAMBLE: Short preamble supported
+ *	in 2.4 GHz band.
+ * @NL80211_BITRATE_ATTR_MAX: highest bitrate attribute number
+ *	currently defined
+ * @__NL80211_BITRATE_ATTR_AFTER_LAST: internal use
+ */
+enum nl80211_bitrate_attr {
+	__NL80211_BITRATE_ATTR_INVALID,
+	NL80211_BITRATE_ATTR_RATE,
+	NL80211_BITRATE_ATTR_2GHZ_SHORTPREAMBLE,
+
+	/* keep last */
+	__NL80211_BITRATE_ATTR_AFTER_LAST,
+	NL80211_BITRATE_ATTR_MAX = __NL80211_BITRATE_ATTR_AFTER_LAST - 1
+};
+
+/**
+ * enum nl80211_initiator - Indicates the initiator of a reg domain request
+ * @NL80211_REGDOM_SET_BY_CORE: Core queried CRDA for a dynamic world
+ * 	regulatory domain.
+ * @NL80211_REGDOM_SET_BY_USER: User asked the wireless core to set the
+ * 	regulatory domain.
+ * @NL80211_REGDOM_SET_BY_DRIVER: a wireless drivers has hinted to the
+ * 	wireless core it thinks its knows the regulatory domain we should be in.
+ * @NL80211_REGDOM_SET_BY_COUNTRY_IE: the wireless core has received an
+ * 	802.11 country information element with regulatory information it
+ * 	thinks we should consider. cfg80211 only processes the country
+ *	code from the IE, and relies on the regulatory domain information
+ *	structure pased by userspace (CRDA) from our wireless-regdb.
+ *	If a channel is enabled but the country code indicates it should
+ *	be disabled we disable the channel and re-enable it upon disassociation.
+ */
+enum nl80211_reg_initiator {
+	NL80211_REGDOM_SET_BY_CORE,
+	NL80211_REGDOM_SET_BY_USER,
+	NL80211_REGDOM_SET_BY_DRIVER,
+	NL80211_REGDOM_SET_BY_COUNTRY_IE,
+};
+
+/**
+ * enum nl80211_reg_type - specifies the type of regulatory domain
+ * @NL80211_REGDOM_TYPE_COUNTRY: the regulatory domain set is one that pertains
+ *	to a specific country. When this is set you can count on the
+ *	ISO / IEC 3166 alpha2 country code being valid.
+ * @NL80211_REGDOM_TYPE_WORLD: the regulatory set domain is the world regulatory
+ * 	domain.
+ * @NL80211_REGDOM_TYPE_CUSTOM_WORLD: the regulatory domain set is a custom
+ * 	driver specific world regulatory domain. These do not apply system-wide
+ * 	and are only applicable to the individual devices which have requested
+ * 	them to be applied.
+ * @NL80211_REGDOM_TYPE_INTERSECTION: the regulatory domain set is the product
+ *	of an intersection between two regulatory domains -- the previously
+ *	set regulatory domain on the system and the last accepted regulatory
+ *	domain request to be processed.
+ */
+enum nl80211_reg_type {
+	NL80211_REGDOM_TYPE_COUNTRY,
+	NL80211_REGDOM_TYPE_WORLD,
+	NL80211_REGDOM_TYPE_CUSTOM_WORLD,
+	NL80211_REGDOM_TYPE_INTERSECTION,
+};
+
+/**
+ * enum nl80211_reg_rule_attr - regulatory rule attributes
+ * @__NL80211_REG_RULE_ATTR_INVALID: attribute number 0 is reserved
+ * @NL80211_ATTR_REG_RULE_FLAGS: a set of flags which specify additional
+ * 	considerations for a given frequency range. These are the
+ * 	&enum nl80211_reg_rule_flags.
+ * @NL80211_ATTR_FREQ_RANGE_START: starting frequencry for the regulatory
+ * 	rule in KHz. This is not a center of frequency but an actual regulatory
+ * 	band edge.
+ * @NL80211_ATTR_FREQ_RANGE_END: ending frequency for the regulatory rule
+ * 	in KHz. This is not a center a frequency but an actual regulatory
+ * 	band edge.
+ * @NL80211_ATTR_FREQ_RANGE_MAX_BW: maximum allowed bandwidth for this
+ * 	frequency range, in KHz.
+ * @NL80211_ATTR_POWER_RULE_MAX_ANT_GAIN: the maximum allowed antenna gain
+ * 	for a given frequency range. The value is in mBi (100 * dBi).
+ * 	If you don't have one then don't send this.
+ * @NL80211_ATTR_POWER_RULE_MAX_EIRP: the maximum allowed EIRP for
+ * 	a given frequency range. The value is in mBm (100 * dBm).
+ * @NL80211_REG_RULE_ATTR_MAX: highest regulatory rule attribute number
+ *	currently defined
+ * @__NL80211_REG_RULE_ATTR_AFTER_LAST: internal use
+ */
+enum nl80211_reg_rule_attr {
+	__NL80211_REG_RULE_ATTR_INVALID,
+	NL80211_ATTR_REG_RULE_FLAGS,
+
+	NL80211_ATTR_FREQ_RANGE_START,
+	NL80211_ATTR_FREQ_RANGE_END,
+	NL80211_ATTR_FREQ_RANGE_MAX_BW,
+
+	NL80211_ATTR_POWER_RULE_MAX_ANT_GAIN,
+	NL80211_ATTR_POWER_RULE_MAX_EIRP,
+
+	/* keep last */
+	__NL80211_REG_RULE_ATTR_AFTER_LAST,
+	NL80211_REG_RULE_ATTR_MAX = __NL80211_REG_RULE_ATTR_AFTER_LAST - 1
+};
+
+/**
+ * enum nl80211_reg_rule_flags - regulatory rule flags
+ *
+ * @NL80211_RRF_NO_OFDM: OFDM modulation not allowed
+ * @NL80211_RRF_NO_CCK: CCK modulation not allowed
+ * @NL80211_RRF_NO_INDOOR: indoor operation not allowed
+ * @NL80211_RRF_NO_OUTDOOR: outdoor operation not allowed
+ * @NL80211_RRF_DFS: DFS support is required to be used
+ * @NL80211_RRF_PTP_ONLY: this is only for Point To Point links
+ * @NL80211_RRF_PTMP_ONLY: this is only for Point To Multi Point links
+ * @NL80211_RRF_PASSIVE_SCAN: passive scan is required
+ * @NL80211_RRF_NO_IBSS: no IBSS is allowed
+ */
+enum nl80211_reg_rule_flags {
+	NL80211_RRF_NO_OFDM		= 1<<0,
+	NL80211_RRF_NO_CCK		= 1<<1,
+	NL80211_RRF_NO_INDOOR		= 1<<2,
+	NL80211_RRF_NO_OUTDOOR		= 1<<3,
+	NL80211_RRF_DFS			= 1<<4,
+	NL80211_RRF_PTP_ONLY		= 1<<5,
+	NL80211_RRF_PTMP_ONLY		= 1<<6,
+	NL80211_RRF_PASSIVE_SCAN	= 1<<7,
+	NL80211_RRF_NO_IBSS		= 1<<8,
+};
+
+/**
+ * enum nl80211_survey_info - survey information
+ *
+ * These attribute types are used with %NL80211_ATTR_SURVEY_INFO
+ * when getting information about a survey.
+ *
+ * @__NL80211_SURVEY_INFO_INVALID: attribute number 0 is reserved
+ * @NL80211_SURVEY_INFO_FREQUENCY: center frequency of channel
+ * @NL80211_SURVEY_INFO_NOISE: noise level of channel (u8, dBm)
+ * @NL80211_SURVEY_INFO_IN_USE: channel is currently being used
+ * @NL80211_SURVEY_INFO_CHANNEL_TIME: amount of time (in ms) that the radio
+ *	spent on this channel
+ * @NL80211_SURVEY_INFO_CHANNEL_TIME_BUSY: amount of the time the primary
+ *	channel was sensed busy (either due to activity or energy detect)
+ * @NL80211_SURVEY_INFO_CHANNEL_TIME_EXT_BUSY: amount of time the extension
+ *	channel was sensed busy
+ * @NL80211_SURVEY_INFO_CHANNEL_TIME_RX: amount of time the radio spent
+ *	receiving data
+ * @NL80211_SURVEY_INFO_CHANNEL_TIME_TX: amount of time the radio spent
+ *	transmitting data
+ * @NL80211_SURVEY_INFO_MAX: highest survey info attribute number
+ *	currently defined
+ * @__NL80211_SURVEY_INFO_AFTER_LAST: internal use
+ */
+enum nl80211_survey_info {
+	__NL80211_SURVEY_INFO_INVALID,
+	NL80211_SURVEY_INFO_FREQUENCY,
+	NL80211_SURVEY_INFO_NOISE,
+	NL80211_SURVEY_INFO_IN_USE,
+	NL80211_SURVEY_INFO_CHANNEL_TIME,
+	NL80211_SURVEY_INFO_CHANNEL_TIME_BUSY,
+	NL80211_SURVEY_INFO_CHANNEL_TIME_EXT_BUSY,
+	NL80211_SURVEY_INFO_CHANNEL_TIME_RX,
+	NL80211_SURVEY_INFO_CHANNEL_TIME_TX,
+
+	/* keep last */
+	__NL80211_SURVEY_INFO_AFTER_LAST,
+	NL80211_SURVEY_INFO_MAX = __NL80211_SURVEY_INFO_AFTER_LAST - 1
+};
+
+/**
+ * enum nl80211_mntr_flags - monitor configuration flags
+ *
+ * Monitor configuration flags.
+ *
+ * @__NL80211_MNTR_FLAG_INVALID: reserved
+ *
+ * @NL80211_MNTR_FLAG_FCSFAIL: pass frames with bad FCS
+ * @NL80211_MNTR_FLAG_PLCPFAIL: pass frames with bad PLCP
+ * @NL80211_MNTR_FLAG_CONTROL: pass control frames
+ * @NL80211_MNTR_FLAG_OTHER_BSS: disable BSSID filtering
+ * @NL80211_MNTR_FLAG_COOK_FRAMES: report frames after processing.
+ *	overrides all other flags.
+ *
+ * @__NL80211_MNTR_FLAG_AFTER_LAST: internal use
+ * @NL80211_MNTR_FLAG_MAX: highest possible monitor flag
+ */
+enum nl80211_mntr_flags {
+	__NL80211_MNTR_FLAG_INVALID,
+	NL80211_MNTR_FLAG_FCSFAIL,
+	NL80211_MNTR_FLAG_PLCPFAIL,
+	NL80211_MNTR_FLAG_CONTROL,
+	NL80211_MNTR_FLAG_OTHER_BSS,
+	NL80211_MNTR_FLAG_COOK_FRAMES,
+
+	/* keep last */
+	__NL80211_MNTR_FLAG_AFTER_LAST,
+	NL80211_MNTR_FLAG_MAX = __NL80211_MNTR_FLAG_AFTER_LAST - 1
+};
+
+/**
+ * enum nl80211_meshconf_params - mesh configuration parameters
+ *
+ * Mesh configuration parameters
+ *
+ * @__NL80211_MESHCONF_INVALID: internal use
+ *
+ * @NL80211_MESHCONF_RETRY_TIMEOUT: specifies the initial retry timeout in
+ * millisecond units, used by the Peer Link Open message
+ *
+ * @NL80211_MESHCONF_CONFIRM_TIMEOUT: specifies the inital confirm timeout, in
+ * millisecond units, used by the peer link management to close a peer link
+ *
+ * @NL80211_MESHCONF_HOLDING_TIMEOUT: specifies the holding timeout, in
+ * millisecond units
+ *
+ * @NL80211_MESHCONF_MAX_PEER_LINKS: maximum number of peer links allowed
+ * on this mesh interface
+ *
+ * @NL80211_MESHCONF_MAX_RETRIES: specifies the maximum number of peer link
+ * open retries that can be sent to establish a new peer link instance in a
+ * mesh
+ *
+ * @NL80211_MESHCONF_TTL: specifies the value of TTL field set at a source mesh
+ * point.
+ *
+ * @NL80211_MESHCONF_ELEMENT_TTL: specifies the value of TTL field set at a
+ * source mesh point for path selection elements.
+ *
+ * @NL80211_MESHCONF_AUTO_OPEN_PLINKS: whether we should automatically
+ * open peer links when we detect compatible mesh peers.
+ *
+ * @NL80211_MESHCONF_HWMP_MAX_PREQ_RETRIES: the number of action frames
+ * containing a PREQ that an MP can send to a particular destination (path
+ * target)
+ *
+ * @NL80211_MESHCONF_PATH_REFRESH_TIME: how frequently to refresh mesh paths
+ * (in milliseconds)
+ *
+ * @NL80211_MESHCONF_MIN_DISCOVERY_TIMEOUT: minimum length of time to wait
+ * until giving up on a path discovery (in milliseconds)
+ *
+ * @NL80211_MESHCONF_HWMP_ACTIVE_PATH_TIMEOUT: The time (in TUs) for which mesh
+ * points receiving a PREQ shall consider the forwarding information from the
+ * root to be valid. (TU = time unit)
+ *
+ * @NL80211_MESHCONF_HWMP_PREQ_MIN_INTERVAL: The minimum interval of time (in
+ * TUs) during which an MP can send only one action frame containing a PREQ
+ * reference element
+ *
+ * @NL80211_MESHCONF_HWMP_NET_DIAM_TRVS_TIME: The interval of time (in TUs)
+ * that it takes for an HWMP information element to propagate across the mesh
+ *
+ * @NL80211_MESHCONF_ROOTMODE: whether root mode is enabled or not
+ *
+ * @NL80211_MESHCONF_ATTR_MAX: highest possible mesh configuration attribute
+ *
+ * @__NL80211_MESHCONF_ATTR_AFTER_LAST: internal use
+ */
+enum nl80211_meshconf_params {
+	__NL80211_MESHCONF_INVALID,
+	NL80211_MESHCONF_RETRY_TIMEOUT,
+	NL80211_MESHCONF_CONFIRM_TIMEOUT,
+	NL80211_MESHCONF_HOLDING_TIMEOUT,
+	NL80211_MESHCONF_MAX_PEER_LINKS,
+	NL80211_MESHCONF_MAX_RETRIES,
+	NL80211_MESHCONF_TTL,
+	NL80211_MESHCONF_AUTO_OPEN_PLINKS,
+	NL80211_MESHCONF_HWMP_MAX_PREQ_RETRIES,
+	NL80211_MESHCONF_PATH_REFRESH_TIME,
+	NL80211_MESHCONF_MIN_DISCOVERY_TIMEOUT,
+	NL80211_MESHCONF_HWMP_ACTIVE_PATH_TIMEOUT,
+	NL80211_MESHCONF_HWMP_PREQ_MIN_INTERVAL,
+	NL80211_MESHCONF_HWMP_NET_DIAM_TRVS_TIME,
+	NL80211_MESHCONF_HWMP_ROOTMODE,
+	NL80211_MESHCONF_ELEMENT_TTL,
+
+	/* keep last */
+	__NL80211_MESHCONF_ATTR_AFTER_LAST,
+	NL80211_MESHCONF_ATTR_MAX = __NL80211_MESHCONF_ATTR_AFTER_LAST - 1
+};
+
+/**
+ * enum nl80211_txq_attr - TX queue parameter attributes
+ * @__NL80211_TXQ_ATTR_INVALID: Attribute number 0 is reserved
+ * @NL80211_TXQ_ATTR_QUEUE: TX queue identifier (NL80211_TXQ_Q_*)
+ * @NL80211_TXQ_ATTR_TXOP: Maximum burst time in units of 32 usecs, 0 meaning
+ *	disabled
+ * @NL80211_TXQ_ATTR_CWMIN: Minimum contention window [a value of the form
+ *	2^n-1 in the range 1..32767]
+ * @NL80211_TXQ_ATTR_CWMAX: Maximum contention window [a value of the form
+ *	2^n-1 in the range 1..32767]
+ * @NL80211_TXQ_ATTR_AIFS: Arbitration interframe space [0..255]
+ * @__NL80211_TXQ_ATTR_AFTER_LAST: Internal
+ * @NL80211_TXQ_ATTR_MAX: Maximum TXQ attribute number
+ */
+enum nl80211_txq_attr {
+	__NL80211_TXQ_ATTR_INVALID,
+	NL80211_TXQ_ATTR_QUEUE,
+	NL80211_TXQ_ATTR_TXOP,
+	NL80211_TXQ_ATTR_CWMIN,
+	NL80211_TXQ_ATTR_CWMAX,
+	NL80211_TXQ_ATTR_AIFS,
+
+	/* keep last */
+	__NL80211_TXQ_ATTR_AFTER_LAST,
+	NL80211_TXQ_ATTR_MAX = __NL80211_TXQ_ATTR_AFTER_LAST - 1
+};
+
+enum nl80211_txq_q {
+	NL80211_TXQ_Q_VO,
+	NL80211_TXQ_Q_VI,
+	NL80211_TXQ_Q_BE,
+	NL80211_TXQ_Q_BK
+};
+
+enum nl80211_channel_type {
+	NL80211_CHAN_NO_HT,
+	NL80211_CHAN_HT20,
+	NL80211_CHAN_HT40MINUS,
+	NL80211_CHAN_HT40PLUS
+};
+
+/**
+ * enum nl80211_bss - netlink attributes for a BSS
+ *
+ * @__NL80211_BSS_INVALID: invalid
+ * @NL80211_BSS_BSSID: BSSID of the BSS (6 octets)
+ * @NL80211_BSS_FREQUENCY: frequency in MHz (u32)
+ * @NL80211_BSS_TSF: TSF of the received probe response/beacon (u64)
+ * @NL80211_BSS_BEACON_INTERVAL: beacon interval of the (I)BSS (u16)
+ * @NL80211_BSS_CAPABILITY: capability field (CPU order, u16)
+ * @NL80211_BSS_INFORMATION_ELEMENTS: binary attribute containing the
+ *	raw information elements from the probe response/beacon (bin);
+ *	if the %NL80211_BSS_BEACON_IES attribute is present, the IEs here are
+ *	from a Probe Response frame; otherwise they are from a Beacon frame.
+ *	However, if the driver does not indicate the source of the IEs, these
+ *	IEs may be from either frame subtype.
+ * @NL80211_BSS_SIGNAL_MBM: signal strength of probe response/beacon
+ *	in mBm (100 * dBm) (s32)
+ * @NL80211_BSS_SIGNAL_UNSPEC: signal strength of the probe response/beacon
+ *	in unspecified units, scaled to 0..100 (u8)
+ * @NL80211_BSS_STATUS: status, if this BSS is "used"
+ * @NL80211_BSS_SEEN_MS_AGO: age of this BSS entry in ms
+ * @NL80211_BSS_BEACON_IES: binary attribute containing the raw information
+ *	elements from a Beacon frame (bin); not present if no Beacon frame has
+ *	yet been received
+ * @__NL80211_BSS_AFTER_LAST: internal
+ * @NL80211_BSS_MAX: highest BSS attribute
+ */
+enum nl80211_bss {
+	__NL80211_BSS_INVALID,
+	NL80211_BSS_BSSID,
+	NL80211_BSS_FREQUENCY,
+	NL80211_BSS_TSF,
+	NL80211_BSS_BEACON_INTERVAL,
+	NL80211_BSS_CAPABILITY,
+	NL80211_BSS_INFORMATION_ELEMENTS,
+	NL80211_BSS_SIGNAL_MBM,
+	NL80211_BSS_SIGNAL_UNSPEC,
+	NL80211_BSS_STATUS,
+	NL80211_BSS_SEEN_MS_AGO,
+	NL80211_BSS_BEACON_IES,
+
+	/* keep last */
+	__NL80211_BSS_AFTER_LAST,
+	NL80211_BSS_MAX = __NL80211_BSS_AFTER_LAST - 1
+};
+
+/**
+ * enum nl80211_bss_status - BSS "status"
+ * @NL80211_BSS_STATUS_AUTHENTICATED: Authenticated with this BSS.
+ * @NL80211_BSS_STATUS_ASSOCIATED: Associated with this BSS.
+ * @NL80211_BSS_STATUS_IBSS_JOINED: Joined to this IBSS.
+ *
+ * The BSS status is a BSS attribute in scan dumps, which
+ * indicates the status the interface has wrt. this BSS.
+ */
+enum nl80211_bss_status {
+	NL80211_BSS_STATUS_AUTHENTICATED,
+	NL80211_BSS_STATUS_ASSOCIATED,
+	NL80211_BSS_STATUS_IBSS_JOINED,
+};
+
+/**
+ * enum nl80211_auth_type - AuthenticationType
+ *
+ * @NL80211_AUTHTYPE_OPEN_SYSTEM: Open System authentication
+ * @NL80211_AUTHTYPE_SHARED_KEY: Shared Key authentication (WEP only)
+ * @NL80211_AUTHTYPE_FT: Fast BSS Transition (IEEE 802.11r)
+ * @NL80211_AUTHTYPE_NETWORK_EAP: Network EAP (some Cisco APs and mainly LEAP)
+ * @__NL80211_AUTHTYPE_NUM: internal
+ * @NL80211_AUTHTYPE_MAX: maximum valid auth algorithm
+ * @NL80211_AUTHTYPE_AUTOMATIC: determine automatically (if necessary by
+ *	trying multiple times); this is invalid in netlink -- leave out
+ *	the attribute for this on CONNECT commands.
+ */
+enum nl80211_auth_type {
+	NL80211_AUTHTYPE_OPEN_SYSTEM,
+	NL80211_AUTHTYPE_SHARED_KEY,
+	NL80211_AUTHTYPE_FT,
+	NL80211_AUTHTYPE_NETWORK_EAP,
+
+	/* keep last */
+	__NL80211_AUTHTYPE_NUM,
+	NL80211_AUTHTYPE_MAX = __NL80211_AUTHTYPE_NUM - 1,
+	NL80211_AUTHTYPE_AUTOMATIC
+};
+
+/**
+ * enum nl80211_key_type - Key Type
+ * @NL80211_KEYTYPE_GROUP: Group (broadcast/multicast) key
+ * @NL80211_KEYTYPE_PAIRWISE: Pairwise (unicast/individual) key
+ * @NL80211_KEYTYPE_PEERKEY: PeerKey (DLS)
+ * @NUM_NL80211_KEYTYPES: number of defined key types
+ */
+enum nl80211_key_type {
+	NL80211_KEYTYPE_GROUP,
+	NL80211_KEYTYPE_PAIRWISE,
+	NL80211_KEYTYPE_PEERKEY,
+
+	NUM_NL80211_KEYTYPES
+};
+
+/**
+ * enum nl80211_mfp - Management frame protection state
+ * @NL80211_MFP_NO: Management frame protection not used
+ * @NL80211_MFP_REQUIRED: Management frame protection required
+ */
+enum nl80211_mfp {
+	NL80211_MFP_NO,
+	NL80211_MFP_REQUIRED,
+};
+
+enum nl80211_wpa_versions {
+	NL80211_WPA_VERSION_1 = 1 << 0,
+	NL80211_WPA_VERSION_2 = 1 << 1,
+};
+
+/**
+ * enum nl80211_key_attributes - key attributes
+ * @__NL80211_KEY_INVALID: invalid
+ * @NL80211_KEY_DATA: (temporal) key data; for TKIP this consists of
+ *	16 bytes encryption key followed by 8 bytes each for TX and RX MIC
+ *	keys
+ * @NL80211_KEY_IDX: key ID (u8, 0-3)
+ * @NL80211_KEY_CIPHER: key cipher suite (u32, as defined by IEEE 802.11
+ *	section 7.3.2.25.1, e.g. 0x000FAC04)
+ * @NL80211_KEY_SEQ: transmit key sequence number (IV/PN) for TKIP and
+ *	CCMP keys, each six bytes in little endian
+ * @NL80211_KEY_DEFAULT: flag indicating default key
+ * @NL80211_KEY_DEFAULT_MGMT: flag indicating default management key
+ * @NL80211_KEY_TYPE: the key type from enum nl80211_key_type, if not
+ *	specified the default depends on whether a MAC address was
+ *	given with the command using the key or not (u32)
+ * @__NL80211_KEY_AFTER_LAST: internal
+ * @NL80211_KEY_MAX: highest key attribute
+ */
+enum nl80211_key_attributes {
+	__NL80211_KEY_INVALID,
+	NL80211_KEY_DATA,
+	NL80211_KEY_IDX,
+	NL80211_KEY_CIPHER,
+	NL80211_KEY_SEQ,
+	NL80211_KEY_DEFAULT,
+	NL80211_KEY_DEFAULT_MGMT,
+	NL80211_KEY_TYPE,
+
+	/* keep last */
+	__NL80211_KEY_AFTER_LAST,
+	NL80211_KEY_MAX = __NL80211_KEY_AFTER_LAST - 1
+};
+
+/**
+ * enum nl80211_tx_rate_attributes - TX rate set attributes
+ * @__NL80211_TXRATE_INVALID: invalid
+ * @NL80211_TXRATE_LEGACY: Legacy (non-MCS) rates allowed for TX rate selection
+ *	in an array of rates as defined in IEEE 802.11 7.3.2.2 (u8 values with
+ *	1 = 500 kbps) but without the IE length restriction (at most
+ *	%NL80211_MAX_SUPP_RATES in a single array).
+ * @__NL80211_TXRATE_AFTER_LAST: internal
+ * @NL80211_TXRATE_MAX: highest TX rate attribute
+ */
+enum nl80211_tx_rate_attributes {
+	__NL80211_TXRATE_INVALID,
+	NL80211_TXRATE_LEGACY,
+
+	/* keep last */
+	__NL80211_TXRATE_AFTER_LAST,
+	NL80211_TXRATE_MAX = __NL80211_TXRATE_AFTER_LAST - 1
+};
+
+/**
+ * enum nl80211_band - Frequency band
+ * @NL80211_BAND_2GHZ: 2.4 GHz ISM band
+ * @NL80211_BAND_5GHZ: around 5 GHz band (4.9 - 5.7 GHz)
+ */
+enum nl80211_band {
+	NL80211_BAND_2GHZ,
+	NL80211_BAND_5GHZ,
+};
+
+enum nl80211_ps_state {
+	NL80211_PS_DISABLED,
+	NL80211_PS_ENABLED,
+};
+
+/**
+ * enum nl80211_attr_cqm - connection quality monitor attributes
+ * @__NL80211_ATTR_CQM_INVALID: invalid
+ * @NL80211_ATTR_CQM_RSSI_THOLD: RSSI threshold in dBm. This value specifies
+ *	the threshold for the RSSI level at which an event will be sent. Zero
+ *	to disable.
+ * @NL80211_ATTR_CQM_RSSI_HYST: RSSI hysteresis in dBm. This value specifies
+ *	the minimum amount the RSSI level must change after an event before a
+ *	new event may be issued (to reduce effects of RSSI oscillation).
+ * @NL80211_ATTR_CQM_RSSI_THRESHOLD_EVENT: RSSI threshold event
+ * @NL80211_ATTR_CQM_PKT_LOSS_EVENT: a u32 value indicating that this many
+ *	consecutive packets were not acknowledged by the peer
+ * @__NL80211_ATTR_CQM_AFTER_LAST: internal
+ * @NL80211_ATTR_CQM_MAX: highest key attribute
+ */
+enum nl80211_attr_cqm {
+	__NL80211_ATTR_CQM_INVALID,
+	NL80211_ATTR_CQM_RSSI_THOLD,
+	NL80211_ATTR_CQM_RSSI_HYST,
+	NL80211_ATTR_CQM_RSSI_THRESHOLD_EVENT,
+	NL80211_ATTR_CQM_PKT_LOSS_EVENT,
+
+	/* keep last */
+	__NL80211_ATTR_CQM_AFTER_LAST,
+	NL80211_ATTR_CQM_MAX = __NL80211_ATTR_CQM_AFTER_LAST - 1
+};
+
+/**
+ * enum nl80211_cqm_rssi_threshold_event - RSSI threshold event
+ * @NL80211_CQM_RSSI_THRESHOLD_EVENT_LOW: The RSSI level is lower than the
+ *      configured threshold
+ * @NL80211_CQM_RSSI_THRESHOLD_EVENT_HIGH: The RSSI is higher than the
+ *      configured threshold
+ */
+enum nl80211_cqm_rssi_threshold_event {
+	NL80211_CQM_RSSI_THRESHOLD_EVENT_LOW,
+	NL80211_CQM_RSSI_THRESHOLD_EVENT_HIGH,
+};
+
+
+/**
+ * enum nl80211_tx_power_setting - TX power adjustment
+ * @NL80211_TX_POWER_AUTOMATIC: automatically determine transmit power
+ * @NL80211_TX_POWER_LIMITED: limit TX power by the mBm parameter
+ * @NL80211_TX_POWER_FIXED: fix TX power to the mBm parameter
+ */
+enum nl80211_tx_power_setting {
+	NL80211_TX_POWER_AUTOMATIC,
+	NL80211_TX_POWER_LIMITED,
+	NL80211_TX_POWER_FIXED,
+};
+
+#endif /* __LINUX_NL80211_H */
diff --git a/external/iw/offch.c b/external/iw/offch.c
new file mode 100644
index 0000000..b40a523
--- /dev/null
+++ b/external/iw/offch.c
@@ -0,0 +1,43 @@
+#include <errno.h>
+
+#include <netlink/genl/genl.h>
+#include <netlink/genl/family.h>
+#include <netlink/genl/ctrl.h>
+#include <netlink/msg.h>
+#include <netlink/attr.h>
+
+#include "nl80211.h"
+#include "iw.h"
+
+static int offchannel(struct nl80211_state *state, struct nl_cb *cb,
+		      struct nl_msg *msg, int argc, char **argv)
+{
+	char *end;
+
+	/* freq */
+	NLA_PUT_U32(msg, NL80211_ATTR_WIPHY_FREQ,
+		    strtoul(argv[0], &end, 10));
+	if (*end != '\0')
+		return 1;
+	argv++;
+	argc--;
+
+	/* duration */
+	NLA_PUT_U32(msg, NL80211_ATTR_DURATION,
+		    strtoul(argv[0], &end, 10));
+	if (*end != '\0')
+		return 1;
+	argv++;
+	argc--;
+
+	if (argc)
+		return 1;
+
+	return 0;
+ nla_put_failure:
+	return -ENOSPC;
+}
+
+TOPLEVEL(offchannel, "<freq> <duration>", NL80211_CMD_REMAIN_ON_CHANNEL, 0,
+	 CIB_NETDEV, offchannel,
+	 "Leave operating channel and go to the given channel for a while.");
diff --git a/external/iw/phy.c b/external/iw/phy.c
new file mode 100644
index 0000000..7c6c7c8
--- /dev/null
+++ b/external/iw/phy.c
@@ -0,0 +1,309 @@
+#include <stdbool.h>
+#include <errno.h>
+#include <net/if.h>
+#include <strings.h>
+
+#include <netlink/genl/genl.h>
+#include <netlink/genl/family.h>
+#include <netlink/genl/ctrl.h>
+#include <netlink/msg.h>
+#include <netlink/attr.h>
+
+#include "nl80211.h"
+#include "iw.h"
+
+static int handle_name(struct nl80211_state *state,
+		       struct nl_cb *cb,
+		       struct nl_msg *msg,
+		       int argc, char **argv)
+{
+	if (argc != 1)
+		return 1;
+
+	NLA_PUT_STRING(msg, NL80211_ATTR_WIPHY_NAME, *argv);
+
+	return 0;
+ nla_put_failure:
+	return -ENOBUFS;
+}
+COMMAND(set, name, "<new name>", NL80211_CMD_SET_WIPHY, 0, CIB_PHY, handle_name,
+	"Rename this wireless device.");
+
+static int handle_freqchan(struct nl_msg *msg, bool chan,
+			   int argc, char **argv)
+{
+	char *end;
+	static const struct {
+		const char *name;
+		unsigned int val;
+	} htmap[] = {
+		{ .name = "HT20", .val = NL80211_CHAN_HT20, },
+		{ .name = "HT40+", .val = NL80211_CHAN_HT40PLUS, },
+		{ .name = "HT40-", .val = NL80211_CHAN_HT40MINUS, },
+	};
+	unsigned int htval = NL80211_CHAN_NO_HT;
+	unsigned int freq;
+	int i;
+
+	if (!argc || argc > 2)
+		return 1;
+
+	if (argc == 2) {
+		for (i = 0; i < ARRAY_SIZE(htmap); i++) {
+			if (strcasecmp(htmap[i].name, argv[1]) == 0) {
+				htval = htmap[i].val;
+				break;
+			}
+		}
+		if (htval == NL80211_CHAN_NO_HT)
+			return 1;
+	}
+
+	if (!*argv[0])
+		return 1;
+	freq = strtoul(argv[0], &end, 10);
+	if (*end)
+		return 1;
+
+	if (chan)
+		freq = ieee80211_channel_to_frequency(freq);
+
+	NLA_PUT_U32(msg, NL80211_ATTR_WIPHY_FREQ, freq);
+	NLA_PUT_U32(msg, NL80211_ATTR_WIPHY_CHANNEL_TYPE, htval);
+
+	return 0;
+ nla_put_failure:
+	return -ENOBUFS;
+}
+
+static int handle_freq(struct nl80211_state *state,
+		       struct nl_cb *cb, struct nl_msg *msg,
+		       int argc, char **argv)
+{
+	return handle_freqchan(msg, false, argc, argv);
+}
+COMMAND(set, freq, "<freq> [HT20|HT40+|HT40-]",
+	NL80211_CMD_SET_WIPHY, 0, CIB_PHY, handle_freq,
+	"Set frequency/channel the hardware is using, including HT\n"
+	"configuration.");
+COMMAND(set, freq, "<freq> [HT20|HT40+|HT40-]",
+	NL80211_CMD_SET_WIPHY, 0, CIB_NETDEV, handle_freq, NULL);
+
+static int handle_chan(struct nl80211_state *state,
+		       struct nl_cb *cb, struct nl_msg *msg,
+		       int argc, char **argv)
+{
+	return handle_freqchan(msg, true, argc, argv);
+}
+COMMAND(set, channel, "<channel> [HT20|HT40+|HT40-]",
+	NL80211_CMD_SET_WIPHY, 0, CIB_PHY, handle_chan, NULL);
+COMMAND(set, channel, "<channel> [HT20|HT40+|HT40-]",
+	NL80211_CMD_SET_WIPHY, 0, CIB_NETDEV, handle_chan, NULL);
+
+static int handle_fragmentation(struct nl80211_state *state,
+				struct nl_cb *cb, struct nl_msg *msg,
+				int argc, char **argv)
+{
+	unsigned int frag;
+
+	if (argc != 1)
+		return 1;
+
+	if (strcmp("off", argv[0]) == 0)
+		frag = -1;
+	else {
+		char *end;
+
+		if (!*argv[0])
+			return 1;
+		frag = strtoul(argv[0], &end, 10);
+		if (*end != '\0')
+			return 1;
+	}
+
+	NLA_PUT_U32(msg, NL80211_ATTR_WIPHY_FRAG_THRESHOLD, frag);
+
+	return 0;
+ nla_put_failure:
+	return -ENOBUFS;
+}
+COMMAND(set, frag, "<fragmentation threshold|off>",
+	NL80211_CMD_SET_WIPHY, 0, CIB_PHY, handle_fragmentation,
+	"Set fragmentation threshold.");
+
+static int handle_rts(struct nl80211_state *state,
+		      struct nl_cb *cb, struct nl_msg *msg,
+		      int argc, char **argv)
+{
+	unsigned int rts;
+
+	if (argc != 1)
+		return 1;
+
+	if (strcmp("off", argv[0]) == 0)
+		rts = -1;
+	else {
+		char *end;
+
+		if (!*argv[0])
+			return 1;
+		rts = strtoul(argv[0], &end, 10);
+		if (*end != '\0')
+			return 1;
+	}
+
+	NLA_PUT_U32(msg, NL80211_ATTR_WIPHY_RTS_THRESHOLD, rts);
+
+	return 0;
+ nla_put_failure:
+	return -ENOBUFS;
+}
+COMMAND(set, rts, "<rts threshold|off>",
+	NL80211_CMD_SET_WIPHY, 0, CIB_PHY, handle_rts,
+	"Set rts threshold.");
+
+static int handle_netns(struct nl80211_state *state,
+			struct nl_cb *cb,
+			struct nl_msg *msg,
+			int argc, char **argv)
+{
+	char *end;
+
+	if (argc != 1)
+		return 1;
+
+	if (!*argv[0])
+		return 1;
+
+	NLA_PUT_U32(msg, NL80211_ATTR_PID,
+		    strtoul(argv[0], &end, 10)); 
+
+	if (*end != '\0')
+		return 1;
+
+	return 0;
+ nla_put_failure:
+	return -ENOBUFS;
+}
+COMMAND(set, netns, "<pid>",
+	NL80211_CMD_SET_WIPHY_NETNS, 0, CIB_PHY, handle_netns,
+	"Put this wireless device into a different network namespace");
+
+static int handle_coverage(struct nl80211_state *state,
+			struct nl_cb *cb,
+			struct nl_msg *msg,
+			int argc, char **argv)
+{
+	char *end;
+	unsigned int coverage;
+
+	if (argc != 1)
+		return 1;
+
+	if (!*argv[0])
+		return 1;
+	coverage = strtoul(argv[0], &end, 10);
+	if (coverage > 255)
+		return 1;
+
+	if (*end)
+		return 1;
+
+	NLA_PUT_U8(msg, NL80211_ATTR_WIPHY_COVERAGE_CLASS, coverage);
+
+	return 0;
+ nla_put_failure:
+	return -ENOBUFS;
+}
+COMMAND(set, coverage, "<coverage class>",
+	NL80211_CMD_SET_WIPHY, 0, CIB_PHY, handle_coverage,
+	"Set coverage class (1 for every 3 usec of air propagation time).\n"
+	"Valid values: 0 - 255.");
+
+static int handle_distance(struct nl80211_state *state,
+			struct nl_cb *cb,
+			struct nl_msg *msg,
+			int argc, char **argv)
+{
+	char *end;
+	unsigned int distance, coverage;
+
+	if (argc != 1)
+		return 1;
+
+	if (!*argv[0])
+		return 1;
+
+	distance = strtoul(argv[0], &end, 10);
+
+	if (*end)
+		return 1;
+
+	/*
+	 * Divide double the distance by the speed of light in m/usec (300) to
+	 * get round-trip time in microseconds and then divide the result by
+	 * three to get coverage class as specified in IEEE 802.11-2007 table
+	 * 7-27. Values are rounded upwards.
+	 */
+	coverage = (distance + 449) / 450;
+	if (coverage > 255)
+		return 1;
+
+	NLA_PUT_U8(msg, NL80211_ATTR_WIPHY_COVERAGE_CLASS, coverage);
+
+	return 0;
+ nla_put_failure:
+	return -ENOBUFS;
+}
+COMMAND(set, distance, "<distance>",
+	NL80211_CMD_SET_WIPHY, 0, CIB_PHY, handle_distance,
+	"Set appropriate coverage class for given link distance in meters.\n"
+	"Valid values: 0 - 114750");
+
+static int handle_txpower(struct nl80211_state *state,
+			  struct nl_cb *cb,
+			  struct nl_msg *msg,
+			  int argc, char **argv)
+{
+	enum nl80211_tx_power_setting type;
+	int mbm;
+
+	/* get the required args */
+	if (argc != 1 && argc != 2)
+		return 1;
+
+	if (!strcmp(argv[0], "auto"))
+		type = NL80211_TX_POWER_AUTOMATIC;
+	else if (!strcmp(argv[0], "fixed"))
+		type = NL80211_TX_POWER_FIXED;
+	else if (!strcmp(argv[0], "limit"))
+		type = NL80211_TX_POWER_LIMITED;
+	else {
+		printf("Invalid parameter: %s\n", argv[0]);
+		return 2;
+	}
+
+	NLA_PUT_U32(msg, NL80211_ATTR_WIPHY_TX_POWER_SETTING, type);
+
+	if (type != NL80211_TX_POWER_AUTOMATIC) {
+		if (argc != 2) {
+			printf("Missing TX power level argument.\n");
+			return 2;
+		}
+
+		mbm = atoi(argv[1]);
+		NLA_PUT_U32(msg, NL80211_ATTR_WIPHY_TX_POWER_LEVEL, mbm);
+	} else if (argc != 1)
+		return 1;
+
+	return 0;
+
+ nla_put_failure:
+	return -ENOBUFS;
+}
+COMMAND(set, txpower, "<auto|fixed|limit> [<tx power in mBm>]",
+	NL80211_CMD_SET_WIPHY, 0, CIB_PHY, handle_txpower,
+	"Specify transmit power level and setting type.");
+COMMAND(set, txpower, "<auto|fixed|limit> [<tx power in mBm>]",
+	NL80211_CMD_SET_WIPHY, 0, CIB_NETDEV, handle_txpower,
+	"Specify transmit power level and setting type.");
diff --git a/external/iw/ps.c b/external/iw/ps.c
new file mode 100644
index 0000000..6feeeb9
--- /dev/null
+++ b/external/iw/ps.c
@@ -0,0 +1,83 @@
+#include <errno.h>
+#include <string.h>
+
+#include <netlink/genl/genl.h>
+#include <netlink/msg.h>
+#include <netlink/attr.h>
+
+#include "nl80211.h"
+#include "iw.h"
+
+static int set_power_save(struct nl80211_state *state,
+			  struct nl_cb *cb,
+			  struct nl_msg *msg,
+			  int argc, char **argv)
+{
+	enum nl80211_ps_state ps_state;
+
+	if (argc != 1) {
+		printf("Invalid parameters!\n");
+		return 2;
+	}
+
+	if (strcmp(argv[0], "on") == 0)
+		ps_state = NL80211_PS_ENABLED;
+	else if (strcmp(argv[0], "off") == 0)
+		ps_state = NL80211_PS_DISABLED;
+	else {
+		printf("Invalid parameter: %s\n", argv[0]);
+		return 2;
+	}
+
+	NLA_PUT_U32(msg, NL80211_ATTR_PS_STATE, ps_state);
+
+	return 0;
+
+ nla_put_failure:
+	return -ENOBUFS;
+}
+
+COMMAND(set, power_save, "<on|off>",
+	NL80211_CMD_SET_POWER_SAVE, 0, CIB_NETDEV, set_power_save,
+	"Set power save state to on or off.");
+
+static int print_power_save_handler(struct nl_msg *msg, void *arg)
+{
+	struct nlattr *attrs[NL80211_ATTR_MAX + 1];
+	struct genlmsghdr *gnlh = nlmsg_data(nlmsg_hdr(msg));
+	const char *s;
+
+	nla_parse(attrs, NL80211_ATTR_MAX, genlmsg_attrdata(gnlh, 0),
+		  genlmsg_attrlen(gnlh, 0), NULL);
+
+	if (!attrs[NL80211_ATTR_PS_STATE])
+		return NL_SKIP;
+
+	switch (nla_get_u32(attrs[NL80211_ATTR_PS_STATE])) {
+	case NL80211_PS_ENABLED:
+		s = "on";
+		break;
+	case NL80211_PS_DISABLED:
+	default:
+		s = "off";
+		break;
+	}
+
+	printf("Power save: %s\n", s);
+
+	return NL_SKIP;
+}
+
+static int get_power_save(struct nl80211_state *state,
+				   struct nl_cb *cb,
+				   struct nl_msg *msg,
+				   int argc, char **argv)
+{
+	nl_cb_set(cb, NL_CB_VALID, NL_CB_CUSTOM,
+		  print_power_save_handler, NULL);
+	return 0;
+}
+
+COMMAND(get, power_save, "<param>",
+	NL80211_CMD_GET_POWER_SAVE, 0, CIB_NETDEV, get_power_save,
+	"Retrieve power save state.");
diff --git a/external/iw/reason.c b/external/iw/reason.c
new file mode 100644
index 0000000..f91c681
--- /dev/null
+++ b/external/iw/reason.c
@@ -0,0 +1,50 @@
+#include <stdint.h>
+#include "iw.h"
+
+static const char *reason_table[] = {
+	[1] = "Unspecified",
+	[2] = "Previous authentication no longer valid",
+	[3] = "Deauthenticated because sending station is leaving (or has left) the IBSS or ESS",
+	[4] = "Disassociated due to inactivity",
+	[5] = "Disassociated because AP is unable to handle all currently associated STA",
+	[6] = "Class 2 frame received from non-authenticated station",
+	[7] = "Class 3 frame received from non-authenticated station",
+	[8] = "Disassociated because sending station is leaving (or has left) the BSS",
+	[9] = "Station requesting (re)association is not authenticated with responding station",
+	[10] = "Disassociated because the information in the Power Capability element is unacceptable",
+	[11] = "Disassociated because the information in the Supported Channels element is unacceptable",
+	[13] = "Invalid information element",
+	[14] = "MIC failure",
+	[15] = "4-way handshake timeout",
+	[16] = "Group key update timeout",
+	[17] = "Information element in 4-way handshake different from (Re-)associate request/Probe response/Beacon",
+	[18] = "Multicast cipher is not valid",
+	[19] = "Unicast cipher is not valid",
+	[20] = "AKMP is not valid",
+	[21] = "Unsupported RSNE version",
+	[22] = "Invalid RSNE capabilities",
+	[23] = "IEEE 802.1X authentication failed",
+	[24] = "Cipher Suite rejected per security policy",
+	[31] = "TS deleted because QoS AP lacks sufficient bandwidth for this QoS STA due to a change in BSS service characteristics or operational mode",
+	[32] = "Disassociated for unspecified QoS-related reason",
+	[33] = "Disassociated because QAP lacks sufficient bandwidth for this STA",
+	[34] = "Disassociated because of excessive frame losses and/or poor channel conditions",
+	[35] = "Disassociated because QSTA is transmitting outside the limits of its polled TXOPs",
+	[36] = "Requested from peer QSTA as the QSTA is leaving the QBSS (or resetting)",
+	[37] = "Requested from peer QSTA as it does not want to use Traffic Stream",
+	[38] = "Requested from peer QSTA as the QSTA received frames indicated Traffic Stream for which it has not set up",
+	[39] = "Requested from peer QSTA due to time out",
+	[40] = "Requested from peer QSTA as the QSTA is leaving the QBSS (or resetting)",
+	[41] = "Requested from peer QSTA as it does not want to receive frames directly from the QSTA",
+	[42] = "Requested from peer QSTA as the QSTA received DLP frames for which it has not set up",
+	[43] = "Requested from peer QSTA as it does not want to use Block Ack",
+	[44] = "Requested from peer QSTA as the QSTA received frames indicated Block Acknowledgement policy for which it has not set up",
+	[45] = "Peer QSTA does not support the requested cipher suite",
+};
+
+const char *get_reason_str(uint16_t reason)
+{
+	if (reason < ARRAY_SIZE(reason_table) && reason_table[reason])
+		return reason_table[reason];
+	return "<unknown>";
+}
diff --git a/external/iw/reg.c b/external/iw/reg.c
new file mode 100644
index 0000000..7f82e08
--- /dev/null
+++ b/external/iw/reg.c
@@ -0,0 +1,191 @@
+#include <net/if.h>
+#include <errno.h>
+#include <string.h>
+#include <stdbool.h>
+
+#include <netlink/genl/genl.h>
+#include <netlink/genl/family.h>
+#include <netlink/genl/ctrl.h>
+#include <netlink/msg.h>
+#include <netlink/attr.h>
+
+#include "nl80211.h"
+#include "iw.h"
+
+SECTION(reg);
+
+#define MHZ_TO_KHZ(freq) ((freq) * 1000)
+#define KHZ_TO_MHZ(freq) ((freq) / 1000)
+#define DBI_TO_MBI(gain) ((gain) * 100)
+#define MBI_TO_DBI(gain) ((gain) / 100)
+#define DBM_TO_MBM(gain) ((gain) * 100)
+#define MBM_TO_DBM(gain) ((gain) / 100)
+
+static bool isalpha_upper(char letter)
+{
+	if (letter >= 65 && letter <= 90)
+		return true;
+	return false;
+}
+
+static bool is_alpha2(char *alpha2)
+{
+	if (isalpha_upper(alpha2[0]) && isalpha_upper(alpha2[1]))
+		return true;
+	return false;
+}
+
+static bool is_world_regdom(char *alpha2)
+{
+	/* ASCII 0 */
+	if (alpha2[0] == 48 && alpha2[1] == 48)
+		return true;
+	return false;
+}
+
+char *reg_initiator_to_string(__u8 initiator)
+{
+	switch (initiator) {
+	case NL80211_REGDOM_SET_BY_CORE:
+		return "the wireless core upon initialization";
+	case NL80211_REGDOM_SET_BY_USER:
+		return "a user";
+	case NL80211_REGDOM_SET_BY_DRIVER:
+		return "a driver";
+	case NL80211_REGDOM_SET_BY_COUNTRY_IE:
+		return "a country IE";
+	default:
+		return "BUG";
+	}
+}
+
+static int handle_reg_set(struct nl80211_state *state,
+			  struct nl_cb *cb,
+			  struct nl_msg *msg,
+			  int argc, char **argv)
+{
+	char alpha2[3];
+
+	if (argc < 1)
+		return 1;
+
+	if (!is_alpha2(argv[0]) && !is_world_regdom(argv[0])) {
+		fprintf(stderr, "not a valid ISO/IEC 3166-1 alpha2\n");
+		fprintf(stderr, "Special non-alpha2 usable entries:\n");
+		fprintf(stderr, "\t00\tWorld Regulatory domain\n");
+		return 2;
+	}
+
+	alpha2[0] = argv[0][0];
+	alpha2[1] = argv[0][1];
+	alpha2[2] = '\0';
+
+	argc--;
+	argv++;
+
+	if (argc)
+		return 1;
+
+	NLA_PUT_STRING(msg, NL80211_ATTR_REG_ALPHA2, alpha2);
+
+	return 0;
+ nla_put_failure:
+	return -ENOBUFS;
+}
+COMMAND(reg, set, "<ISO/IEC 3166-1 alpha2>",
+	NL80211_CMD_REQ_SET_REG, 0, CIB_NONE, handle_reg_set,
+	"Notify the kernel about the current regulatory domain.");
+
+static int print_reg_handler(struct nl_msg *msg, void *arg)
+
+{
+#define PARSE_FLAG(nl_flag, string_value)  do { \
+		if ((flags & nl_flag)) { \
+			printf(", %s", string_value); \
+		} \
+	} while (0)
+	struct nlattr *tb_msg[NL80211_ATTR_MAX + 1];
+	struct genlmsghdr *gnlh = nlmsg_data(nlmsg_hdr(msg));
+	char *alpha2;
+	struct nlattr *nl_rule;
+	int rem_rule;
+	static struct nla_policy reg_rule_policy[NL80211_FREQUENCY_ATTR_MAX + 1] = {
+		[NL80211_ATTR_REG_RULE_FLAGS]           = { .type = NLA_U32 },
+		[NL80211_ATTR_FREQ_RANGE_START]         = { .type = NLA_U32 },
+		[NL80211_ATTR_FREQ_RANGE_END]           = { .type = NLA_U32 },
+		[NL80211_ATTR_FREQ_RANGE_MAX_BW]        = { .type = NLA_U32 },
+		[NL80211_ATTR_POWER_RULE_MAX_ANT_GAIN]  = { .type = NLA_U32 },
+		[NL80211_ATTR_POWER_RULE_MAX_EIRP]      = { .type = NLA_U32 },
+	};
+
+	nla_parse(tb_msg, NL80211_ATTR_MAX, genlmsg_attrdata(gnlh, 0),
+		genlmsg_attrlen(gnlh, 0), NULL);
+
+	if (!tb_msg[NL80211_ATTR_REG_ALPHA2]) {
+		printf("No alpha2\n");
+		return NL_SKIP;
+	}
+
+	if (!tb_msg[NL80211_ATTR_REG_RULES]) {
+		printf("No reg rules\n");
+		return NL_SKIP;
+	}
+
+	alpha2 = nla_data(tb_msg[NL80211_ATTR_REG_ALPHA2]);
+	printf("country %s:\n", alpha2);
+
+	nla_for_each_nested(nl_rule, tb_msg[NL80211_ATTR_REG_RULES], rem_rule) {
+		struct nlattr *tb_rule[NL80211_FREQUENCY_ATTR_MAX + 1];
+		__u32 flags, start_freq_khz, end_freq_khz, max_bw_khz, max_ant_gain_mbi, max_eirp_mbm;
+
+		nla_parse(tb_rule, NL80211_FREQUENCY_ATTR_MAX, nla_data(nl_rule), nla_len(nl_rule), reg_rule_policy);
+
+		flags = nla_get_u32(tb_rule[NL80211_ATTR_REG_RULE_FLAGS]);
+		start_freq_khz = nla_get_u32(tb_rule[NL80211_ATTR_FREQ_RANGE_START]);
+		end_freq_khz = nla_get_u32(tb_rule[NL80211_ATTR_FREQ_RANGE_END]);
+		max_bw_khz = nla_get_u32(tb_rule[NL80211_ATTR_FREQ_RANGE_MAX_BW]);
+		max_ant_gain_mbi = nla_get_u32(tb_rule[NL80211_ATTR_POWER_RULE_MAX_ANT_GAIN]);
+		max_eirp_mbm = nla_get_u32(tb_rule[NL80211_ATTR_POWER_RULE_MAX_EIRP]);
+
+
+		printf("\t(%d - %d @ %d), (",
+			KHZ_TO_MHZ(start_freq_khz), KHZ_TO_MHZ(end_freq_khz), KHZ_TO_MHZ(max_bw_khz));
+
+		if (MBI_TO_DBI(max_ant_gain_mbi))
+			printf("%d", MBI_TO_DBI(max_ant_gain_mbi));
+		else
+			printf("N/A");
+
+		printf(", %d)", MBM_TO_DBM(max_eirp_mbm));
+
+		if (!flags) {
+			printf("\n");
+			continue;
+		}
+
+		/* Sync this output format to match that of dbparse.py from wireless-regdb.git */
+		PARSE_FLAG(NL80211_RRF_NO_OFDM, "NO-OFDM");
+		PARSE_FLAG(NL80211_RRF_NO_CCK, "NO-CCK");
+		PARSE_FLAG(NL80211_RRF_NO_INDOOR, "NO-INDOOR");
+		PARSE_FLAG(NL80211_RRF_NO_OUTDOOR, "NO-OUTDOOR");
+		PARSE_FLAG(NL80211_RRF_DFS, "DFS");
+		PARSE_FLAG(NL80211_RRF_PTP_ONLY, "PTP-ONLY");
+		PARSE_FLAG(NL80211_RRF_PASSIVE_SCAN, "PASSIVE-SCAN");
+		PARSE_FLAG(NL80211_RRF_NO_IBSS, "NO-IBSS");
+
+		printf("\n");
+	}
+	return NL_OK;
+#undef PARSE_FLAG
+}
+
+static int handle_reg_get(struct nl80211_state *state,
+			  struct nl_cb *cb,
+			  struct nl_msg *msg,
+			  int argc, char **argv)
+{
+	nl_cb_set(cb, NL_CB_VALID, NL_CB_CUSTOM, print_reg_handler, NULL);
+	return 0;
+}
+COMMAND(reg, get, NULL, NL80211_CMD_GET_REG, 0, CIB_NONE, handle_reg_get,
+	"Print out the kernel's current regulatory domain information.");
diff --git a/external/iw/scan.c b/external/iw/scan.c
new file mode 100644
index 0000000..486a70e
--- /dev/null
+++ b/external/iw/scan.c
@@ -0,0 +1,1227 @@
+#include <net/if.h>
+#include <errno.h>
+#include <string.h>
+#include <ctype.h>
+#include <stdbool.h>
+
+#include <netlink/genl/genl.h>
+#include <netlink/genl/family.h>
+#include <netlink/genl/ctrl.h>
+#include <netlink/msg.h>
+#include <netlink/attr.h>
+
+#include "nl80211.h"
+#include "iw.h"
+
+#define WLAN_CAPABILITY_ESS		(1<<0)
+#define WLAN_CAPABILITY_IBSS		(1<<1)
+#define WLAN_CAPABILITY_CF_POLLABLE	(1<<2)
+#define WLAN_CAPABILITY_CF_POLL_REQUEST	(1<<3)
+#define WLAN_CAPABILITY_PRIVACY		(1<<4)
+#define WLAN_CAPABILITY_SHORT_PREAMBLE	(1<<5)
+#define WLAN_CAPABILITY_PBCC		(1<<6)
+#define WLAN_CAPABILITY_CHANNEL_AGILITY	(1<<7)
+#define WLAN_CAPABILITY_SPECTRUM_MGMT	(1<<8)
+#define WLAN_CAPABILITY_QOS		(1<<9)
+#define WLAN_CAPABILITY_SHORT_SLOT_TIME	(1<<10)
+#define WLAN_CAPABILITY_APSD		(1<<11)
+#define WLAN_CAPABILITY_DSSS_OFDM	(1<<13)
+
+static unsigned char wifi_oui[3]      = { 0x00, 0x50, 0xf2 };
+static unsigned char ieee80211_oui[3] = { 0x00, 0x0f, 0xac };
+
+struct scan_params {
+	bool unknown;
+	enum print_ie_type type;
+	bool show_both_ie_sets;
+};
+
+#define IEEE80211_COUNTRY_EXTENSION_ID 201
+
+union ieee80211_country_ie_triplet {
+	struct {
+		__u8 first_channel;
+		__u8 num_channels;
+		__s8 max_power;
+	} __attribute__ ((packed)) chans;
+	struct {
+		__u8 reg_extension_id;
+		__u8 reg_class;
+		__u8 coverage_class;
+	} __attribute__ ((packed)) ext;
+} __attribute__ ((packed));
+
+static int handle_scan(struct nl80211_state *state,
+		       struct nl_cb *cb,
+		       struct nl_msg *msg,
+		       int argc, char **argv)
+{
+	struct nl_msg *ssids = NULL, *freqs = NULL;
+	char *eptr;
+	int err = -ENOBUFS;
+	int i;
+	enum {
+		NONE,
+		FREQ,
+		IES,
+		SSID,
+		DONE,
+	} parse = NONE;
+	int freq;
+	bool passive = false, have_ssids = false, have_freqs = false;
+	size_t tmp;
+	unsigned char *ies;
+
+	ssids = nlmsg_alloc();
+	if (!ssids)
+		return -ENOMEM;
+
+	freqs = nlmsg_alloc();
+	if (!freqs) {
+		nlmsg_free(ssids);
+		return -ENOMEM;
+	}
+
+	for (i = 0; i < argc; i++) {
+		switch (parse) {
+		case NONE:
+			if (strcmp(argv[i], "freq") == 0) {
+				parse = FREQ;
+				have_freqs = true;
+				break;
+			} else if (strcmp(argv[i], "ies") == 0) {
+				parse = IES;
+				break;
+			} else if (strcmp(argv[i], "ssid") == 0) {
+				parse = SSID;
+				have_ssids = true;
+				break;
+			} else if (strcmp(argv[i], "passive") == 0) {
+				parse = DONE;
+				passive = true;
+				break;
+			}
+		case DONE:
+			return 1;
+		case FREQ:
+			freq = strtoul(argv[i], &eptr, 10);
+			if (eptr != argv[i] + strlen(argv[i]))
+				return 1;
+			NLA_PUT_U32(freqs, i, freq);
+			parse = NONE;
+			break;
+		case IES:
+			ies = parse_hex(argv[i], &tmp);
+			if (!ies)
+				goto nla_put_failure;
+			NLA_PUT(msg, NL80211_ATTR_IE, tmp, ies);
+			free(ies);
+			parse = NONE;
+			break;
+		case SSID:
+			NLA_PUT(ssids, i, strlen(argv[i]), argv[i]);
+			break;
+		}
+	}
+
+	if (!have_ssids)
+		NLA_PUT(ssids, 1, 0, "");
+	if (!passive)
+		nla_put_nested(msg, NL80211_ATTR_SCAN_SSIDS, ssids);
+
+	if (have_freqs)
+		nla_put_nested(msg, NL80211_ATTR_SCAN_FREQUENCIES, freqs);
+
+	err = 0;
+ nla_put_failure:
+	nlmsg_free(ssids);
+	nlmsg_free(freqs);
+	return err;
+}
+
+static void tab_on_first(bool *first)
+{
+	if (!*first)
+		printf("\t");
+	else
+		*first = false;
+}
+
+static void print_ssid(const uint8_t type, uint8_t len, const uint8_t *data)
+{
+	printf(" ");
+	print_ssid_escaped(len, data);
+	printf("\n");
+}
+
+static void print_supprates(const uint8_t type, uint8_t len, const uint8_t *data)
+{
+	int i;
+
+	printf(" ");
+
+	for (i = 0; i < len; i++) {
+		int r = data[i] & 0x7f;
+		printf("%d.%d%s ", r/2, 5*(r&1), data[i] & 0x80 ? "*":"");
+	}
+	printf("\n");
+}
+
+static void print_ds(const uint8_t type, uint8_t len, const uint8_t *data)
+{
+	printf(" channel %d\n", data[0]);
+}
+
+static const char *country_env_str(char environment)
+{
+	switch (environment) {
+	case 'I':
+		return "Indoor only";
+	case 'O':
+		return "Outdoor only";
+	case ' ':
+		return "Indoor/Outdoor";
+	default:
+		return "bogus";
+	}
+}
+
+static void print_country(const uint8_t type, uint8_t len, const uint8_t *data)
+{
+	printf(" %.*s", 2, data);
+
+	printf("\tEnvironment: %s\n", country_env_str(data[2]));
+
+	data += 3;
+	len -= 3;
+
+	if (len < 3) {
+		printf("\t\tNo country IE triplets present\n");
+		return;
+	}
+
+	while (len >= 3) {
+		int end_channel;
+		union ieee80211_country_ie_triplet *triplet = (void *) data;
+
+		if (triplet->ext.reg_extension_id >= IEEE80211_COUNTRY_EXTENSION_ID) {
+			printf("\t\tExtension ID: %d Regulatory Class: %d Coverage class: %d (up to %dm)\n",
+			       triplet->ext.reg_extension_id,
+			       triplet->ext.reg_class,
+			       triplet->ext.coverage_class,
+			       triplet->ext.coverage_class * 450);
+
+			data += 3;
+			len -= 3;
+			continue;
+		}
+
+		/* 2 GHz */
+		if (triplet->chans.first_channel <= 14)
+			end_channel = triplet->chans.first_channel + (triplet->chans.num_channels - 1);
+		else
+			end_channel =  triplet->chans.first_channel + (4 * (triplet->chans.num_channels - 1));
+
+		printf("\t\tChannels [%d - %d] @ %d dBm\n", triplet->chans.first_channel, end_channel, triplet->chans.max_power);
+
+		data += 3;
+		len -= 3;
+	}
+
+	return;
+}
+
+static void print_powerconstraint(const uint8_t type, uint8_t len, const uint8_t *data)
+{
+	printf(" %d dB\n", data[0]);
+}
+
+static void print_erp(const uint8_t type, uint8_t len, const uint8_t *data)
+{
+	if (data[0] == 0x00)
+		printf(" <no flags>");
+	if (data[0] & 0x01)
+		printf(" NonERP_Present");
+	if (data[0] & 0x02)
+		printf(" Use_Protection");
+	if (data[0] & 0x04)
+		printf(" Barker_Preamble_Mode");
+	printf("\n");
+}
+
+static void print_cipher(const uint8_t *data)
+{
+	if (memcmp(data, wifi_oui, 3) == 0) {
+		switch (data[3]) {
+		case 0:
+			printf("Use group cipher suite");
+			break;
+		case 1:
+			printf("WEP-40");
+			break;
+		case 2:
+			printf("TKIP");
+			break;
+		case 4:
+			printf("CCMP");
+			break;
+		case 5:
+			printf("WEP-104");
+			break;
+		default:
+			printf("%.02x-%.02x-%.02x:%d",
+				data[0], data[1] ,data[2], data[3]);
+			break;
+		}
+	} else if (memcmp(data, ieee80211_oui, 3) == 0) {
+		switch (data[3]) {
+		case 0:
+			printf("Use group cipher suite");
+			break;
+		case 1:
+			printf("WEP-40");
+			break;
+		case 2:
+			printf("TKIP");
+			break;
+		case 4:
+			printf("CCMP");
+			break;
+		case 5:
+			printf("WEP-104");
+			break;
+		case 6:
+			printf("AES-128-CMAC");
+			break;
+		default:
+			printf("%.02x-%.02x-%.02x:%d",
+				data[0], data[1] ,data[2], data[3]);
+			break;
+		}
+	} else
+		printf("%.02x-%.02x-%.02x:%d",
+			data[0], data[1] ,data[2], data[3]);
+}
+
+static void print_auth(const uint8_t *data)
+{
+	if (memcmp(data, wifi_oui, 3) == 0) {
+		switch (data[3]) {
+		case 1:
+			printf("IEEE 802.1X");
+			break;
+		case 2:
+			printf("PSK");
+			break;
+		default:
+			printf("%.02x-%.02x-%.02x:%d",
+				data[0], data[1] ,data[2], data[3]);
+			break;
+		}
+	} else if (memcmp(data, ieee80211_oui, 3) == 0) {
+		switch (data[3]) {
+		case 1:
+			printf("IEEE 802.1X");
+			break;
+		case 2:
+			printf("PSK");
+			break;
+		case 3:
+			printf("FT/IEEE 802.1X");
+			break;
+		case 4:
+			printf("FT/PSK");
+			break;
+		case 5:
+			printf("IEEE 802.1X/SHA-256");
+			break;
+		case 6:
+			printf("PSK/SHA-256");
+			break;
+		default:
+			printf("%.02x-%.02x-%.02x:%d",
+				data[0], data[1] ,data[2], data[3]);
+			break;
+		}
+	} else
+		printf("%.02x-%.02x-%.02x:%d",
+			data[0], data[1] ,data[2], data[3]);
+}
+
+static void print_rsn_ie(const char *defcipher, const char *defauth,
+			 uint8_t len, const uint8_t *data)
+{
+	bool first = true;
+	__u16 version, count, capa;
+	int i;
+
+	version = data[0] + (data[1] << 8);
+	tab_on_first(&first);
+	printf("\t * Version: %d\n", version);
+
+	data += 2;
+	len -= 2;
+
+	if (len < 4) {
+		tab_on_first(&first);
+		printf("\t * Group cipher: %s\n", defcipher);
+		printf("\t * Pairwise ciphers: %s\n", defcipher);
+		return;
+	}
+
+	tab_on_first(&first);
+	printf("\t * Group cipher: ");
+	print_cipher(data);
+	printf("\n");
+
+	data += 4;
+	len -= 4;
+
+	if (len < 2) {
+		tab_on_first(&first);
+		printf("\t * Pairwise ciphers: %s\n", defcipher);
+		return;
+	}
+
+	count = data[0] | (data[1] << 8);
+	if (2 + (count * 4) > len)
+		goto invalid;
+
+	tab_on_first(&first);
+	printf("\t * Pairwise ciphers:");
+	for (i = 0; i < count; i++) {
+		printf(" ");
+		print_cipher(data + 2 + (i * 4));
+	}
+	printf("\n");
+
+	data += 2 + (count * 4);
+	len -= 2 + (count * 4);
+
+	if (len < 2) {
+		tab_on_first(&first);
+		printf("\t * Authentication suites: %s\n", defauth);
+		return;
+	}
+
+	count = data[0] | (data[1] << 8);
+	if (2 + (count * 4) > len)
+		goto invalid;
+
+	tab_on_first(&first);
+	printf("\t * Authentication suites:");
+	for (i = 0; i < count; i++) {
+		printf(" ");
+		print_auth(data + 2 + (i * 4));
+	}
+	printf("\n");
+
+	data += 2 + (count * 4);
+	len -= 2 + (count * 4);
+
+	if (len >= 2) {
+		capa = data[0] | (data[1] << 8);
+		tab_on_first(&first);
+		printf("\t * Capabilities:");
+		if (capa & 0x0001)
+			printf(" PreAuth");
+		if (capa & 0x0002)
+			printf(" NoPairwise");
+		switch ((capa & 0x000c) >> 2) {
+		case 0:
+			break;
+		case 1:
+			printf(" 2-PTKSA-RC");
+			break;
+		case 2:
+			printf(" 4-PTKSA-RC");
+			break;
+		case 3:
+			printf(" 16-PTKSA-RC");
+			break;
+		}
+		switch ((capa & 0x0030) >> 4) {
+		case 0:
+			break;
+		case 1:
+			printf(" 2-GTKSA-RC");
+			break;
+		case 2:
+			printf(" 4-GTKSA-RC");
+			break;
+		case 3:
+			printf(" 16-GTKSA-RC");
+			break;
+		}
+		if (capa & 0x0040)
+			printf(" MFP-required");
+		if (capa & 0x0080)
+			printf(" MFP-capable");
+		if (capa & 0x0200)
+			printf(" Peerkey-enabled");
+		if (capa & 0x0400)
+			printf(" SPP-AMSDU-capable");
+		if (capa & 0x0800)
+			printf(" SPP-AMSDU-required");
+		printf(" (0x%.4x)\n", capa);
+		data += 2;
+		len -= 2;
+	}
+
+	if (len >= 2) {
+		int pmkid_count = data[0] | (data[1] << 8);
+
+		if (len >= 2 + 16 * pmkid_count) {
+			tab_on_first(&first);
+			printf("\t * %d PMKIDs\n", pmkid_count);
+			/* not printing PMKID values */
+			data += 2 + 16 * pmkid_count;
+			len -= 2 + 16 * pmkid_count;
+		} else
+			goto invalid;
+	}
+
+	if (len >= 4) {
+		tab_on_first(&first);
+		printf("\t * Group mgmt cipher suite: ");
+		print_cipher(data);
+		printf("\n");
+		data += 4;
+		len -= 4;
+	}
+
+ invalid:
+	if (len != 0) {
+		printf("\t\t * bogus tail data (%d):", len);
+		while (len) {
+			printf(" %.2x", *data);
+			data++;
+			len--;
+		}
+		printf("\n");
+	}
+}
+
+static void print_rsn(const uint8_t type, uint8_t len, const uint8_t *data)
+{
+	print_rsn_ie("CCMP", "IEEE 802.1X", len, data);
+}
+
+static void print_ht_capa(const uint8_t type, uint8_t len, const uint8_t *data)
+{
+	printf("\n");
+	print_ht_capability(data[0] | (data[1] << 8));
+	print_ampdu_length(data[2] & 3);
+	print_ampdu_spacing((data[2] >> 2) & 7);
+	print_ht_mcs(data + 3);
+}
+
+static void print_ht_op(const uint8_t type, uint8_t len, const uint8_t *data)
+{
+	static const char *offset[4] = {
+		"no secondary",
+		"above",
+		"[reserved!]",
+		"below",
+	};
+	static const char *protection[4] = {
+		"no",
+		"nonmember",
+		"20 MHz",
+		"non-HT mixed",
+	};
+	static const char *sta_chan_width[2] = {
+		"20 MHz",
+		"any",
+	};
+
+	printf("\n");
+	printf("\t\t * primary channel: %d\n", data[0]);
+	printf("\t\t * secondary channel offset: %s\n",
+		offset[data[1] & 0x3]);
+	printf("\t\t * STA channel width: %s\n", sta_chan_width[(data[1] & 0x4)>>2]);
+	printf("\t\t * RIFS: %d\n", (data[1] & 0x8)>>3);
+	printf("\t\t * HT protection: %s\n", protection[data[2] & 0x3]);
+	printf("\t\t * non-GF present: %d\n", (data[2] & 0x4) >> 2);
+	printf("\t\t * OBSS non-GF present: %d\n", (data[2] & 0x10) >> 4);
+	printf("\t\t * dual beacon: %d\n", (data[4] & 0x40) >> 6);
+	printf("\t\t * dual CTS protection: %d\n", (data[4] & 0x80) >> 7);
+	printf("\t\t * STBC beacon: %d\n", data[5] & 0x1);
+	printf("\t\t * L-SIG TXOP Prot: %d\n", (data[5] & 0x2) >> 1);
+	printf("\t\t * PCO active: %d\n", (data[5] & 0x4) >> 2);
+	printf("\t\t * PCO phase: %d\n", (data[5] & 0x8) >> 3);
+}
+
+static void print_capabilities(const uint8_t type, uint8_t len, const uint8_t *data)
+{
+	int i, base, bit;
+	bool first = true;
+
+
+	for (i = 0; i < len; i++) {
+		base = i * 8;
+
+		for (bit = 0; bit < 8; bit++) {
+			if (!(data[i] & (1 << bit)))
+				continue;
+
+			if (!first)
+				printf(",");
+			else
+				first = false;
+
+			switch (bit + base) {
+			case 0:
+				printf(" HT Information Exchange Supported");
+				break;
+			case 1:
+				printf(" On-demand Beacon");
+				break;
+			case 2:
+				printf(" Extended Channel Switching");
+				break;
+			case 3:
+				printf(" Wave Indication");
+				break;
+			case 4:
+				printf(" PSMP Capability");
+				break;
+			case 5:
+				printf(" Service Interval Granularity");
+				break;
+			case 6:
+				printf(" S-PSMP Capability");
+				break;
+			default:
+				printf(" %d", bit);
+				break;
+			}
+		}
+	}
+
+	printf("\n");
+}
+
+static void print_tim(const uint8_t type, uint8_t len, const uint8_t *data)
+{
+	printf(" DTIM Count %u DTIM Period %u Bitmap Control 0x%x "
+	       "Bitmap[0] 0x%x",
+	       data[0], data[1], data[2], data[3]);
+	if (len - 4)
+		printf(" (+ %u octet%s)", len - 4, len - 4 == 1 ? "" : "s");
+	printf("\n");
+}
+
+struct ie_print {
+	const char *name;
+	void (*print)(const uint8_t type, uint8_t len, const uint8_t *data);
+	uint8_t minlen, maxlen;
+	uint8_t flags;
+};
+
+static void print_ie(const struct ie_print *p, const uint8_t type,
+		     uint8_t len, const uint8_t *data)
+{
+	int i;
+
+	if (!p->print)
+		return;
+
+	printf("\t%s:", p->name);
+	if (len < p->minlen || len > p->maxlen) {
+		if (len > 1) {
+			printf(" <invalid: %d bytes:", len);
+			for (i = 0; i < len; i++)
+				printf(" %.02x", data[i]);
+			printf(">\n");
+		} else if (len)
+			printf(" <invalid: 1 byte: %.02x>\n", data[0]);
+		else
+			printf(" <invalid: no data>\n");
+		return;
+	}
+
+	p->print(type, len, data);
+}
+
+#define PRINT_IGN {		\
+	.name = "IGNORE",	\
+	.print = NULL,		\
+	.minlen = 0,		\
+	.maxlen = 255,		\
+}
+
+static const struct ie_print ieprinters[] = {
+	[0] = { "SSID", print_ssid, 0, 32, BIT(PRINT_SCAN) | BIT(PRINT_LINK), },
+	[1] = { "Supported rates", print_supprates, 0, 255, BIT(PRINT_SCAN), },
+	[3] = { "DS Parameter set", print_ds, 1, 1, BIT(PRINT_SCAN), },
+	[5] = { "TIM", print_tim, 4, 255, BIT(PRINT_SCAN), },
+	[7] = { "Country", print_country, 3, 255, BIT(PRINT_SCAN), },
+	[32] = { "Power constraint", print_powerconstraint, 1, 1, BIT(PRINT_SCAN), },
+	[42] = { "ERP", print_erp, 1, 255, BIT(PRINT_SCAN), },
+	[45] = { "HT capabilities", print_ht_capa, 26, 26, BIT(PRINT_SCAN), },
+	[61] = { "HT operation", print_ht_op, 22, 22, BIT(PRINT_SCAN), },
+	[48] = { "RSN", print_rsn, 2, 255, BIT(PRINT_SCAN), },
+	[50] = { "Extended supported rates", print_supprates, 0, 255, BIT(PRINT_SCAN), },
+	[127] = { "Extended capabilities", print_capabilities, 0, 255, BIT(PRINT_SCAN), },
+};
+
+static void print_wifi_wpa(const uint8_t type, uint8_t len, const uint8_t *data)
+{
+	print_rsn_ie("TKIP", "IEEE 802.1X", len, data);
+}
+
+static bool print_wifi_wmm_param(const uint8_t *data, uint8_t len)
+{
+	int i;
+	static const char *aci_tbl[] = { "BE", "BK", "VI", "VO" };
+
+	if (len < 19)
+		goto invalid;
+
+	if (data[0] != 1) {
+		printf("Parameter: not version 1: ");
+		return false;
+	}
+
+	printf("\t * Parameter version 1");
+
+	data++;
+
+	if (data[0] & 0x80)
+		printf("\n\t\t * u-APSD");
+
+	data += 2;
+
+	for (i = 0; i < 4; i++) {
+		printf("\n\t\t * %s:", aci_tbl[(data[0] >> 5) & 3]);
+		if (data[4] & 0x10)
+			printf(" acm");
+		printf(" CW %d-%d", (1 << (data[1] & 0xf)) - 1,
+				    (1 << (data[1] >> 4)) - 1);
+		printf(", AIFSN %d", data[0] & 0xf);
+		if (data[2] | data[3])
+			printf(", TXOP %d usec", (data[2] + (data[3] << 8)) * 32);
+		data += 4;
+	}
+
+	printf("\n");
+	return true;
+
+ invalid:
+ 	printf("invalid: ");
+ 	return false;
+}
+
+static void print_wifi_wmm(const uint8_t type, uint8_t len, const uint8_t *data)
+{
+	int i;
+
+	switch (data[0]) {
+	case 0x00:
+		printf(" information:");
+		break;
+	case 0x01:
+		if (print_wifi_wmm_param(data + 1, len - 1))
+			return;
+		break;
+	default:
+		printf(" type %d:", data[0]);
+		break;
+	}
+
+	for(i = 1; i < len; i++)
+		printf(" %.02x", data[i]);
+	printf("\n");
+}
+
+static const char * wifi_wps_dev_passwd_id(uint16_t id)
+{
+	switch (id) {
+	case 0:
+		return "Default (PIN)";
+	case 1:
+		return "User-specified";
+	case 2:
+		return "Machine-specified";
+	case 3:
+		return "Rekey";
+	case 4:
+		return "PushButton";
+	case 5:
+		return "Registrar-specified";
+	default:
+		return "??";
+	}
+}
+
+static void print_wifi_wps(const uint8_t type, uint8_t len, const uint8_t *data)
+{
+	bool first = true;
+	__u16 subtype, sublen;
+
+	while (len >= 4) {
+		subtype = (data[0] << 8) + data[1];
+		sublen = (data[2] << 8) + data[3];
+		if (sublen > len)
+			break;
+
+		switch (subtype) {
+		case 0x104a:
+			tab_on_first(&first);
+			printf("\t * Version: %d.%d\n", data[4] >> 4, data[4] & 0xF);
+			break;
+		case 0x1011:
+			tab_on_first(&first);
+			printf("\t * Device name: %.*s\n", sublen, data + 4);
+			break;
+		case 0x1012: {
+			uint16_t id;
+			tab_on_first(&first);
+			if (sublen != 2) {
+				printf("\t * Device Password ID: (invalid "
+				       "length %d)\n", sublen);
+				break;
+			}
+			id = data[4] << 8 | data[5];
+			printf("\t * Device Password ID: %u (%s)\n",
+			       id, wifi_wps_dev_passwd_id(id));
+			break;
+		}
+		case 0x1021:
+			tab_on_first(&first);
+			printf("\t * Manufacturer: %.*s\n", sublen, data + 4);
+			break;
+		case 0x1023:
+			tab_on_first(&first);
+			printf("\t * Model: %.*s\n", sublen, data + 4);
+			break;
+		case 0x1024:
+			tab_on_first(&first);
+			printf("\t * Model Number: %.*s\n", sublen, data + 4);
+			break;
+		case 0x103b: {
+			__u8 val = data[4];
+			tab_on_first(&first);
+			printf("\t * Response Type: %d%s\n",
+			       val, val == 3 ? " (AP)" : "");
+			break;
+		}
+		case 0x103c: {
+			__u8 val = data[4];
+			tab_on_first(&first);
+			printf("\t * RF Bands: 0x%x\n", val);
+			break;
+		}
+		case 0x1041: {
+			__u8 val = data[4];
+			tab_on_first(&first);
+			printf("\t * Selected Registrar: 0x%x\n", val);
+			break;
+		}
+		case 0x1042:
+			tab_on_first(&first);
+			printf("\t * Serial Number: %.*s\n", sublen, data + 4);
+			break;
+		case 0x1044: {
+			__u8 val = data[4];
+			tab_on_first(&first);
+			printf("\t * Wi-Fi Protected Setup State: %d%s%s\n",
+			       val,
+			       val == 1 ? " (Unconfigured)" : "",
+			       val == 2 ? " (Configured)" : "");
+			break;
+		}
+		case 0x1054: {
+			tab_on_first(&first);
+			if (sublen != 8) {
+				printf("\t * Primary Device Type: (invalid "
+				       "length %d)\n", sublen);
+				break;
+			}
+			printf("\t * Primary Device Type: "
+			       "%u-%02x%02x%02x%02x-%u\n",
+			       data[4] << 8 | data[5],
+			       data[6], data[7], data[8], data[9],
+			       data[10] << 8 | data[11]);
+			break;
+		}
+		case 0x1057: {
+			__u8 val = data[4];
+			tab_on_first(&first);
+			printf("\t * AP setup locked: 0x%.2x\n", val);
+			break;
+		}
+		case 0x1008:
+		case 0x1053: {
+			__u16 meth = (data[4] << 8) + data[5];
+			bool comma = false;
+			tab_on_first(&first);
+			printf("\t * %sConfig methods:",
+			       subtype == 0x1053 ? "Selected Registrar ": "");
+#define T(bit, name) do {		\
+	if (meth & (1<<bit)) {		\
+		if (comma)		\
+			printf(",");	\
+		comma = true;		\
+		printf(" " name);	\
+	} } while (0)
+			T(0, "USB");
+			T(1, "Ethernet");
+			T(2, "Label");
+			T(3, "Display");
+			T(4, "Ext. NFC");
+			T(5, "Int. NFC");
+			T(6, "NFC Intf.");
+			T(7, "PBC");
+			T(8, "Keypad");
+			printf("\n");
+			break;
+#undef T
+		}
+		default: {
+			const __u8 *subdata = data + 4;
+			__u16 tmplen = sublen;
+
+			tab_on_first(&first);
+			printf("\t * Unknown TLV (%#.4x, %d bytes):",
+			       subtype, tmplen);
+			while (tmplen) {
+				printf(" %.2x", *subdata);
+				subdata++;
+				tmplen--;
+			}
+			printf("\n");
+			break;
+		}
+		}
+
+		data += sublen + 4;
+		len -= sublen + 4;
+	}
+
+	if (len != 0) {
+		printf("\t\t * bogus tail data (%d):", len);
+		while (len) {
+			printf(" %.2x", *data);
+			data++;
+			len--;
+		}
+		printf("\n");
+	}
+}
+
+static const struct ie_print wifiprinters[] = {
+	[1] = { "WPA", print_wifi_wpa, 2, 255, BIT(PRINT_SCAN), },
+	[2] = { "WMM", print_wifi_wmm, 1, 255, BIT(PRINT_SCAN), },
+	[4] = { "WPS", print_wifi_wps, 0, 255, BIT(PRINT_SCAN), },
+};
+
+static void print_vendor(unsigned char len, unsigned char *data,
+			 bool unknown, enum print_ie_type ptype)
+{
+	int i;
+
+	if (len < 3) {
+		printf("\tVendor specific: <too short> data:");
+		for(i = 0; i < len; i++)
+			printf(" %.02x", data[i]);
+		printf("\n");
+		return;
+	}
+
+	if (len >= 4 && memcmp(data, wifi_oui, 3) == 0) {
+		if (data[3] < ARRAY_SIZE(wifiprinters) &&
+		    wifiprinters[data[3]].name &&
+		    wifiprinters[data[3]].flags & BIT(ptype)) {
+			print_ie(&wifiprinters[data[3]], data[3], len - 4, data + 4);
+			return;
+		}
+		if (!unknown)
+			return;
+		printf("\tWiFi OUI %#.2x, data:", data[3]);
+		for(i = 0; i < len - 4; i++)
+			printf(" %.02x", data[i + 4]);
+		printf("\n");
+		return;
+	}
+
+	if (!unknown)
+		return;
+
+	printf("\tVendor specific: OUI %.2x:%.2x:%.2x, data:",
+		data[0], data[1], data[2]);
+	for (i = 3; i < len; i++)
+		printf(" %.2x", data[i]);
+	printf("\n");
+}
+
+void print_ies(unsigned char *ie, int ielen, bool unknown,
+	       enum print_ie_type ptype)
+{
+	while (ielen >= 2 && ielen >= ie[1]) {
+		if (ie[0] < ARRAY_SIZE(ieprinters) &&
+		    ieprinters[ie[0]].name &&
+		    ieprinters[ie[0]].flags & BIT(ptype)) {
+			print_ie(&ieprinters[ie[0]], ie[0], ie[1], ie + 2);
+		} else if (ie[0] == 221 /* vendor */) {
+			print_vendor(ie[1], ie + 2, unknown, ptype);
+		} else if (unknown) {
+			int i;
+
+			printf("\tUnknown IE (%d):", ie[0]);
+			for (i=0; i<ie[1]; i++)
+				printf(" %.2x", ie[2+i]);
+			printf("\n");
+		}
+		ielen -= ie[1] + 2;
+		ie += ie[1] + 2;
+	}
+}
+
+static int print_bss_handler(struct nl_msg *msg, void *arg)
+{
+	struct nlattr *tb[NL80211_ATTR_MAX + 1];
+	struct genlmsghdr *gnlh = nlmsg_data(nlmsg_hdr(msg));
+	struct nlattr *bss[NL80211_BSS_MAX + 1];
+	char mac_addr[20], dev[20];
+	static struct nla_policy bss_policy[NL80211_BSS_MAX + 1] = {
+		[NL80211_BSS_TSF] = { .type = NLA_U64 },
+		[NL80211_BSS_FREQUENCY] = { .type = NLA_U32 },
+		[NL80211_BSS_BSSID] = { },
+		[NL80211_BSS_BEACON_INTERVAL] = { .type = NLA_U16 },
+		[NL80211_BSS_CAPABILITY] = { .type = NLA_U16 },
+		[NL80211_BSS_INFORMATION_ELEMENTS] = { },
+		[NL80211_BSS_SIGNAL_MBM] = { .type = NLA_U32 },
+		[NL80211_BSS_SIGNAL_UNSPEC] = { .type = NLA_U8 },
+		[NL80211_BSS_STATUS] = { .type = NLA_U32 },
+		[NL80211_BSS_SEEN_MS_AGO] = { .type = NLA_U32 },
+		[NL80211_BSS_BEACON_IES] = { },
+	};
+	struct scan_params *params = arg;
+	int show = params->show_both_ie_sets ? 2 : 1;
+
+	nla_parse(tb, NL80211_ATTR_MAX, genlmsg_attrdata(gnlh, 0),
+		  genlmsg_attrlen(gnlh, 0), NULL);
+
+	if (!tb[NL80211_ATTR_BSS]) {
+		fprintf(stderr, "bss info missing!\n");
+		return NL_SKIP;
+	}
+	if (nla_parse_nested(bss, NL80211_BSS_MAX,
+			     tb[NL80211_ATTR_BSS],
+			     bss_policy)) {
+		fprintf(stderr, "failed to parse nested attributes!\n");
+		return NL_SKIP;
+	}
+
+	if (!bss[NL80211_BSS_BSSID])
+		return NL_SKIP;
+
+	mac_addr_n2a(mac_addr, nla_data(bss[NL80211_BSS_BSSID]));
+	if_indextoname(nla_get_u32(tb[NL80211_ATTR_IFINDEX]), dev);
+	printf("BSS %s (on %s)", mac_addr, dev);
+
+	if (bss[NL80211_BSS_STATUS]) {
+		switch (nla_get_u32(bss[NL80211_BSS_STATUS])) {
+		case NL80211_BSS_STATUS_AUTHENTICATED:
+			printf(" -- authenticated");
+			break;
+		case NL80211_BSS_STATUS_ASSOCIATED:
+			printf(" -- associated");
+			break;
+		case NL80211_BSS_STATUS_IBSS_JOINED:
+			printf(" -- joined");
+			break;
+		default:
+			printf(" -- unknown status: %d",
+				nla_get_u32(bss[NL80211_BSS_STATUS]));
+			break;
+		}
+	}
+	printf("\n");
+
+	if (bss[NL80211_BSS_TSF]) {
+		unsigned long long tsf;
+		tsf = (unsigned long long)nla_get_u64(bss[NL80211_BSS_TSF]);
+		printf("\tTSF: %llu usec (%llud, %.2lld:%.2llu:%.2llu)\n",
+			tsf, tsf/1000/1000/60/60/24, (tsf/1000/1000/60/60) % 24,
+			(tsf/1000/1000/60) % 60, (tsf/1000/1000) % 60);
+	}
+	if (bss[NL80211_BSS_FREQUENCY])
+		printf("\tfreq: %d\n",
+			nla_get_u32(bss[NL80211_BSS_FREQUENCY]));
+	if (bss[NL80211_BSS_BEACON_INTERVAL])
+		printf("\tbeacon interval: %d\n",
+			nla_get_u16(bss[NL80211_BSS_BEACON_INTERVAL]));
+	if (bss[NL80211_BSS_CAPABILITY]) {
+		__u16 capa = nla_get_u16(bss[NL80211_BSS_CAPABILITY]);
+		printf("\tcapability:");
+		if (capa & WLAN_CAPABILITY_ESS)
+			printf(" ESS");
+		if (capa & WLAN_CAPABILITY_IBSS)
+			printf(" IBSS");
+		if (capa & WLAN_CAPABILITY_PRIVACY)
+			printf(" Privacy");
+		if (capa & WLAN_CAPABILITY_SHORT_PREAMBLE)
+			printf(" ShortPreamble");
+		if (capa & WLAN_CAPABILITY_PBCC)
+			printf(" PBCC");
+		if (capa & WLAN_CAPABILITY_CHANNEL_AGILITY)
+			printf(" ChannelAgility");
+		if (capa & WLAN_CAPABILITY_SPECTRUM_MGMT)
+			printf(" SpectrumMgmt");
+		if (capa & WLAN_CAPABILITY_QOS)
+			printf(" QoS");
+		if (capa & WLAN_CAPABILITY_SHORT_SLOT_TIME)
+			printf(" ShortSlotTime");
+		if (capa & WLAN_CAPABILITY_APSD)
+			printf(" APSD");
+		if (capa & WLAN_CAPABILITY_DSSS_OFDM)
+			printf(" DSSS-OFDM");
+		printf(" (0x%.4x)\n", capa);
+	}
+	if (bss[NL80211_BSS_SIGNAL_MBM]) {
+		int s = nla_get_u32(bss[NL80211_BSS_SIGNAL_MBM]);
+		printf("\tsignal: %d.%.2d dBm\n", s/100, s%100);
+	}
+	if (bss[NL80211_BSS_SIGNAL_UNSPEC]) {
+		unsigned char s = nla_get_u8(bss[NL80211_BSS_SIGNAL_UNSPEC]);
+		printf("\tsignal: %d/100\n", s);
+	}
+	if (bss[NL80211_BSS_SEEN_MS_AGO]) {
+		int age = nla_get_u32(bss[NL80211_BSS_SEEN_MS_AGO]);
+		printf("\tlast seen: %d ms ago\n", age);
+	}
+	
+	if (bss[NL80211_BSS_INFORMATION_ELEMENTS] && show--) {
+		if (bss[NL80211_BSS_BEACON_IES])
+			printf("\tInformation elements from Probe Response "
+			       "frame:\n");
+		print_ies(nla_data(bss[NL80211_BSS_INFORMATION_ELEMENTS]),
+			  nla_len(bss[NL80211_BSS_INFORMATION_ELEMENTS]),
+			  params->unknown, params->type);
+	}
+	if (bss[NL80211_BSS_BEACON_IES] && show--) {
+		printf("\tInformation elements from Beacon frame:\n");
+		print_ies(nla_data(bss[NL80211_BSS_BEACON_IES]),
+			  nla_len(bss[NL80211_BSS_BEACON_IES]),
+			  params->unknown, params->type);
+	}
+
+	return NL_SKIP;
+}
+
+static struct scan_params scan_params;
+
+static int handle_scan_dump(struct nl80211_state *state,
+			    struct nl_cb *cb,
+			    struct nl_msg *msg,
+			    int argc, char **argv)
+{
+	if (argc > 1)
+		return 1;
+
+	memset(&scan_params, 0, sizeof(scan_params));
+
+	if (argc == 1 && !strcmp(argv[0], "-u"))
+		scan_params.unknown = true;
+	else if (argc == 1 && !strcmp(argv[0], "-b"))
+		scan_params.show_both_ie_sets = true;
+
+	scan_params.type = PRINT_SCAN;
+
+	nl_cb_set(cb, NL_CB_VALID, NL_CB_CUSTOM, print_bss_handler,
+		  &scan_params);
+	return 0;
+}
+
+static int handle_scan_combined(struct nl80211_state *state,
+				struct nl_cb *cb,
+				struct nl_msg *msg,
+				int argc, char **argv)
+{
+	char **trig_argv;
+	static char *dump_argv[] = {
+		NULL,
+		"scan",
+		"dump",
+		NULL,
+	};
+	static const __u32 cmds[] = {
+		NL80211_CMD_NEW_SCAN_RESULTS,
+		NL80211_CMD_SCAN_ABORTED,
+	};
+	int trig_argc, dump_argc, err;
+
+	if (argc >= 3 && !strcmp(argv[2], "-u")) {
+		dump_argc = 4;
+		dump_argv[3] = "-u";
+	} else if (argc >= 3 && !strcmp(argv[2], "-b")) {
+		dump_argc = 4;
+		dump_argv[3] = "-b";
+	} else
+		dump_argc = 3;
+
+	trig_argc = 3 + (argc - 2) + (3 - dump_argc);
+	trig_argv = calloc(trig_argc, sizeof(*trig_argv));
+	if (!trig_argv)
+		return -ENOMEM;
+	trig_argv[0] = argv[0];
+	trig_argv[1] = "scan";
+	trig_argv[2] = "trigger";
+	int i;
+	for (i = 0; i < argc - 2 - (dump_argc - 3); i++)
+		trig_argv[i + 3] = argv[i + 2 + (dump_argc - 3)];
+	err = handle_cmd(state, II_NETDEV, trig_argc, trig_argv);
+	free(trig_argv);
+	if (err)
+		return err;
+
+	/*
+	 * WARNING: DO NOT COPY THIS CODE INTO YOUR APPLICATION
+	 *
+	 * This code has a bug, which requires creating a separate
+	 * nl80211 socket to fix:
+	 * It is possible for a NL80211_CMD_NEW_SCAN_RESULTS or
+	 * NL80211_CMD_SCAN_ABORTED message to be sent by the kernel
+	 * before (!) we listen to it, because we only start listening
+	 * after we send our scan request.
+	 *
+	 * Doing it the other way around has a race condition as well,
+	 * if you first open the events socket you may get a notification
+	 * for a previous scan.
+	 *
+	 * The only proper way to fix this would be to listen to events
+	 * before sending the command, and for the kernel to send the
+	 * scan request along with the event, so that you can match up
+	 * whether the scan you requested was finished or aborted (this
+	 * may result in processing a scan that another application
+	 * requested, but that doesn't seem to be a problem).
+	 *
+	 * Alas, the kernel doesn't do that (yet).
+	 */
+
+	if (listen_events(state, ARRAY_SIZE(cmds), cmds) ==
+					NL80211_CMD_SCAN_ABORTED) {
+		printf("scan aborted!\n");
+		return 0;
+	}
+
+	dump_argv[0] = argv[0];
+	return handle_cmd(state, II_NETDEV, dump_argc, dump_argv);
+}
+TOPLEVEL(scan, "[-u] [freq <freq>*] [ies <hex as 00:11:..>] [ssid <ssid>*|passive]", 0, 0,
+	 CIB_NETDEV, handle_scan_combined,
+	 "Scan on the given frequencies and probe for the given SSIDs\n"
+	 "(or wildcard if not given) unless passive scanning is requested.\n"
+	 "If -u is specified print unknown data in the scan results.\n"
+	 "Specified (vendor) IEs must be well-formed.");
+COMMAND(scan, dump, "[-u]",
+	NL80211_CMD_GET_SCAN, NLM_F_DUMP, CIB_NETDEV, handle_scan_dump,
+	"Dump the current scan results. If -u is specified, print unknown\n"
+	"data in scan results.");
+COMMAND(scan, trigger, "[freq <freq>*] [ies <hex as 00:11:..>] [ssid <ssid>*|passive]",
+	NL80211_CMD_TRIGGER_SCAN, 0, CIB_NETDEV, handle_scan,
+	 "Trigger a scan on the given frequencies with probing for the given\n"
+	 "SSIDs (or wildcard if not given) unless passive scanning is requested.");
diff --git a/external/iw/sections.c b/external/iw/sections.c
new file mode 100644
index 0000000..38095f6
--- /dev/null
+++ b/external/iw/sections.c
@@ -0,0 +1,4 @@
+#include "iw.h"
+
+SECTION(get);
+SECTION(set);
diff --git a/external/iw/station.c b/external/iw/station.c
new file mode 100644
index 0000000..be2301f
--- /dev/null
+++ b/external/iw/station.c
@@ -0,0 +1,328 @@
+#include <net/if.h>
+#include <errno.h>
+#include <string.h>
+
+#include <netlink/genl/genl.h>
+#include <netlink/genl/family.h>
+#include <netlink/genl/ctrl.h>
+#include <netlink/msg.h>
+#include <netlink/attr.h>
+
+#include "nl80211.h"
+#include "iw.h"
+
+SECTION(station);
+
+enum plink_state {
+	LISTEN,
+	OPN_SNT,
+	OPN_RCVD,
+	CNF_RCVD,
+	ESTAB,
+	HOLDING,
+	BLOCKED
+};
+
+enum plink_actions {
+	PLINK_ACTION_UNDEFINED,
+	PLINK_ACTION_OPEN,
+	PLINK_ACTION_BLOCK,
+};
+
+
+static int print_sta_handler(struct nl_msg *msg, void *arg)
+{
+	struct nlattr *tb[NL80211_ATTR_MAX + 1];
+	struct genlmsghdr *gnlh = nlmsg_data(nlmsg_hdr(msg));
+	struct nlattr *sinfo[NL80211_STA_INFO_MAX + 1];
+	struct nlattr *rinfo[NL80211_RATE_INFO_MAX + 1];
+	char mac_addr[20], state_name[10], dev[20];
+	static struct nla_policy stats_policy[NL80211_STA_INFO_MAX + 1] = {
+		[NL80211_STA_INFO_INACTIVE_TIME] = { .type = NLA_U32 },
+		[NL80211_STA_INFO_RX_BYTES] = { .type = NLA_U32 },
+		[NL80211_STA_INFO_TX_BYTES] = { .type = NLA_U32 },
+		[NL80211_STA_INFO_RX_PACKETS] = { .type = NLA_U32 },
+		[NL80211_STA_INFO_TX_PACKETS] = { .type = NLA_U32 },
+		[NL80211_STA_INFO_SIGNAL] = { .type = NLA_U8 },
+		[NL80211_STA_INFO_TX_BITRATE] = { .type = NLA_NESTED },
+		[NL80211_STA_INFO_LLID] = { .type = NLA_U16 },
+		[NL80211_STA_INFO_PLID] = { .type = NLA_U16 },
+		[NL80211_STA_INFO_PLINK_STATE] = { .type = NLA_U8 },
+		[NL80211_STA_INFO_TX_RETRIES] = { .type = NLA_U32 },
+		[NL80211_STA_INFO_TX_FAILED] = { .type = NLA_U32 },
+	};
+
+	static struct nla_policy rate_policy[NL80211_RATE_INFO_MAX + 1] = {
+		[NL80211_RATE_INFO_BITRATE] = { .type = NLA_U16 },
+		[NL80211_RATE_INFO_MCS] = { .type = NLA_U8 },
+		[NL80211_RATE_INFO_40_MHZ_WIDTH] = { .type = NLA_FLAG },
+		[NL80211_RATE_INFO_SHORT_GI] = { .type = NLA_FLAG },
+	};
+
+	nla_parse(tb, NL80211_ATTR_MAX, genlmsg_attrdata(gnlh, 0),
+		  genlmsg_attrlen(gnlh, 0), NULL);
+
+	/*
+	 * TODO: validate the interface and mac address!
+	 * Otherwise, there's a race condition as soon as
+	 * the kernel starts sending station notifications.
+	 */
+
+	if (!tb[NL80211_ATTR_STA_INFO]) {
+		fprintf(stderr, "sta stats missing!\n");
+		return NL_SKIP;
+	}
+	if (nla_parse_nested(sinfo, NL80211_STA_INFO_MAX,
+			     tb[NL80211_ATTR_STA_INFO],
+			     stats_policy)) {
+		fprintf(stderr, "failed to parse nested attributes!\n");
+		return NL_SKIP;
+	}
+
+	mac_addr_n2a(mac_addr, nla_data(tb[NL80211_ATTR_MAC]));
+	if_indextoname(nla_get_u32(tb[NL80211_ATTR_IFINDEX]), dev);
+	printf("Station %s (on %s)", mac_addr, dev);
+
+	if (sinfo[NL80211_STA_INFO_INACTIVE_TIME])
+		printf("\n\tinactive time:\t%u ms",
+			nla_get_u32(sinfo[NL80211_STA_INFO_INACTIVE_TIME]));
+	if (sinfo[NL80211_STA_INFO_RX_BYTES])
+		printf("\n\trx bytes:\t%u",
+			nla_get_u32(sinfo[NL80211_STA_INFO_RX_BYTES]));
+	if (sinfo[NL80211_STA_INFO_RX_PACKETS])
+		printf("\n\trx packets:\t%u",
+			nla_get_u32(sinfo[NL80211_STA_INFO_RX_PACKETS]));
+	if (sinfo[NL80211_STA_INFO_TX_BYTES])
+		printf("\n\ttx bytes:\t%u",
+			nla_get_u32(sinfo[NL80211_STA_INFO_TX_BYTES]));
+	if (sinfo[NL80211_STA_INFO_TX_PACKETS])
+		printf("\n\ttx packets:\t%u",
+			nla_get_u32(sinfo[NL80211_STA_INFO_TX_PACKETS]));
+	if (sinfo[NL80211_STA_INFO_TX_RETRIES])
+		printf("\n\ttx retries:\t%u",
+			nla_get_u32(sinfo[NL80211_STA_INFO_TX_RETRIES]));
+	if (sinfo[NL80211_STA_INFO_TX_FAILED])
+		printf("\n\ttx failed:\t%u",
+			nla_get_u32(sinfo[NL80211_STA_INFO_TX_FAILED]));
+	if (sinfo[NL80211_STA_INFO_SIGNAL])
+		printf("\n\tsignal:  \t%d dBm",
+			(int8_t)nla_get_u8(sinfo[NL80211_STA_INFO_SIGNAL]));
+
+	if (sinfo[NL80211_STA_INFO_TX_BITRATE]) {
+		if (nla_parse_nested(rinfo, NL80211_RATE_INFO_MAX,
+				     sinfo[NL80211_STA_INFO_TX_BITRATE], rate_policy)) {
+			fprintf(stderr, "failed to parse nested rate attributes!\n");
+		} else {
+			printf("\n\ttx bitrate:\t");
+			if (rinfo[NL80211_RATE_INFO_BITRATE]) {
+				int rate = nla_get_u16(rinfo[NL80211_RATE_INFO_BITRATE]);
+				printf("%d.%d MBit/s", rate / 10, rate % 10);
+			}
+
+			if (rinfo[NL80211_RATE_INFO_MCS])
+				printf(" MCS %d", nla_get_u8(rinfo[NL80211_RATE_INFO_MCS]));
+			if (rinfo[NL80211_RATE_INFO_40_MHZ_WIDTH])
+				printf(" 40Mhz");
+			if (rinfo[NL80211_RATE_INFO_SHORT_GI])
+				printf(" short GI");
+		}
+	}
+
+	if (sinfo[NL80211_STA_INFO_LLID])
+		printf("\n\tmesh llid:\t%d",
+			nla_get_u16(sinfo[NL80211_STA_INFO_LLID]));
+	if (sinfo[NL80211_STA_INFO_PLID])
+		printf("\n\tmesh plid:\t%d",
+			nla_get_u16(sinfo[NL80211_STA_INFO_PLID]));
+	if (sinfo[NL80211_STA_INFO_PLINK_STATE]) {
+		switch (nla_get_u8(sinfo[NL80211_STA_INFO_PLINK_STATE])) {
+		case LISTEN:
+			strcpy(state_name, "LISTEN");
+			break;
+		case OPN_SNT:
+			strcpy(state_name, "OPN_SNT");
+			break;
+		case OPN_RCVD:
+			strcpy(state_name, "OPN_RCVD");
+			break;
+		case CNF_RCVD:
+			strcpy(state_name, "CNF_RCVD");
+			break;
+		case ESTAB:
+			strcpy(state_name, "ESTAB");
+			break;
+		case HOLDING:
+			strcpy(state_name, "HOLDING");
+			break;
+		case BLOCKED:
+			strcpy(state_name, "BLOCKED");
+			break;
+		default:
+			strcpy(state_name, "UNKNOWN");
+			break;
+		}
+		printf("\n\tmesh plink:\t%s", state_name);
+	}
+
+	printf("\n");
+	return NL_SKIP;
+}
+
+static int handle_station_get(struct nl80211_state *state,
+			      struct nl_cb *cb,
+			      struct nl_msg *msg,
+			      int argc, char **argv)
+{
+	unsigned char mac_addr[ETH_ALEN];
+
+	if (argc < 1)
+		return 1;
+
+	if (mac_addr_a2n(mac_addr, argv[0])) {
+		fprintf(stderr, "invalid mac address\n");
+		return 2;
+	}
+
+	argc--;
+	argv++;
+
+	if (argc)
+		return 1;
+
+	NLA_PUT(msg, NL80211_ATTR_MAC, ETH_ALEN, mac_addr);
+
+	nl_cb_set(cb, NL_CB_VALID, NL_CB_CUSTOM, print_sta_handler, NULL);
+
+	return 0;
+ nla_put_failure:
+	return -ENOBUFS;
+}
+COMMAND(station, get, "<MAC address>",
+	NL80211_CMD_GET_STATION, 0, CIB_NETDEV, handle_station_get,
+	"Get information for a specific station.");
+COMMAND(station, del, "<MAC address>",
+	NL80211_CMD_DEL_STATION, 0, CIB_NETDEV, handle_station_get,
+	"Remove the given station entry (use with caution!)");
+
+static const struct cmd *station_set_plink;
+static const struct cmd *station_set_vlan;
+
+static const struct cmd *select_station_cmd(int argc, char **argv)
+{
+	if (argc < 2)
+		return NULL;
+	if (strcmp(argv[1], "plink_action") == 0)
+		return station_set_plink;
+	if (strcmp(argv[1], "vlan") == 0)
+		return station_set_vlan;
+	return NULL;
+}
+
+static int handle_station_set_plink(struct nl80211_state *state,
+			      struct nl_cb *cb,
+			      struct nl_msg *msg,
+			      int argc, char **argv)
+{
+	unsigned char plink_action;
+	unsigned char mac_addr[ETH_ALEN];
+
+	if (argc < 3)
+		return 1;
+
+	if (mac_addr_a2n(mac_addr, argv[0])) {
+		fprintf(stderr, "invalid mac address\n");
+		return 2;
+	}
+	argc--;
+	argv++;
+
+	if (strcmp("plink_action", argv[0]) != 0)
+		return 1;
+	argc--;
+	argv++;
+
+	if (strcmp("open", argv[0]) == 0)
+		plink_action = PLINK_ACTION_OPEN;
+	else if (strcmp("block", argv[0]) == 0)
+		plink_action = PLINK_ACTION_BLOCK;
+	else {
+		fprintf(stderr, "plink action not supported\n");
+		return 2;
+	}
+	argc--;
+	argv++;
+
+	if (argc)
+		return 1;
+
+	NLA_PUT(msg, NL80211_ATTR_MAC, ETH_ALEN, mac_addr);
+	NLA_PUT_U8(msg, NL80211_ATTR_STA_PLINK_ACTION, plink_action);
+
+	return 0;
+ nla_put_failure:
+	return -ENOBUFS;
+}
+COMMAND_ALIAS(station, set, "<MAC address> plink_action <open|block>",
+	NL80211_CMD_SET_STATION, 0, CIB_NETDEV, handle_station_set_plink,
+	"Set mesh peer link action for this station (peer).",
+	select_station_cmd, station_set_plink);
+
+static int handle_station_set_vlan(struct nl80211_state *state,
+			      struct nl_cb *cb,
+			      struct nl_msg *msg,
+			      int argc, char **argv)
+{
+	unsigned char mac_addr[ETH_ALEN];
+	unsigned long sta_vlan = 0;
+	char *err = NULL;
+
+	if (argc < 3)
+		return 1;
+
+	if (mac_addr_a2n(mac_addr, argv[0])) {
+		fprintf(stderr, "invalid mac address\n");
+		return 2;
+	}
+	argc--;
+	argv++;
+
+	if (strcmp("vlan", argv[0]) != 0)
+		return 1;
+	argc--;
+	argv++;
+
+	sta_vlan = strtoul(argv[0], &err, 0);
+	if (err && *err) {
+		fprintf(stderr, "invalid vlan id\n");
+		return 2;
+	}
+	argc--;
+	argv++;
+
+	if (argc)
+		return 1;
+
+	NLA_PUT(msg, NL80211_ATTR_MAC, ETH_ALEN, mac_addr);
+	NLA_PUT_U32(msg, NL80211_ATTR_STA_VLAN, sta_vlan);
+
+	return 0;
+ nla_put_failure:
+	return -ENOBUFS;
+}
+COMMAND_ALIAS(station, set, "<MAC address> vlan <ifindex>",
+	NL80211_CMD_SET_STATION, 0, CIB_NETDEV, handle_station_set_vlan,
+	"Set an AP VLAN for this station.",
+	select_station_cmd, station_set_vlan);
+
+
+static int handle_station_dump(struct nl80211_state *state,
+			       struct nl_cb *cb,
+			       struct nl_msg *msg,
+			       int argc, char **argv)
+{
+	nl_cb_set(cb, NL_CB_VALID, NL_CB_CUSTOM, print_sta_handler, NULL);
+	return 0;
+}
+COMMAND(station, dump, NULL,
+	NL80211_CMD_GET_STATION, NLM_F_DUMP, CIB_NETDEV, handle_station_dump,
+	"List all stations known, e.g. the AP on managed interfaces");
diff --git a/external/iw/status.c b/external/iw/status.c
new file mode 100644
index 0000000..731727d
--- /dev/null
+++ b/external/iw/status.c
@@ -0,0 +1,59 @@
+#include <stdint.h>
+#include "iw.h"
+
+static const char *status_table[] = {
+	[0] = "Successful",
+	[1] = "Unspecified failure",
+	[10] = "Cannot support all requested capabilities in the capability information field",
+	[11] = "Reassociation denied due to inability to confirm that association exists",
+	[12] = "Association denied due to reason outside the scope of this standard",
+	[13] = "Responding station does not support the specified authentication algorithm",
+	[14] = "Received an authentication frame with authentication transaction sequence number out of expected sequence",
+	[15] = "Authentication rejected because of challenge failure",
+	[16] = "Authentication rejected due to timeout waiting for next frame in sequence",
+	[17] = "Association denied because AP is unable to handle additional associated STA",
+	[18] = "Association denied due to requesting station not supporting all of the data rates in the BSSBasicRateSet parameter",
+	[19] = "Association denied due to requesting station not supporting the short preamble option",
+	[20] = "Association denied due to requesting station not supporting the PBCC modulation option",
+	[21] = "Association denied due to requesting station not supporting the channel agility option",
+	[22] = "Association request rejected because Spectrum Management capability is required",
+	[23] = "Association request rejected because the information in the Power Capability element is unacceptable",
+	[24] = "Association request rejected because the information in the Supported Channels element is unacceptable",
+	[25] = "Association request rejected due to requesting station not supporting the short slot time option",
+	[26] = "Association request rejected due to requesting station not supporting the ER-PBCC modulation option",
+	[27] = "Association denied due to requesting STA not supporting HT features",
+	[28] = "R0KH Unreachable",
+	[29] = "Association denied because the requesting STA does not support the PCO transition required by the AP",
+	[30] = "Association request rejected temporarily; try again later",
+	[31] = "Robust Management frame policy violation",
+	[32] = "Unspecified, QoS related failure",
+	[33] = "Association denied due to QAP having insufficient bandwidth to handle another QSTA",
+	[34] = "Association denied due to poor channel conditions",
+	[35] = "Association (with QBSS) denied due to requesting station not supporting the QoS facility",
+	[37] = "The request has been declined",
+	[38] = "The request has not been successful as one or more parameters have invalid values",
+	[39] = "The TS has not been created because the request cannot be honored. However, a suggested Tspec is provided so that the initiating QSTA may attempt to send another TS with the suggested changes to the TSpec",
+	[40] = "Invalid Information Element",
+	[41] = "Group Cipher is not valid",
+	[42] = "Pairwise Cipher is not valid",
+	[43] = "AKMP is not valid",
+	[44] = "Unsupported RSN IE version",
+	[45] = "Invalid RSN IE Capabilities",
+	[46] = "Cipher suite is rejected per security policy",
+	[47] = "The TS has not been created. However, the HC may be capable of creating a TS, in response to a request, after the time indicated in the TS Delay element",
+	[48] = "Direct link is not allowed in the BSS by policy",
+	[49] = "Destination STA is not present within this QBSS",
+	[50] = "The destination STA is not a QSTA",
+	[51] = "Association denied because Listen Interval is too large",
+	[52] = "Invalid Fast BSS Transition Action Frame Count",
+	[53] = "Invalid PMKID",
+	[54] = "Invalid MDIE",
+	[55] = "Invalid FTIE",
+};
+
+const char *get_status_str(uint16_t status)
+{
+	if (status < ARRAY_SIZE(status_table) && status_table[status])
+		return status_table[status];
+	return "<unknown>";
+}
diff --git a/external/iw/survey.c b/external/iw/survey.c
new file mode 100644
index 0000000..f9f2508
--- /dev/null
+++ b/external/iw/survey.c
@@ -0,0 +1,66 @@
+#include <net/if.h>
+#include <errno.h>
+#include <string.h>
+
+#include <netlink/genl/genl.h>
+#include <netlink/genl/family.h>
+#include <netlink/genl/ctrl.h>
+#include <netlink/msg.h>
+#include <netlink/attr.h>
+
+#include "nl80211.h"
+#include "iw.h"
+
+SECTION(survey);
+
+static int print_survey_handler(struct nl_msg *msg, void *arg)
+{
+	struct nlattr *tb[NL80211_ATTR_MAX + 1];
+	struct genlmsghdr *gnlh = nlmsg_data(nlmsg_hdr(msg));
+	struct nlattr *sinfo[NL80211_SURVEY_INFO_MAX + 1];
+	char dev[20];
+
+	static struct nla_policy survey_policy[NL80211_SURVEY_INFO_MAX + 1] = {
+		[NL80211_SURVEY_INFO_FREQUENCY] = { .type = NLA_U32 },
+		[NL80211_SURVEY_INFO_NOISE] = { .type = NLA_U8 },
+	};
+
+	nla_parse(tb, NL80211_ATTR_MAX, genlmsg_attrdata(gnlh, 0),
+		  genlmsg_attrlen(gnlh, 0), NULL);
+
+	if_indextoname(nla_get_u32(tb[NL80211_ATTR_IFINDEX]), dev);
+	printf("Survey data from %s\n", dev);
+
+	if (!tb[NL80211_ATTR_SURVEY_INFO]) {
+		fprintf(stderr, "survey data missing!\n");
+		return NL_SKIP;
+	}
+
+	if (nla_parse_nested(sinfo, NL80211_SURVEY_INFO_MAX,
+			     tb[NL80211_ATTR_SURVEY_INFO],
+			     survey_policy)) {
+		fprintf(stderr, "failed to parse nested attributes!\n");
+		return NL_SKIP;
+	}
+
+	if (sinfo[NL80211_SURVEY_INFO_FREQUENCY])
+		printf("\tfrequency:\t%u MHz\n",
+			nla_get_u32(sinfo[NL80211_SURVEY_INFO_FREQUENCY]));
+	if (sinfo[NL80211_SURVEY_INFO_NOISE])
+		printf("\tnoise:\t\t%d dBm\n",
+			(int8_t)nla_get_u8(sinfo[NL80211_SURVEY_INFO_NOISE]));
+	return NL_SKIP;
+}
+
+static int handle_survey_dump(struct nl80211_state *state,
+			       struct nl_cb *cb,
+			       struct nl_msg *msg,
+			       int argc, char **argv)
+{
+	nl_cb_set(cb, NL_CB_VALID, NL_CB_CUSTOM, print_survey_handler, NULL);
+	return 0;
+}
+COMMAND(survey, dump, NULL,
+	NL80211_CMD_GET_SURVEY, NLM_F_DUMP, CIB_NETDEV, handle_survey_dump,
+	"List all gathered channel survey data");
+
diff --git a/external/iw/util.c b/external/iw/util.c
new file mode 100644
index 0000000..7e40457
--- /dev/null
+++ b/external/iw/util.c
@@ -0,0 +1,521 @@
+#include <ctype.h>
+#include <netlink/attr.h>
+#include <errno.h>
+#include <stdbool.h>
+#include "iw.h"
+#include "nl80211.h"
+
+void mac_addr_n2a(char *mac_addr, unsigned char *arg)
+{
+	int i, l;
+
+	l = 0;
+	for (i = 0; i < ETH_ALEN ; i++) {
+		if (i == 0) {
+			sprintf(mac_addr+l, "%02x", arg[i]);
+			l += 2;
+		} else {
+			sprintf(mac_addr+l, ":%02x", arg[i]);
+			l += 3;
+		}
+	}
+}
+
+int mac_addr_a2n(unsigned char *mac_addr, char *arg)
+{
+	int i;
+
+	for (i = 0; i < ETH_ALEN ; i++) {
+		int temp;
+		char *cp = strchr(arg, ':');
+		if (cp) {
+			*cp = 0;
+			cp++;
+		}
+		if (sscanf(arg, "%x", &temp) != 1)
+			return -1;
+		if (temp < 0 || temp > 255)
+			return -1;
+
+		mac_addr[i] = temp;
+		if (!cp)
+			break;
+		arg = cp;
+	}
+	if (i < ETH_ALEN - 1)
+		return -1;
+
+	return 0;
+}
+
+unsigned char *parse_hex(char *hex, size_t *outlen)
+{
+	size_t len = strlen(hex);
+	unsigned char *result = calloc(len/2 + 2, 1);
+	int pos = 0;
+
+	if (!result)
+		return NULL;
+
+	*outlen = 0;
+
+	while (1) {
+		int temp;
+		char *cp = strchr(hex, ':');
+		if (cp) {
+			*cp = 0;
+			cp++;
+		}
+		if (sscanf(hex, "%x", &temp) != 1)
+			goto error;
+		if (temp < 0 || temp > 255)
+			goto error;
+
+		(*outlen)++;
+
+		result[pos++] = temp;
+		if (!cp)
+			break;
+		hex = cp;
+	}
+
+	return result;
+ error:
+	free(result);
+	return NULL;
+}
+
+static const char *ifmodes[NL80211_IFTYPE_MAX + 1] = {
+	"unspecified",
+	"IBSS",
+	"managed",
+	"AP",
+	"AP/VLAN",
+	"WDS",
+	"monitor",
+	"mesh point",
+	"P2P-client",
+	"P2P-GO",
+};
+
+static char modebuf[100];
+
+const char *iftype_name(enum nl80211_iftype iftype)
+{
+	if (iftype <= NL80211_IFTYPE_MAX)
+		return ifmodes[iftype];
+	sprintf(modebuf, "Unknown mode (%d)", iftype);
+	return modebuf;
+}
+
+static const char *commands[NL80211_CMD_MAX + 1] = {
+	[NL80211_CMD_GET_WIPHY] = "get_wiphy",
+	[NL80211_CMD_SET_WIPHY] = "set_wiphy",
+	[NL80211_CMD_NEW_WIPHY] = "new_wiphy",
+	[NL80211_CMD_DEL_WIPHY] = "del_wiphy",
+	[NL80211_CMD_GET_INTERFACE] = "get_interface",
+	[NL80211_CMD_SET_INTERFACE] = "set_interface",
+	[NL80211_CMD_NEW_INTERFACE] = "new_interface",
+	[NL80211_CMD_DEL_INTERFACE] = "del_interface",
+	[NL80211_CMD_GET_KEY] = "get_key",
+	[NL80211_CMD_SET_KEY] = "set_key",
+	[NL80211_CMD_NEW_KEY] = "new_key",
+	[NL80211_CMD_DEL_KEY] = "del_key",
+	[NL80211_CMD_GET_BEACON] = "get_beacon",
+	[NL80211_CMD_SET_BEACON] = "set_beacon",
+	[NL80211_CMD_NEW_BEACON] = "new_beacon",
+	[NL80211_CMD_DEL_BEACON] = "del_beacon",
+	[NL80211_CMD_GET_STATION] = "get_station",
+	[NL80211_CMD_SET_STATION] = "set_station",
+	[NL80211_CMD_NEW_STATION] = "new_station",
+	[NL80211_CMD_DEL_STATION] = "del_station",
+	[NL80211_CMD_GET_MPATH] = "get_mpath",
+	[NL80211_CMD_SET_MPATH] = "set_mpath",
+	[NL80211_CMD_NEW_MPATH] = "new_mpath",
+	[NL80211_CMD_DEL_MPATH] = "del_mpath",
+	[NL80211_CMD_SET_BSS] = "set_bss",
+	[NL80211_CMD_SET_REG] = "set_reg",
+	[NL80211_CMD_REQ_SET_REG] = "reg_set_reg",
+	[NL80211_CMD_GET_MESH_PARAMS] = "get_mesh_params",
+	[NL80211_CMD_SET_MESH_PARAMS] = "set_mesh_params",
+	[NL80211_CMD_SET_MGMT_EXTRA_IE] = "set_mgmt_extra_ie",
+	[NL80211_CMD_GET_REG] = "get_reg",
+	[NL80211_CMD_GET_SCAN] = "get_scan",
+	[NL80211_CMD_TRIGGER_SCAN] = "trigger_scan",
+	[NL80211_CMD_NEW_SCAN_RESULTS] = "new_scan_results",
+	[NL80211_CMD_SCAN_ABORTED] = "scan_aborted",
+	[NL80211_CMD_REG_CHANGE] = "reg_change",
+	[NL80211_CMD_AUTHENTICATE] = "authenticate",
+	[NL80211_CMD_ASSOCIATE] = "associate",
+	[NL80211_CMD_DEAUTHENTICATE] = "deauthenticate",
+	[NL80211_CMD_DISASSOCIATE] = "disassociate",
+	[NL80211_CMD_MICHAEL_MIC_FAILURE] = "michael_mic_failure",
+	[NL80211_CMD_REG_BEACON_HINT] = "reg_beacon_hint",
+	[NL80211_CMD_JOIN_IBSS] = "join_ibss",
+	[NL80211_CMD_LEAVE_IBSS] = "leave_ibss",
+	[NL80211_CMD_TESTMODE] = "testmode",
+	[NL80211_CMD_CONNECT] = "connect",
+	[NL80211_CMD_ROAM] = "roam",
+	[NL80211_CMD_DISCONNECT] = "disconnect",
+	[NL80211_CMD_SET_WIPHY_NETNS] = "set_wiphy_netns",
+	[NL80211_CMD_GET_SURVEY] = "get_survey",
+	[NL80211_CMD_SET_PMKSA] = "set_pmksa",
+	[NL80211_CMD_DEL_PMKSA] = "del_pmksa",
+	[NL80211_CMD_FLUSH_PMKSA] = "flush_pmksa",
+	[NL80211_CMD_REMAIN_ON_CHANNEL] = "remain_on_channel",
+	[NL80211_CMD_CANCEL_REMAIN_ON_CHANNEL] = "cancel_remain_on_channel",
+	[NL80211_CMD_SET_TX_BITRATE_MASK] = "set_tx_bitrate_mask",
+	[NL80211_CMD_REGISTER_ACTION] = "register_action",
+	[NL80211_CMD_ACTION] = "action",
+	[NL80211_CMD_SET_CHANNEL] = "set_channel",
+};
+
+static char cmdbuf[100];
+
+const char *command_name(enum nl80211_commands cmd)
+{
+	if (cmd <= NL80211_CMD_MAX && commands[cmd])
+		return commands[cmd];
+	sprintf(cmdbuf, "Unknown command (%d)", cmd);
+	return cmdbuf;
+}
+
+int ieee80211_channel_to_frequency(int chan)
+{
+	if (chan < 14)
+		return 2407 + chan * 5;
+
+	if (chan == 14)
+		return 2484;
+
+	/* FIXME: dot11ChannelStartingFactor (802.11-2007 17.3.8.3.2) */
+	return (chan + 1000) * 5;
+}
+
+int ieee80211_frequency_to_channel(int freq)
+{
+	if (freq == 2484)
+		return 14;
+
+	if (freq < 2484)
+		return (freq - 2407) / 5;
+
+	/* FIXME: dot11ChannelStartingFactor (802.11-2007 17.3.8.3.2) */
+	return freq/5 - 1000;
+}
+
+void print_ssid_escaped(const uint8_t len, const uint8_t *data)
+{
+	int i;
+
+	for (i = 0; i < len; i++) {
+		if (isprint(data[i]))
+			printf("%c", data[i]);
+		else
+			printf("\\x%.2x", data[i]);
+	}
+}
+
+static int hex2num(char digit)
+{
+	if (!isxdigit(digit))
+		return -1;
+	if (isdigit(digit))
+		return digit - '0';
+	return tolower(digit) - 'a' + 10;
+}
+
+static int hex2byte(char *hex)
+{
+	int d1, d2;
+
+	d1 = hex2num(hex[0]);
+	if (d1 < 0)
+		return -1;
+	d2 = hex2num(hex[1]);
+	if (d2 < 0)
+		return -1;
+	return (d1 << 4) | d2;
+}
+
+static char *hex2bin(char *hex, char *buf)
+{
+	char *result = buf;
+	int d;
+
+	while (hex[0]) {
+		d = hex2byte(hex);
+		if (d < 0)
+			return NULL;
+		buf[0] = d;
+		buf++;
+		hex += 2;
+	}
+
+	return result;
+}
+
+int parse_keys(struct nl_msg *msg, char **argv, int argc)
+{
+	struct nlattr *keys;
+	int i = 0;
+	bool have_default = false;
+	char keybuf[13];
+
+	if (!argc)
+		return 1;
+
+	NLA_PUT_FLAG(msg, NL80211_ATTR_PRIVACY);
+
+	keys = nla_nest_start(msg, NL80211_ATTR_KEYS);
+	if (!keys)
+		return -ENOBUFS;
+
+	do {
+		char *arg = *argv;
+		int pos = 0, keylen;
+		struct nlattr *key = nla_nest_start(msg, ++i);
+		char *keydata;
+
+		if (!key)
+			return -ENOBUFS;
+
+		if (arg[pos] == 'd') {
+			NLA_PUT_FLAG(msg, NL80211_KEY_DEFAULT);
+			pos++;
+			if (arg[pos] == ':')
+				pos++;
+			have_default = true;
+		}
+
+		if (!isdigit(arg[pos]))
+			goto explain;
+		NLA_PUT_U8(msg, NL80211_KEY_IDX, arg[pos++] - '0');
+		if (arg[pos++] != ':')
+			goto explain;
+		keydata = arg + pos;
+		switch (strlen(keydata)) {
+		case 10:
+			keydata = hex2bin(keydata, keybuf);
+		case 5:
+			NLA_PUT_U32(msg, NL80211_KEY_CIPHER, 0x000FAC01);
+			keylen = 5;
+			break;
+		case 26:
+			keydata = hex2bin(keydata, keybuf);
+		case 13:
+			NLA_PUT_U32(msg, NL80211_KEY_CIPHER, 0x000FAC05);
+			keylen = 13;
+			break;
+		default:
+			goto explain;
+		}
+
+		if (!keydata)
+			goto explain;
+
+		NLA_PUT(msg, NL80211_KEY_DATA, keylen, keydata);
+
+		argv++;
+		argc--;
+
+		/* one key should be TX key */
+		if (!have_default && !argc)
+			NLA_PUT_FLAG(msg, NL80211_KEY_DEFAULT);
+
+		nla_nest_end(msg, key);
+	} while (argc);
+
+	nla_nest_end(msg, keys);
+
+	return 0;
+ nla_put_failure:
+	return -ENOBUFS;
+ explain:
+	fprintf(stderr, "key must be [d:]index:data where\n"
+			"  'd:'     means default (transmit) key\n"
+			"  'index:' is a single digit (0-3)\n"
+			"  'data'   must be 5 or 13 ascii chars\n"
+			"           or 10 or 26 hex digits\n"
+			"for example: d:2:6162636465 is the same as d:2:abcde\n");
+	return 2;
+}
+
+static void print_mcs_index(const __u8 *mcs)
+{
+	unsigned int mcs_bit, prev_bit = -2, prev_cont = 0;
+
+	for (mcs_bit = 0; mcs_bit <= 76; mcs_bit++) {
+		unsigned int mcs_octet = mcs_bit/8;
+		unsigned int MCS_RATE_BIT = 1 << mcs_bit % 8;
+		bool mcs_rate_idx_set;
+
+		mcs_rate_idx_set = !!(mcs[mcs_octet] & MCS_RATE_BIT);
+
+		if (!mcs_rate_idx_set)
+			continue;
+
+		if (prev_bit != mcs_bit - 1) {
+			if (prev_bit != -2)
+				printf("%d, ", prev_bit);
+			else
+				printf(" ");
+			printf("%d", mcs_bit);
+			prev_cont = 0;
+		} else if (!prev_cont) {
+			printf("-");
+			prev_cont = 1;
+		}
+
+		prev_bit = mcs_bit;
+	}
+
+	if (prev_cont)
+		printf("%d", prev_bit);
+	printf("\n");
+}
+
+/*
+ * There are only 4 possible values, we just use a case instead of computing it,
+ * but technically this can also be computed through the formula:
+ *
+ * Max AMPDU length = (2 ^ (13 + exponent)) - 1 bytes
+ */
+static __u32 compute_ampdu_length(__u8 exponent)
+{
+	switch (exponent) {
+	case 0: return 8191;  /* (2 ^(13 + 0)) -1 */
+	case 1: return 16383; /* (2 ^(13 + 1)) -1 */
+	case 2: return 32767; /* (2 ^(13 + 2)) -1 */
+	case 3: return 65535; /* (2 ^(13 + 3)) -1 */
+	default: return 0;
+	}
+}
+
+static const char *print_ampdu_space(__u8 space)
+{
+	switch (space) {
+	case 0: return "No restriction";
+	case 1: return "1/4 usec";
+	case 2: return "1/2 usec";
+	case 3: return "1 usec";
+	case 4: return "2 usec";
+	case 5: return "4 usec";
+	case 6: return "8 usec";
+	case 7: return "16 usec";
+	default:
+		return "BUG (spacing more than 3 bits!)";
+	}
+}
+
+void print_ampdu_length(__u8 exponent)
+{
+	__u32 max_ampdu_length;
+
+	max_ampdu_length = compute_ampdu_length(exponent);
+
+	if (max_ampdu_length) {
+		printf("\t\tMaximum RX AMPDU length %d bytes (exponent: 0x0%02x)\n",
+		       max_ampdu_length, exponent);
+        } else {
+		printf("\t\tMaximum RX AMPDU length: unrecognized bytes "
+		       "(exponent: %d)\n", exponent);
+	}
+}
+
+void print_ampdu_spacing(__u8 spacing)
+{
+        printf("\t\tMinimum RX AMPDU time spacing: %s (0x%02x)\n",
+               print_ampdu_space(spacing), spacing);
+}
+
+void print_ht_capability(__u16 cap)
+{
+#define PRINT_HT_CAP(_cond, _str) \
+	do { \
+		if (_cond) \
+			printf("\t\t\t" _str "\n"); \
+	} while (0)
+
+	printf("\t\tCapabilities: 0x%02x\n", cap);
+
+	PRINT_HT_CAP((cap & BIT(0)), "RX LDPC");
+	PRINT_HT_CAP((cap & BIT(1)), "HT20/HT40");
+	PRINT_HT_CAP(!(cap & BIT(1)), "HT20");
+
+	PRINT_HT_CAP(((cap >> 2) & 0x3) == 0, "Static SM Power Save");
+	PRINT_HT_CAP(((cap >> 2) & 0x3) == 1, "Dynamic SM Power Save");
+	PRINT_HT_CAP(((cap >> 2) & 0x3) == 3, "SM Power Save disabled");
+
+	PRINT_HT_CAP((cap & BIT(4)), "RX Greenfield");
+	PRINT_HT_CAP((cap & BIT(5)), "RX HT20 SGI");
+	PRINT_HT_CAP((cap & BIT(6)), "RX HT40 SGI");
+	PRINT_HT_CAP((cap & BIT(7)), "TX STBC");
+
+	PRINT_HT_CAP(((cap >> 8) & 0x3) == 0, "No RX STBC");
+	PRINT_HT_CAP(((cap >> 8) & 0x3) == 1, "RX STBC 1-stream");
+	PRINT_HT_CAP(((cap >> 8) & 0x3) == 2, "RX STBC 2-streams");
+	PRINT_HT_CAP(((cap >> 8) & 0x3) == 3, "RX STBC 3-streams");
+
+	PRINT_HT_CAP((cap & BIT(10)), "HT Delayed Block Ack");
+
+	PRINT_HT_CAP(!(cap & BIT(11)), "Max AMSDU length: 3839 bytes");
+	PRINT_HT_CAP((cap & BIT(11)), "Max AMSDU length: 7935 bytes");
+
+	/*
+	 * For beacons and probe response this would mean the BSS
+	 * does or does not allow the usage of DSSS/CCK HT40.
+	 * Otherwise it means the STA does or does not use
+	 * DSSS/CCK HT40.
+	 */
+	PRINT_HT_CAP((cap & BIT(12)), "DSSS/CCK HT40");
+	PRINT_HT_CAP(!(cap & BIT(12)), "No DSSS/CCK HT40");
+
+	/* BIT(13) is reserved */
+
+	PRINT_HT_CAP((cap & BIT(14)), "40 MHz Intolerant");
+
+	PRINT_HT_CAP((cap & BIT(15)), "L-SIG TXOP protection");
+#undef PRINT_HT_CAP
+}
+
+void print_ht_mcs(const __u8 *mcs)
+{
+	/* As defined in 7.3.2.57.4 Supported MCS Set field */
+	unsigned int tx_max_num_spatial_streams, max_rx_supp_data_rate;
+	bool tx_mcs_set_defined, tx_mcs_set_equal, tx_unequal_modulation;
+
+	max_rx_supp_data_rate = ((mcs[10] >> 8) & ((mcs[11] & 0x3) << 8));
+	tx_mcs_set_defined = !!(mcs[12] & (1 << 0));
+	tx_mcs_set_equal = !(mcs[12] & (1 << 1));
+	tx_max_num_spatial_streams = ((mcs[12] >> 2) & 3) + 1;
+	tx_unequal_modulation = !!(mcs[12] & (1 << 4));
+
+	if (max_rx_supp_data_rate)
+		printf("\t\tHT Max RX data rate: %d Mbps\n", max_rx_supp_data_rate);
+	/* XXX: else see 9.6.0e.5.3 how to get this I think */
+
+	if (tx_mcs_set_defined) {
+		if (tx_mcs_set_equal) {
+			printf("\t\tHT TX/RX MCS rate indexes supported:");
+			print_mcs_index(mcs);
+		} else {
+			printf("\t\tHT RX MCS rate indexes supported:");
+			print_mcs_index(mcs);
+
+			if (tx_unequal_modulation)
+				printf("\t\tTX unequal modulation supported\n");
+			else
+				printf("\t\tTX unequal modulation not supported\n");
+
+			printf("\t\tHT TX Max spatial streams: %d\n",
+				tx_max_num_spatial_streams);
+
+			printf("\t\tHT TX MCS rate indexes supported may differ\n");
+		}
+	} else {
+		printf("\t\tHT RX MCS rate indexes supported:");
+		print_mcs_index(mcs);
+		printf("\t\tHT TX MCS rate indexes are undefined\n");
+	}
+}
diff --git a/external/iw/version.c b/external/iw/version.c
new file mode 100644
index 0000000..68d4489
--- /dev/null
+++ b/external/iw/version.c
@@ -0,0 +1,2 @@
+#include "iw.h"
+const char iw_version[] = "0.9.21-18-gfc08b23-dirty";
diff --git a/external/iw/version.sh b/external/iw/version.sh
new file mode 100755
index 0000000..766b37f
--- /dev/null
+++ b/external/iw/version.sh
@@ -0,0 +1,24 @@
+#!/bin/sh
+
+VERSION="0.9.21"
+OUT="$1"
+
+echo '#include "iw.h"' > "$OUT"
+
+if head=`git rev-parse --verify HEAD 2>/dev/null`; then
+	git update-index --refresh --unmerged > /dev/null
+	descr=$(git describe)
+
+	# on git builds check that the version number above
+	# is correct...
+	[ "${descr%%-*}" = "v$VERSION" ] || exit 2
+
+	v="${descr#v}"
+	if git diff-index --name-only HEAD | read dummy ; then
+		v="$v"-dirty
+	fi
+else
+	v="$VERSION"
+fi
+
+echo "const char iw_version[] = \"$v\";" >> "$OUT"
-- 
1.7.4.1

